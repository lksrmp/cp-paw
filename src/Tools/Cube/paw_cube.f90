      MODULE CUBE_MODULE
      TYPE CUB_TYPE
      INTEGER(4) :: NATOM
      REAL(8) :: O(3)
      INTEGER(4) :: GRID(3)
      REAL(8) :: VXL(3,3)
      REAL(8), ALLOCATABLE :: ATOM(:,:)
      REAL(8), ALLOCATABLE :: DATA(:,:,:)
      CHARACTER(256) :: LINE1
      CHARACTER(256) :: LINE2
      CHARACTER(256) :: FILE
      END TYPE CUB_TYPE

      TYPE CUBE_TYPE
      TYPE(CUB_TYPE) :: REAL
      TYPE(CUB_TYPE) :: IMAG
      COMPLEX(8) :: FAC
      LOGICAL(4) :: TREAL
      LOGICAL(4) :: TIMAG
      COMPLEX(8), ALLOCATABLE :: DATA(:,:,:)
      END TYPE CUBE_TYPE

      TYPE(CUBE_TYPE), ALLOCATABLE :: CUBES(:)


      INTEGER(4) :: NCUBES
      CHARACTER(256) :: REALOUT
      CHARACTER(256) :: IMAGOUT
      LOGICAL(4) :: TREAL
      LOGICAL(4) :: TIMAG


      END MODULE CUBE_MODULE

      MODULE CNTL_MODULE
      USE LINKEDLIST_MODULE, ONLY: LL_TYPE
      TYPE(LL_TYPE) :: LL_CNTL
      SAVE
      END MODULE CNTL_MODULE

      PROGRAM PAW_CUBE
      IMPLICIT NONE
                          CALL TRACE$PUSH('PAW_CUBE')
      
                          CALL TRACE$POP
      RETURN
      END PROGRAM PAW_CUBE

      SUBROUTINE INITIALIZE_FILEHANDLER
!     *********************************************************************
      USE STRINGS_MODULE
      IMPLICIT NONE
      CHARACTER(256) :: ROOTNAME
      CHARACTER(256) :: INNAME
      INTEGER(4)     :: ISVAR
      INTEGER(4)     :: NARGS
!     **************************************************************************
      NARGS=COMMAND_ARGUMENT_COUNT()
      IF(NARGS.LT.1) THEN
        CALL ERROR$MSG('ARGUMENT LIST OF EXECUTABLE IS EMPTY')
        CALL ERROR$MSG('THE CONTROL FILE OF THE CUBE TOOL IS MANDATORY')
        CALL ERROR$STOP('INITIALIZEFILEANDLER')
      END IF
      CALL GET_COMMAND_ARGUMENT(1,INNAME)
      ISVAR=INDEX(INNAME,-'.CUBCNTL',BACK=.TRUE.)
      IF(ISVAR.NE.0) THEN
        ROOTNAME=INNAME(1:ISVAR-1)
      ELSE
        ROOTNAME=' '
      END IF
      CALL FILEHANDLER$SETROOT(ROOTNAME)
      CALL STANDARDFILES
      CALL FILEHANDLER$SETFILE('CUBCNTL',.FALSE.,INNAME)
      RETURN
      END SUBROUTINE INITIALIZEFILEHANDLER

      !
!      ..1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE STANDARDFILES
!     **************************************************************************
!     **                                                                      **
!     **************************************************************************
      USE STRINGS_MODULE
      IMPLICIT NONE
      CHARACTER(32)        :: ID
!     **************************************************************************
                                   CALL TRACE$PUSH('STANDARDFILES')
!  
!     ==========================================================================
!     == SET STANDARD FILENAMES                                               ==
!     ==========================================================================
!
!     ==  ERROR FILE ===========================================================
      ID=+'ERR'
      CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.CUBERR')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','REPLACE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','APPEND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','WRITE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')
!
!     ==  PROTOCOL FILE ========================================================
      ID=+'PROT'
      CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.CUBPROT')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','REPLACE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','APPEND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','WRITE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')
!
!     ==  CONTROL FILE  == =====================================================
      ID=+'DCNTL'
      CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.CUBCNTL')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','OLD')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','REWIND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','READ')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')
!
!     ==  CUBE FILE INPUT  =====================================================
      ID=+'REALIN'
      CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.CUB')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','OLD')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','REWIND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','READ')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')
!
!     ==  CUBE FILE INPUT  =====================================================
      ID=+'IMAGIN'
      CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.CUB')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','OLD')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','REWIND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','READ')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')
!
!     ==  CUBE FILE REAL OUTPUT  ===============================================
      ID=+'REALOUT'
      CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.CUB')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','REPLACE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','APPEND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','WRITE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')
!
!     ==  CUBE FILE IMAGE OUTPUT  ===============================================
      ID=+'IMAGOUT'
      CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.CUB')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','REPLACE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','APPEND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','WRITE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE STANDARDFILES
!
!     ..1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE READCNTL
!     **************************************************************************
      USE LINKEDLIST_MODULE
      USE CNTL_MODULE, ONLY: LL_CNTL
      USE CUBE_MODULE, ONLY: REALOUT,IMAGOUT,TREAL,TIMAG,CUBES,NCUBES
      IMPLICIT NONE
      INTEGER(4) :: NFIL
      LOGICAL(4) :: TCHK
      REAL(8) :: SVAR(2)
!     **************************************************************************
                          CALL TRACE$PUSH('READCNTL')
      CALL LINKEDLIST$NEW(LL_CNTL)
      CALL FILEHANDLER$UNIT('CUBCNTL',NFIL)
      CALL LINKEDLIST$READ(LL_CNTL,NFIL,'~')

      CALL LINKEDLIST$SELECT(LL_CNTL,'~')
      CALL LINKEDLIST$MARK(LL_CNTL,1)
!     CHECK !CUBCNTL BLOCK
      CALL LINKEDLIST$EXISTL(LL_CNTL,'CUBCNTL',1,TCHK)
      IF(.NOT.TCHK) THEN
        CALL ERROR$MSG('BLOCK !CUBCNTL NOT FOUND')
        CALL ERROR$STOP('READCNTL')
      END IF
      CALL LINKEDLIST$SELECT(LL_CNTL,'CUBCNTL')
!     CHECK !CUBCNTL:!OUTPUT BLOCK
      CALL LINKEDLIST$EXISTL(LL_CNTL,'OUTPUT',1,TCHK)
      IF(.NOT.TCHK) THEN
        CALL ERROR$MSG('BLOCK !CUBCNTL:!OUTPUT NOT FOUND')
        CALL ERROR$STOP('READCNTL')
      END IF
      CALL LINKEDLIST$SELECT(LL_CNTL,'OUTPUT')
      CALL LINKEDLIST$EXISTD(LL_CNTL,'REAL',1,TREAL)
      CALL LINKEDLIST$EXISTD(LL_CNTL,'IMAG',1,TIMAG)
      IF(.NOT.TREAL.OR..NOT.TIMAG) THEN
        CALL ERROR$MSG('BLOCK !CUBCNTL:!OUTPUT:REAL OR IMAG NOT FOUND')
        CALL ERROR$STOP('READCNTL')
      END IF
      IF(TREAL) THEN
        CALL LINKEDLIST$GET(LL_CNTL,'REAL',1,REALOUT)
        CALL FILEHANDLER$SETFILE('REALOUT',.FALSE.,TRIM(REALOUT))
      ENDIF
      IF(TIMAG) THEN
        CALL LINKEDLIST$GET(LL_CNTL,'IMAG',1,IMAGOUT)
        CALL FILEHANDLER$SETFILE('IMAGOUT',.FALSE.,TRIM(IMAGOUT))
      ENDIF
!     CHECK !CUBCNTL:!CUBE BLOCK
      CALL LINKEDLIST$SELECT(LL_CNTL,'~')
      CALL LINKEDLIST$SELECT(LL_CNTL,'CUBCNTL')
      CALL LINKEDLIST$NLISTS(LL_CNTL,'CUBE',NCUBES)
      IF(NCUBES.EQ.0) THEN
        CALL ERROR$MSG('BLOCK !CUBCNTL:!CUBE NOT FOUND')
        CALL ERROR$STOP('READCNTL')
      END IF
      ALLOCATE(CUBES(NCUBES))
      DO I=1,NCUBES
        CALL LINKEDLIST$SELECT(LL_CNTL,'CUBE',I)
        CALL LINKEDLIST$EXISTD(LL_CNTL,'REAL',1,CUBES(I)%TREAL)
        CALL LINKEDLIST$EXISTD(LL_CNTL,'IMAG',1,CUBES(I)%TIMAG)
        IF(.NOT.CUBES(I)%TREAL.OR..NOT.CUBES(I)%TIMAG) THEN
          CALL ERROR$MSG('BLOCK !CUBCNTL:!CUBE:REAL OR IMAG NOT FOUND')
          CALL ERROR$I4VAL('CUBE NUMBER',I)
          CALL ERROR$STOP('READCNTL')
        END IF
        IF(CUBES(I)%TREAL) CALL LINKEDLIST$GET(LL_CNTL,'REAL',1,CUBES(I)%REAL%FILE)
        IF(CUBES(I)%TIMAG) CALL LINKEDLIST$GET(LL_CNTL,'IMAG',1,CUBES(I)%IMAG%FILE)
        CALL LINKEDLIST$EXISTD(LL_CNTL,'FAC',1,TCHK)
        IF(TCHK) THEN
          CALL LINKEDLIST$GET(LL_CNTL,'FAC',1,SVAR)
          CUBES(I)%FAC=CMPLX(SVAR(1),SVAR(2),KIND=8)
        ELSE
          CUBES(I)%FAC=CMPLX(1.0,0.0,KIND=8)
        END IF
        CALL LINKEDLIST$SELECT(LL_CNTL,'..')
      ENDDO
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE READCNTL
!
!     ..1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE READCUBES
!     **************************************************************************
      USE CUBE_MODULE, ONLY: CUBES,NCUBES
      IMPLICIT NONE
      INTEGER(4) :: I
      INTEGER(4) :: NFIL
      LOGICAL(4) :: TREAL
      LOGICAL(4) :: TIMAG
!     **************************************************************************
                          CALL TRACE$PUSH('READCUBES')
      DO I=1,NCUBES
        TREAL=CUBES(I)%TREAL
        TIMAG=CUBES(I)%TIMAG
        IF(TREAL) THEN
          CALL FILEHANDLER$SETFILE('REALIN',.FALSE.,TRIM(CUBES(I)%REAL%FILE))
          CALL FILEHANDLER$UNIT('REALIN',NFIL)
          CALL READCUB(NFIL,I,'REAL')
        ENDIF
        IF(TIMAG) THEN
          CALL FILEHANDLER$SETFILE('IMAGIN',.FALSE.,TRIM(CUBES(I)%IMAG%FILE))
          CALL FILEHANDLER$UNIT('IMAGIN',NFIL)
          CALL READCUB(NFIL,I,'IMAG')
        ENDIF

      ENDDO
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE READCUBES
!
!     ..1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE READCUB(NFIL,ICUBE,FLAG)
!     **************************************************************************
      USE CUBE_MODULE, ONLY: CUBES,CUB_TYPE
      IMPLICIT NONE
      INTEGER(4), PARAMETER :: NCOL=6
      INTEGER(4), INTENT(IN) :: NFIL
      INTEGER(4), INTENT(IN) :: ICUBE
      CHARACTER(4), INTENT(IN) :: FLAG
      TYPE(CUB_TYPE) :: CUB
      INTEGER(4) :: I,J,K,N
      INTEGER(4) :: IO
      INTEGER(4) :: NATOMS
      INTEGER(4) :: NUMVAL
      REAL(8) :: LINEVAL(NCOL)
      CHARACTER(1024) :: LINE
      REAL(8), ALLOCATABLE :: AUX(:)
!     **************************************************************************
                          CALL TRACE$PUSH('READCUB')
      IF(FLAG.NE.'REAL'.AND.FLAG.NE.'IMAG') THEN
        CALL ERROR$MSG('FLAG MUST BE REAL OR IMAG')
        CALL ERROR$STOP('READCUB')
      END IF
      IF(.NOT.ALLOCATED(CUBES)) THEN
        CALL ERROR$MSG('CUBES NOT ALLOCATED')
        CALL ERROR$STOP('READCUB')
      END IF
      IF(ICUBE.LT.1.OR.ICUBE.GT.NCUBES) THEN
        CALL ERROR$MSG('ICUBE OUT OF RANGE')
        CALL ERROR$I4VAL('ICUBE',ICUBE)
        CALL ERROR$I4VAL('NCUBES',NCUBES)
        CALL ERROR$STOP('READCUB')
      END IF
      IF(FLAG.EQ.'REAL') THEN
        CUB=CUBES(ICUBE)%REAL
      ELSE
        CUB=CUBES(ICUBE)%IMAG
      END IF
!     READ FIRST TWO COMMENT LINES
      READ(NFIL,FMT='(A)',IOSTAT=IO) CUB%LINE1
      IF(IO.NE.0) THEN
        CALL ERROR$MSG('ERROR READING COMMENT LINE 1')
        CALL ERROR$STOP('READCUB')
      END IF
      READ(NFIL,FMT='(A)',IOSTAT=IO) CUB%LINE2
      IF(IO.NE.0) THEN
        CALL ERROR$MSG('ERROR READING COMMENT LINE 2')
        CALL ERROR$STOP('READCUB')
      END IF
!     READ NUMBER OF ATOMS AND ORIGIN
      READ(NFIL,*) CUB%NATOM,CUB%O(:)
!     READ GRID SIZE AND VOXEL VECTORS
      DO I=1,3
        READ(NFIL,*) CUB%GRID(I),CUB%VXL(I,:)
      ENDDO
!     ALLOCATE AND READ ATOM INFORMATION
      ALLOCATE(CUB%ATOM(CUB%NATOM,5))
      DO I=1,CUB%NATOM
        READ(NFIL,*) CUB%ATOM(:)
      ENDDO
!     ALLOCATE DATA ARRAY
      ALLOCATE(CUB%DATA(CUB%GRID(1),CUB%GRID(2),CUB%GRID(3)))
      ALLOCATE(AUX(CUB%GRID(1)*CUB%GRID(2)*CUB%GRID(3)))
      NUMVAL=0
      DO WHILE(.TRUE.)
        READ(NFIL,'(A)',IOSTAT=IO) LINE ! READ LINE AS STRING
        IF(IO.NE.0) EXIT ! EXIT LOOP IF END OF FILE
!       READ UP TO NCOL VALUES FROM THE LINE
        READ(LINE,*,IOSTAT=IO) LINEVAL
        IF(IO.NE.0) THEN
!         HANDLE PARTIAL LINE
          READ(LINE,*,IOSTAT=IO) (AUX(NUMVAL+I),I=1,NCOL)
          IF(IO.EQ.0) THEN
            NUMVAL=NUMVAL+NCOL
          ENDIF
        ELSE
!         READ ALL NCOL VALUES
          DO I=1,NCOL
            NUMVAL=NUMVAL+1
            AUX(NUMVAL)=LINEVAL(I)
          ENDDO
        ENDIF
      ENDDO
!     READ VOLUMETRIC DATA
      N=0
      DO I=1,CUB%GRID(1)
        DO J=1,CUB%GRID(2)
          DO K=1,CUB%GRID(3)
            N=N+1
            CUB%DATA(I,J,K)=AUX(N)
          ENDDO
        ENDDO
      ENDDO
      DEALLOCATE(AUX)
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE READCUB

! TODO: DATA CHECKS OVER ALL CUBES FOR CONSISTENCY
! TODO: TRANSFER DATA TO REAL/IMAG IF ONLY IMAG/REAL IS GIVEN
! TODO: CALCULATE COMPLEX DATA, DEALLOCATE REAL/IMAG DATA AFTERWARDS
! TODO: SUM UP DATA
! TODO: WRITE DATA TO OUTPUT FILES
