      MODULE CUBE_MODULE
!     STORE DATA FROM A SINGLE CUBE FILE
      TYPE CUB_TYPE
      INTEGER(4) :: NATOM  ! NUMBER OF ATOMS
      REAL(8) :: O(3)  ! ORIGIN
      INTEGER(4) :: GRID(3)  ! NUMBER OF GRID POINTS
      REAL(8) :: VXL(3,3)  ! VOXEL VECTORS
      REAL(8), ALLOCATABLE :: ATOM(:,:)  ! ATOM INFORMATION
      REAL(8), ALLOCATABLE :: DATA(:,:,:)  ! VOLUMETRIC DATA
      CHARACTER(256) :: LINE1  ! COMMENT LINE 1
      CHARACTER(256) :: LINE2  ! COMMENT LINE 2
      CHARACTER(256) :: FILE  ! FILENAME
      END TYPE CUB_TYPE
!     STRUCTURE FOR A COMPLEX CUBE FILE CONSISTING OF REAL AND IMAGINARY PART
      TYPE CUBE_TYPE
      TYPE(CUB_TYPE) :: REAL  ! REAL PART CUBE
      TYPE(CUB_TYPE) :: IMAG  ! IMAGINARY PART CUBE
      COMPLEX(8) :: FAC  ! FACTOR FOR SUM OF COMPLEX CUBES
      REAL(8)    :: POW  ! POWER FOR CUBE
      LOGICAL(4) :: TREAL  ! REAL PART EXISTS
      LOGICAL(4) :: TIMAG  ! IMAGINARY PART EXISTS
      REAL(8) :: KPT(3)  ! K-POINT IN RECIPROCAL ANGSTROM
      COMPLEX(8), ALLOCATABLE :: CVOL(:,:,:)  ! COMPLEX VOLUMETRIC DATA
      END TYPE CUBE_TYPE

      TYPE(CUBE_TYPE), ALLOCATABLE, TARGET :: CUBES(:)  ! ARRAY OF COMPLEX CUBES
      TYPE(CUBE_TYPE), POINTER :: CPTR  ! POINTER TO COMPLEX CUBE
      TYPE(CUB_TYPE), POINTER :: PTR  ! POINTER TO REAL PART

      COMPLEX(8), ALLOCATABLE :: CUBSUM(:,:,:)  ! SUM OF COMPLEX CUBES
      INTEGER(4) :: NCUBES  ! NUMBER OF COMPLEX CUBES
      CHARACTER(256) :: REALOUT  ! REAL OUTPUT FILE
      CHARACTER(256) :: IMAGOUT  ! IMAGINARY OUTPUT FILE
      LOGICAL(4) :: TREAL  ! REAL OUTPUT EXISTS
      LOGICAL(4) :: TIMAG  ! IMAGINARY OUTPUT EXISTS
      END MODULE CUBE_MODULE

      MODULE CNTL_MODULE
      USE LINKEDLIST_MODULE, ONLY: LL_TYPE
      TYPE(LL_TYPE) :: LL_CNTL
      SAVE
      END MODULE CNTL_MODULE

      PROGRAM PAW_CUBE
      IMPLICIT NONE
                          CALL TRACE$PUSH('PAW_CUBE')
      CALL INITIALIZE_FILEHANDLER
      CALL READCNTL
      CALL READCUBES
      CALL CONSTRUCTCOMPLEXCUBE
      CALL CHECKCONSISTENCY
      CALL KPOINT
      CALL SUMCUBES
      CALL WRITECOMPLEXCUBE

                          CALL TRACE$POP
      END PROGRAM PAW_CUBE

      SUBROUTINE INITIALIZE_FILEHANDLER
!     **************************************************************************
      USE STRINGS_MODULE
      IMPLICIT NONE
      CHARACTER(256) :: ROOTNAME
      CHARACTER(256) :: INNAME
      INTEGER(4)     :: ISVAR
      INTEGER(4)     :: NARGS
!     **************************************************************************
      NARGS=COMMAND_ARGUMENT_COUNT()
      IF(NARGS.LT.1) THEN
        CALL ERROR$MSG('ARGUMENT LIST OF EXECUTABLE IS EMPTY')
        CALL ERROR$MSG('THE CONTROL FILE OF THE CUBE TOOL IS MANDATORY')
        CALL ERROR$STOP('INITIALIZEFILEANDLER')
      END IF
      CALL GET_COMMAND_ARGUMENT(1,INNAME)
      ISVAR=INDEX(INNAME,-'.CUBCNTL',BACK=.TRUE.)
      IF(ISVAR.NE.0) THEN
        ROOTNAME=INNAME(1:ISVAR-1)
      ELSE
        ROOTNAME=' '
      END IF
      CALL FILEHANDLER$SETROOT(ROOTNAME)
      CALL STANDARDFILES
      CALL FILEHANDLER$SETFILE('CUBCNTL',.FALSE.,INNAME)
      RETURN
      END SUBROUTINE INITIALIZE_FILEHANDLER

      !
!      ..1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE STANDARDFILES
!     **************************************************************************
!     **                                                                      **
!     **************************************************************************
      USE STRINGS_MODULE
      IMPLICIT NONE
      CHARACTER(32)        :: ID
!     **************************************************************************
                                   CALL TRACE$PUSH('STANDARDFILES')
!  
!     ==========================================================================
!     == SET STANDARD FILENAMES                                               ==
!     ==========================================================================
!
!     ==  ERROR FILE ===========================================================
      ID=+'ERR'
      CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.CUBERR')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','REPLACE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','APPEND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','WRITE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')
!
!     ==  PROTOCOL FILE ========================================================
      ID=+'PROT'
      CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.CUBPROT')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','REPLACE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','APPEND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','WRITE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')
!
!     ==  CONTROL FILE  == =====================================================
      ID=+'CUBCNTL'
      CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.CUBCNTL')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','OLD')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','REWIND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','READ')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')
!
!     ==  CUBE FILE INPUT  =====================================================
      ID=+'REALIN'
      CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.CUB')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','OLD')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','REWIND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','READ')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')
!
!     ==  CUBE FILE INPUT  =====================================================
      ID=+'IMAGIN'
      CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.CUB')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','OLD')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','REWIND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','READ')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')
!
!     ==  CUBE FILE REAL OUTPUT  ===============================================
      ID=+'REALOUT'
      CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.CUB')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','REPLACE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','APPEND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','WRITE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')
!
!     ==  CUBE FILE IMAGE OUTPUT  ===============================================
      ID=+'IMAGOUT'
      CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.CUB')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','REPLACE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','APPEND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','WRITE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE STANDARDFILES
!
!     ..1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE READCNTL
!     **************************************************************************
      USE LINKEDLIST_MODULE
      USE CNTL_MODULE, ONLY: LL_CNTL
      USE CUBE_MODULE, ONLY: REALOUT,IMAGOUT,TREAL,TIMAG,CUBES,NCUBES
      IMPLICIT NONE
      INTEGER(4) :: NFIL
      LOGICAL(4) :: TCHK,TCHK1
      REAL(8) :: SVAR(2)
      INTEGER(4) :: I
      REAL(8) :: ANGSTROM
!     **************************************************************************
                          CALL TRACE$PUSH('READCNTL')
      CALL CONSTANTS('ANGSTROM',ANGSTROM)
      CALL LINKEDLIST$NEW(LL_CNTL)
      CALL FILEHANDLER$UNIT('CUBCNTL',NFIL)
      CALL LINKEDLIST$READ(LL_CNTL,NFIL,'~')

      CALL LINKEDLIST$SELECT(LL_CNTL,'~')
      CALL LINKEDLIST$MARK(LL_CNTL,1)
!     CHECK !CUBCNTL BLOCK
      CALL LINKEDLIST$EXISTL(LL_CNTL,'CUBCNTL',1,TCHK)
      IF(.NOT.TCHK) THEN
        CALL ERROR$MSG('BLOCK !CUBCNTL NOT FOUND')
        CALL ERROR$STOP('READCNTL')
      END IF
      CALL LINKEDLIST$SELECT(LL_CNTL,'CUBCNTL')
!     CHECK !CUBCNTL:!OUTPUT BLOCK
      CALL LINKEDLIST$EXISTL(LL_CNTL,'OUTPUT',1,TCHK)
      IF(.NOT.TCHK) THEN
        CALL ERROR$MSG('BLOCK !CUBCNTL:!OUTPUT NOT FOUND')
        CALL ERROR$STOP('READCNTL')
      END IF
      CALL LINKEDLIST$SELECT(LL_CNTL,'OUTPUT')
      CALL LINKEDLIST$EXISTD(LL_CNTL,'REAL',1,TREAL)
      CALL LINKEDLIST$EXISTD(LL_CNTL,'IMAG',1,TIMAG)
      IF(.NOT.TREAL.AND..NOT.TIMAG) THEN
        CALL ERROR$MSG('BLOCK !CUBCNTL:!OUTPUT:REAL OR IMAG NOT FOUND')
        CALL ERROR$STOP('READCNTL')
      END IF
      IF(TREAL) THEN
        CALL LINKEDLIST$GET(LL_CNTL,'REAL',1,REALOUT)
        CALL FILEHANDLER$SETFILE('REALOUT',.FALSE.,TRIM(REALOUT))
      ENDIF
      IF(TIMAG) THEN
        CALL LINKEDLIST$GET(LL_CNTL,'IMAG',1,IMAGOUT)
        CALL FILEHANDLER$SETFILE('IMAGOUT',.FALSE.,TRIM(IMAGOUT))
      ENDIF
!     CHECK !CUBCNTL:!CUBE BLOCK
      CALL LINKEDLIST$SELECT(LL_CNTL,'~')
      CALL LINKEDLIST$SELECT(LL_CNTL,'CUBCNTL')
      CALL LINKEDLIST$NLISTS(LL_CNTL,'CUBE',NCUBES)
      IF(NCUBES.EQ.0) THEN
        CALL ERROR$MSG('BLOCK !CUBCNTL:!CUBE NOT FOUND')
        CALL ERROR$STOP('READCNTL')
      END IF
      ALLOCATE(CUBES(NCUBES))
      DO I=1,NCUBES
        CALL LINKEDLIST$SELECT(LL_CNTL,'CUBE',I)
        CALL LINKEDLIST$EXISTD(LL_CNTL,'REAL',1,CUBES(I)%TREAL)
        CALL LINKEDLIST$EXISTD(LL_CNTL,'IMAG',1,CUBES(I)%TIMAG)
        IF(.NOT.CUBES(I)%TREAL.AND..NOT.CUBES(I)%TIMAG) THEN
          CALL ERROR$MSG('BLOCK !CUBCNTL:!CUBE:REAL OR IMAG NOT FOUND')
          CALL ERROR$I4VAL('CUBE NUMBER',I)
          CALL ERROR$STOP('READCNTL')
        END IF
        IF(CUBES(I)%TREAL) CALL LINKEDLIST$GET(LL_CNTL,'REAL',1,CUBES(I)%REAL%FILE)
        IF(CUBES(I)%TIMAG) CALL LINKEDLIST$GET(LL_CNTL,'IMAG',1,CUBES(I)%IMAG%FILE)
        CALL LINKEDLIST$EXISTD(LL_CNTL,'FAC',1,TCHK)
        IF(TCHK) THEN
          CALL LINKEDLIST$GET(LL_CNTL,'FAC',1,SVAR)
          CUBES(I)%FAC=CMPLX(SVAR(1),SVAR(2),KIND=8)
        ELSE
          CUBES(I)%FAC=CMPLX(1.D0,0.D0,KIND=8)
        END IF
        CALL LINKEDLIST$EXISTD(LL_CNTL,'POW',1,TCHK)
        IF(TCHK) THEN
          CALL LINKEDLIST$GET(LL_CNTL,'POW',1,CUBES(I)%POW)
        ELSE
          CUBES(I)%POW=1.D0
        END IF
        CALL LINKEDLIST$EXISTD(LL_CNTL,'KPT[1/AA]',1,TCHK)
        CALL LINKEDLIST$EXISTD(LL_CNTL,'KPT[1/BOHR]',1,TCHK1)
        IF(TCHK.AND.TCHK1) THEN
          CALL ERROR$MSG('K-POINT IN RECIPROCAL GIVEN IN TWO UNITS')
          CALL ERROR$I4VAL('CUBE NUMBER',I)
          CALL ERROR$STOP('READCNTL')
        END IF
        IF(TCHK) THEN
          CALL LINKEDLIST$GET(LL_CNTL,'KPT[1/AA]',1,CUBES(I)%KPT)
        ELSE IF(TCHK1) THEN
          CALL LINKEDLIST$GET(LL_CNTL,'KPT[1/BOHR]',1,CUBES(I)%KPT)
          CUBES(I)%KPT=CUBES(I)%KPT*ANGSTROM
        ELSE
          CUBES(I)%KPT=(/0.D0,0.D0,0.D0/)
        END IF
PRINT *, 'CUBES(I)%KPT=', CUBES(I)%KPT
        CALL LINKEDLIST$SELECT(LL_CNTL,'..')
      ENDDO
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE READCNTL
!
!     ..1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE READCUBES
!     **************************************************************************
      USE CUBE_MODULE, ONLY: CUBES,NCUBES
      IMPLICIT NONE
      INTEGER(4) :: I
      INTEGER(4) :: NFIL
      LOGICAL(4) :: TREAL
      LOGICAL(4) :: TIMAG
!     **************************************************************************
                          CALL TRACE$PUSH('READCUBES')
      DO I=1,NCUBES
        TREAL=CUBES(I)%TREAL
        TIMAG=CUBES(I)%TIMAG
        IF(TREAL) THEN
          CALL FILEHANDLER$SETFILE('REALIN',.FALSE.,TRIM(CUBES(I)%REAL%FILE))
                          CALL TRACE$PASS(TRIM(CUBES(I)%REAL%FILE))
          CALL FILEHANDLER$UNIT('REALIN',NFIL)
          CALL READCUB(NFIL,I,'REAL')
                          CALL TRACE$PASS('REAL READ SUCCESSFUL')
          CALL FILEHANDLER$CLOSE('REALIN')
        ENDIF
        IF(TIMAG) THEN
          CALL FILEHANDLER$SETFILE('IMAGIN',.FALSE.,TRIM(CUBES(I)%IMAG%FILE))
                          CALL TRACE$PASS(TRIM(CUBES(I)%IMAG%FILE))
          CALL FILEHANDLER$UNIT('IMAGIN',NFIL)
                          CALL TRACE$PASS('IMAG READ SUCCESSFUL')
          CALL READCUB(NFIL,I,'IMAG')
          CALL FILEHANDLER$CLOSE('IMAGIN')
        ENDIF

      ENDDO
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE READCUBES
!
!     ..1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE READCUB(NFIL,ICUBE,FLAG)
!     **************************************************************************
      USE CUBE_MODULE, ONLY: CUBES,CUB_TYPE,NCUBES,PTR
      IMPLICIT NONE
      INTEGER(4), PARAMETER :: NCOL=6
      INTEGER(4), INTENT(IN) :: NFIL
      INTEGER(4), INTENT(IN) :: ICUBE
      CHARACTER(4), INTENT(IN) :: FLAG
      TYPE(CUB_TYPE), POINTER :: CUB
      INTEGER(4) :: I,J,K,N
      INTEGER(4) :: IO
      INTEGER(4) :: NATOMS
      INTEGER(4) :: NUMVAL
      REAL(8) :: LINEVAL(NCOL)
      CHARACTER(1024) :: LINE
      REAL(8), ALLOCATABLE :: AUX(:)
!     **************************************************************************
                          CALL TRACE$PUSH('READCUB')
      IF(FLAG.NE.'REAL'.AND.FLAG.NE.'IMAG') THEN
        CALL ERROR$MSG('FLAG MUST BE REAL OR IMAG')
        CALL ERROR$STOP('READCUB')
      END IF
      IF(.NOT.ALLOCATED(CUBES)) THEN
        CALL ERROR$MSG('CUBES NOT ALLOCATED')
        CALL ERROR$STOP('READCUB')
      END IF
      IF(ICUBE.LT.1.OR.ICUBE.GT.NCUBES) THEN
        CALL ERROR$MSG('ICUBE OUT OF RANGE')
        CALL ERROR$I4VAL('ICUBE',ICUBE)
        CALL ERROR$I4VAL('NCUBES',NCUBES)
        CALL ERROR$STOP('READCUB')
      END IF
      IF(FLAG.EQ.'REAL') PTR=>CUBES(ICUBE)%REAL
      IF(FLAG.EQ.'IMAG') PTR=>CUBES(ICUBE)%IMAG
!     READ FIRST TWO COMMENT LINES
      READ(NFIL,FMT='(A)',IOSTAT=IO) PTR%LINE1
      IF(IO.NE.0) THEN
        CALL ERROR$MSG('ERROR READING COMMENT LINE 1')
        CALL ERROR$STOP('READCUB')
      END IF
      READ(NFIL,FMT='(A)',IOSTAT=IO) PTR%LINE2
      IF(IO.NE.0) THEN
        CALL ERROR$MSG('ERROR READING COMMENT LINE 2')
        CALL ERROR$STOP('READCUB')
      END IF
!     READ NUMBER OF ATOMS AND ORIGIN
      READ(NFIL,*) PTR%NATOM,PTR%O(:)
      write(*,*) 'CUB%NATOM=', PTR%NATOM
      write(*,*) 'CUB%O=', PTR%O
!     READ GRID SIZE AND VOXEL VECTORS
      DO I=1,3
        READ(NFIL,*) PTR%GRID(I),PTR%VXL(I,:)
      ENDDO
      write(*,*) 'CUB%GRID=', PTR%GRID
      write(*,*) 'CUB%VXL=', PTR%VXL
!     ALLOCATE AND READ ATOM INFORMATION
      ALLOCATE(PTR%ATOM(PTR%NATOM,5))
      DO I=1,PTR%NATOM
        READ(NFIL,*) PTR%ATOM(I,:)
      ENDDO

!     ALLOCATE DATA ARRAY
      ALLOCATE(PTR%DATA(PTR%GRID(1),PTR%GRID(2),PTR%GRID(3)))
      ALLOCATE(AUX(PTR%GRID(1)*PTR%GRID(2)*PTR%GRID(3)))
      NUMVAL=0
      DO WHILE(.TRUE.)
        READ(NFIL,'(A)',IOSTAT=IO) LINE ! READ LINE AS STRING
        IF(IO.NE.0) EXIT ! EXIT LOOP IF END OF FILE
!       READ UP TO NCOL VALUES FROM THE LINE
        READ(LINE,*,IOSTAT=IO) LINEVAL
        IF(IO.NE.0) THEN
!         HANDLE PARTIAL LINE
          DO I=1,LEN_TRIM(LINE)
            NUMVAL=NUMVAL+1
            IF(NUMVAL.GT.SIZE(AUX)) EXIT
            AUX(NUMVAL)=LINEVAL(I)
          ENDDO
          ! READ(LINE,*,IOSTAT=IO) (AUX(NUMVAL+I),I=1,NCOL)
          ! IF(IO.EQ.0) THEN
          !   NUMVAL=NUMVAL+NCOL
          ! ENDIF
        ELSE
!         READ ALL NCOL VALUES
          DO I=1,NCOL
            NUMVAL=NUMVAL+1
            AUX(NUMVAL)=LINEVAL(I)
          ENDDO
        ENDIF
      ENDDO
!     READ VOLUMETRIC DATA
      N=0
      DO I=1,PTR%GRID(1)
        DO J=1,PTR%GRID(2)
          DO K=1,PTR%GRID(3)
            N=N+1
            PTR%DATA(I,J,K)=AUX(N)
          ENDDO
        ENDDO
      ENDDO
      DEALLOCATE(AUX)
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE READCUB

      SUBROUTINE CONSTRUCTCOMPLEXCUBE
!     **************************************************************************
      USE CUBE_MODULE, ONLY: CUBES,NCUBES,CUBE_TYPE,CPTR
      IMPLICIT NONE
      REAL(8), PARAMETER :: TOL=1.D-9
      ! TYPE(CUBE_TYPE), POINTER :: CPTR
      INTEGER(4) :: ICUBE
      INTEGER(4) :: IAT
      INTEGER(4) :: I
      TYPE(CUBE_TYPE) :: CUBE
      LOGICAL(4) :: TCHK
!     **************************************************************************
                          CALL TRACE$PUSH('CONSTRUCTCOMPLEXCUBE')
      DO ICUBE=1,NCUBES
                          CALL TRACE$I4VAL(' ICUBE',ICUBE)
        CPTR=>CUBES(ICUBE)
!       REAL PART EXISTS, IMAGINARY PART NOT
        IF(CPTR%TREAL.AND..NOT.CPTR%TIMAG) THEN
                          CALL TRACE$PASS('REAL PART EXISTS, IMAGINARY PART NOT')
          CPTR%IMAG%NATOM=CPTR%REAL%NATOM
          CPTR%IMAG%O=CPTR%REAL%O
          CPTR%IMAG%GRID=CPTR%REAL%GRID
          CPTR%IMAG%VXL=CPTR%REAL%VXL
          ALLOCATE(CPTR%IMAG%ATOM(CPTR%REAL%NATOM,5))
          CPTR%IMAG%ATOM=CPTR%REAL%ATOM
          ALLOCATE(CPTR%IMAG%DATA(CPTR%REAL%GRID(1),CPTR%REAL%GRID(2),CPTR%REAL%GRID(3)))
          CPTR%IMAG%DATA=0.D0
          CPTR%IMAG%FILE=' '
        ENDIF
!       IMAGINARY PART EXISTS, REAL PART NOT
        IF(CPTR%TIMAG.AND..NOT.CPTR%TREAL) THEN
                          CALL TRACE$PASS('IMAGINARY PART EXISTS, REAL PART NOT')
          CPTR%REAL%NATOM=CPTR%IMAG%NATOM
          CPTR%REAL%O=CPTR%IMAG%O
          CPTR%REAL%GRID=CPTR%IMAG%GRID
          CPTR%REAL%VXL=CPTR%IMAG%VXL
          ALLOCATE(CPTR%REAL%ATOM(CPTR%IMAG%NATOM,5))
          CPTR%REAL%ATOM=CPTR%IMAG%ATOM
          ALLOCATE(CPTR%REAL%DATA(CPTR%IMAG%GRID(1),CPTR%IMAG%GRID(2),CPTR%IMAG%GRID(3)))
          CPTR%REAL%DATA=0.D0
          CPTR%REAL%FILE=' '
        ENDIF
!       REAL AND IMAGINARY PART EXIST, CHECK CONSISTENCY
        IF(CPTR%TREAL.AND.CPTR%TIMAG) THEN
          IF(CPTR%REAL%NATOM.NE.CPTR%IMAG%NATOM) THEN
            CALL ERROR$MSG('NUMBER OF ATOMS DIFFERENT')
            CALL ERROR$I4VAL('CUBE NUMBER',ICUBE)
            CALL ERROR$I4VAL(' REAL',CPTR%REAL%NATOM)
            CALL ERROR$I4VAL(' IMAG',CPTR%IMAG%NATOM)
            CALL ERROR$STOP('CONSTRUCTCOMPLEXCUBE')
          ENDIF
          IF (ANY(CPTR%REAL%GRID.NE.CPTR%IMAG%GRID)) THEN
            CALL ERROR$MSG('GRID SIZE DIFFERENT')
            CALL ERROR$I4VAL('CUBE NUMBER', ICUBE)
            WRITE(*,*) 'REAL=', CPTR%REAL%GRID
            WRITE(*,*) 'IMAG=', CPTR%IMAG%GRID
            CALL ERROR$STOP('CONSTRUCTCOMPLEXCUBE')
          ENDIF
          IF (ANY(ABS(CPTR%REAL%VXL-CPTR%IMAG%VXL).GT.TOL)) THEN
            CALL ERROR$MSG('VOXEL VECTORS DIFFERENT')
            CALL ERROR$I4VAL('CUBE NUMBER', ICUBE)
            WRITE(*,*) 'REAL=', CPTR%REAL%VXL
            WRITE(*,*) 'IMAG=', CPTR%IMAG%VXL
            CALL ERROR$STOP('CONSTRUCTCOMPLEXCUBE')
          ENDIF
          IF(ANY(ABS(CPTR%REAL%O-CPTR%IMAG%O).GT.TOL)) THEN
            CALL ERROR$MSG('ORIGIN DIFFERENT')
            CALL ERROR$I4VAL('CUBE NUMBER',ICUBE)
            WRITE(*,*) 'REAL=',CPTR%REAL%O
            WRITE(*,*) 'IMAG=',CPTR%IMAG%O
            CALL ERROR$STOP('CONSTRUCTCOMPLEXCUBE')
          ENDIF
          DO IAT=1,CPTR%REAL%NATOM
            DO I=1,5
              IF(CPTR%REAL%ATOM(IAT,I).NE.CPTR%IMAG%ATOM(IAT,I)) THEN
                CALL ERROR$MSG('ATOM INFORMATION DIFFERENT')
                CALL ERROR$I4VAL('CUBE NUMBER',ICUBE)
                CALL ERROR$I4VAL(' ATOM NUMBER',IAT)
                CALL ERROR$R8VAL(' REAL',CPTR%REAL%ATOM(IAT,I))
                CALL ERROR$R8VAL(' IMAG',CPTR%IMAG%ATOM(IAT,I))
                CALL ERROR$STOP('CONSTRUCTCOMPLEXCUBE')
              ENDIF
            ENDDO
          ENDDO
        ENDIF
!       BOTH EXIST NOW, CONSTRUCT COMPLEX DATA
        CPTR%TREAL=.TRUE.
        CPTR%TIMAG=.TRUE.
        ALLOCATE(CPTR%CVOL(CPTR%REAL%GRID(1),CPTR%REAL%GRID(2),CPTR%REAL%GRID(3)))
        CPTR%CVOL=CMPLX(CPTR%REAL%DATA,CPTR%IMAG%DATA,KIND=8)
        DEALLOCATE(CPTR%REAL%DATA)
        DEALLOCATE(CPTR%IMAG%DATA)
      ENDDO
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE CONSTRUCTCOMPLEXCUBE

      SUBROUTINE CHECKCONSISTENCY
!     **************************************************************************
      USE CUBE_MODULE, ONLY: CUBES,NCUBES,CUB_TYPE
      IMPLICIT NONE
      REAL(8), PARAMETER :: TOL=1.D-9
      INTEGER(4) :: ICUBE
      TYPE(CUB_TYPE), POINTER :: CUB
      TYPE(CUB_TYPE), POINTER :: REFCUB
!     **************************************************************************
      IF(NCUBES.EQ.1) RETURN
                          CALL TRACE$PUSH('CHECKCONSISTENCY')
!     CONSISTENCY BETWEEN REAL AND IMAGINARY PART IS CHECKED IN CONSTRUCTCOMPLEXCUBE
!     ONLY CHECK BETWEEN COMPLEX CUBES
      IF(.NOT.ALLOCATED(CUBES(1)%CVOL)) THEN
        CALL ERROR$MSG('COMPLEX CUBE NOT CONSTRUCTED')
        CALL ERROR$MSG('CONSTRUCTCOMPLEXCUBE MUST BE CALLED FIRST')
        CALL ERROR$STOP('CHECKCONSISTENCY')
      END IF
      REFCUB=>CUBES(1)%REAL
      DO ICUBE=2,NCUBES
        CUB=>CUBES(ICUBE)%REAL
        IF(CUB%NATOM.NE.REFCUB%NATOM) THEN
          CALL ERROR$MSG('NUMBER OF ATOMS DIFFERENT')
          CALL ERROR$I4VAL(' CUBE NUMBER',ICUBE)
          CALL ERROR$I4VAL(' REAL',CUB%NATOM)
          CALL ERROR$I4VAL(' REFERENCE',REFCUB%NATOM)
          CALL ERROR$STOP('CHECKCONSISTENCY')
        ENDIF
        IF(ANY(CUB%GRID.NE.REFCUB%GRID)) THEN
          CALL ERROR$MSG('GRID SIZE DIFFERENT')
          CALL ERROR$I4VAL(' CUBE NUMBER',ICUBE)
          WRITE(*,*) 'REAL=',CUB%GRID
          WRITE(*,*) 'REFERENCE=',REFCUB%GRID
          CALL ERROR$STOP('CHECKCONSISTENCY')
        ENDIF
        IF(SUM(ABS(CUB%VXL-REFCUB%VXL)).GT.TOL) THEN
          CALL ERROR$MSG('VOXEL VECTORS DIFFERENT')
          CALL ERROR$I4VAL(' CUBE NUMBER',ICUBE)
          WRITE(*,*) 'REAL=',CUB%VXL
          WRITE(*,*) 'REFERENCE=',REFCUB%VXL
          CALL ERROR$STOP('CHECKCONSISTENCY')
        ENDIF
        IF(SUM(ABS(CUB%O-REFCUB%O)).GT.TOL) THEN
          CALL ERROR$MSG('ORIGIN DIFFERENT')
          CALL ERROR$I4VAL(' CUBE NUMBER',ICUBE)
          WRITE(*,*) 'REAL=',CUB%O
          WRITE(*,*) 'REFERENCE=',REFCUB%O
          CALL ERROR$STOP('CHECKCONSISTENCY')
        ENDIF
      ENDDO
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE CHECKCONSISTENCY
!
!     ..1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SUMCUBES
!     **************************************************************************
      USE CUBE_MODULE, ONLY: CUBES,NCUBES,CUBE_TYPE,CUBSUM
      IMPLICIT NONE
      INTEGER(4) :: ICUBE
      INTEGER(4) :: I,J,K
      TYPE(CUBE_TYPE), POINTER :: CUBE
!     **************************************************************************
                          CALL TRACE$PUSH('SUMCUBES')
      IF(.NOT.ALLOCATED(CUBES(1)%CVOL)) THEN
        CALL ERROR$MSG('COMPLEX CUBE NOT CONSTRUCTED')
        CALL ERROR$MSG('CONSTRUCTCOMPLEXCUBE MUST BE CALLED FIRST')
        CALL ERROR$STOP('SUMCUBES')
      END IF
      ALLOCATE(CUBSUM(CUBES(1)%REAL%GRID(1),CUBES(1)%REAL%GRID(2),CUBES(1)%REAL%GRID(3)))
      CUBSUM=(0.D0,0.D0)
      DO ICUBE=1,NCUBES
        CUBE=>CUBES(ICUBE)
        CUBSUM=CUBSUM+CUBE%FAC*CUBE%CVOL**CUBE%POW
      ENDDO
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE SUMCUBES
!
!     ..1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE WRITECOMPLEXCUBE
!     **************************************************************************
      USE CUBE_MODULE, ONLY: CUBSUM,CUBES,CUB_TYPE,TREAL,TIMAG,REALOUT,IMAGOUT
      USE CLOCK_MODULE
      IMPLICIT NONE
      TYPE(CUB_TYPE), POINTER :: CUB
      INTEGER(4) :: NFIL
      INTEGER(4) :: I,J,K
      CHARACTER(256) :: LINE1
      CHARACTER(256) :: LINE2
      CHARACTER(32) :: NOW
!     **************************************************************************
                          CALL TRACE$PUSH('WRITECOMPLEXCUBE')
      IF(.NOT.ALLOCATED(CUBSUM)) THEN
        CALL ERROR$MSG('COMPLEX CUBE NOT SUMMED UP')
        CALL ERROR$STOP('WRITECOMPLEXCUBE')
      END IF
      CUB=>CUBES(1)%REAL
      CALL CLOCK$NOW(NOW)
      LINE1="CUBE FILE CREATED BY PAW_CUBE ON "//TRIM(NOW)
      IF(TREAL) THEN
        LINE2="REAL PART OF COMPLEX CUBE"
        CALL FILEHANDLER$SETFILE('REALOUT',.FALSE.,TRIM(REALOUT))
        CALL FILEHANDLER$UNIT('REALOUT',NFIL)
        CALL WRITECUB(NFIL,CUB%NATOM,CUB%O,CUB%GRID,CUB%VXL,CUB%ATOM,REAL(CUBSUM,KIND=8),LINE1,LINE2)
        CALL FILEHANDLER$CLOSE('REALOUT')
      ENDIF
      IF(TIMAG) THEN
        LINE2="IMAGINARY PART OF COMPLEX CUBE"
        CALL FILEHANDLER$SETFILE('IMAGOUT',.FALSE.,TRIM(IMAGOUT))
        CALL FILEHANDLER$UNIT('IMAGOUT',NFIL)
        CALL WRITECUB(NFIL,CUB%NATOM,CUB%O,CUB%GRID,CUB%VXL,CUB%ATOM,AIMAG(CUBSUM),LINE1,LINE2)
        CALL FILEHANDLER$CLOSE('IMAGOUT')
      ENDIF
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE WRITECOMPLEXCUBE
!
!     ..1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE WRITECUB(NFIL,NATOMS,O,GRID,VXL,ATOM,DATA,LINE1,LINE2)
!     **************************************************************************
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: NFIL
      INTEGER(4), INTENT(IN) :: NATOMS
      REAL(8), INTENT(IN) :: O(3)
      INTEGER(4), INTENT(IN) :: GRID(3)
      REAL(8), INTENT(IN) :: VXL(3,3)
      REAL(8), INTENT(IN) :: ATOM(NATOMS,5)
      REAL(8), INTENT(IN) :: DATA(GRID(1),GRID(2),GRID(3))
      CHARACTER(256), INTENT(IN) :: LINE1
      CHARACTER(256), INTENT(IN) :: LINE2
      INTEGER(4) :: I,J,K
!     **************************************************************************
                          CALL TRACE$PUSH('WRITECUB')
!     WRITE FIRST TWO COMMENT LINES
      WRITE(NFIL,FMT='(A)') TRIM(LINE1)
      WRITE(NFIL,FMT='(A)') TRIM(LINE2)
!     WRITE NUMBER OF ATOMS AND ORIGIN
      WRITE(NFIL,FMT='(I5,3F12.6)')NATOMS,O
!     WRITE GRID SIZE AND VOXEL VECTORS
      DO I=1,3
        WRITE(NFIL,FMT='(I5,3F12.6)')GRID(I),VXL(I,:)
      ENDDO
!     WRITE ATOM INFORMATION
      DO I=1,NATOMS
        WRITE(NFIL,FMT='(I5,4F12.6)')NINT(ATOM(I,1)),ATOM(I,2:5)
      ENDDO
!     WRITE VOLUMETRIC DATA
      WRITE(NFIL,FMT='(6(E12.6," "))')(((DATA(I,J,K),K=1,GRID(3)),J=1,GRID(2)),I=1,GRID(1))
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE WRITECUB
!
!     ..1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE KPOINT
!     **************************************************************************
      USE CUBE_MODULE, ONLY: CUBES,NCUBES,CUBE_TYPE
      IMPLICIT NONE
      COMPLEX(8), PARAMETER :: CI=(0.D0,1.D0)
      REAL(8), PARAMETER :: PI=4.D0*ATAN(1.D0)
      REAL(8) :: R(3)
      TYPE(CUBE_TYPE), POINTER :: REF
      TYPE(CUBE_TYPE), POINTER :: CUBE
      INTEGER(4) :: ICUBE
      INTEGER(4) :: I,J,K
      REAL(8) :: VXL1(3),VXL2(3),VXL3(3),O(3)
!     **************************************************************************
                          CALL TRACE$PUSH('KPOINT')
      REF=>CUBES(1)
      VXL1=REF%REAL%VXL(1,:)
      VXL2=REF%REAL%VXL(2,:)
      VXL3=REF%REAL%VXL(3,:)
      O=REF%REAL%O(:)
      DO K=1,REF%REAL%GRID(3)
        DO J=1,REF%REAL%GRID(2)
          DO I=1,REF%REAL%GRID(1)
            R=O+(I-1)*VXL1+(J-1)*VXL2+(K-1)*VXL3
            
            DO ICUBE=1,NCUBES
              CUBE=>CUBES(ICUBE)
! WARNING: CHECK THIS, IS IT NECESSARY TO USE AT ALL, FACTOR 2*PI?, EXP(-)?
              CUBE%CVOL(I,J,K)=CUBE%CVOL(I,J,K)*EXP(CI*DOT_PRODUCT(CUBE%KPT,R))
            ENDDO
          ENDDO
        ENDDO
      ENDDO
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE KPOINT