!........1.........2.........3.........4.........5.........6.........7.........8
      MODULE RIXS_MODULE
      TYPE SETUP_TYPE
        INTEGER(4) :: GID ! GRID ID FOR RADIAL MESH
        REAL(8) :: ECORE ! CORE ENERGY
        REAL(8), ALLOCATABLE :: PSPHI(:,:) ! PSEUDO PARTIAL WAVE
        REAL(8), ALLOCATABLE :: AEPHI(:,:) ! AE PARTIAL WAVE
        INTEGER(4) :: NBATOM ! #(ATOMIC WAVE FUNCTIONS)
        INTEGER(4), ALLOCATABLE :: LATOM(:) ! (NBATOM) L QUANTUM NUMBER
        REAL(8), ALLOCATABLE :: AEPSI(:,:) ! (NR,NBATOM) AE ATOMIC WAVE FUNCTION
      END TYPE SETUP_TYPE

      TYPE STATE_TYPE
!       IF OCCUPATION > OCCPERCENT*MAXOCC THEN OCCUPIED 
!       DEACTIVATED IF EFERMI GIVEN, MAXOCC=2.0/1.0 FOR NSPIN=1/2
        REAL(8) :: OCCPERCENT=0.5D0 
        INTEGER(4)          :: NB ! #(STATES)
        REAL(8), POINTER    :: EIG(:) ! (NB) EIGENVALUES
        REAL(8), POINTER    :: OCC(:) ! (NB) OCCUPATIONS
        INTEGER(4)          :: NOCC ! #(OCCUPIED STATES)
        COMPLEX(8), POINTER :: PROJ(:,:,:) ! (NDIM,NB,NPRO) PROJECTIONS
      END TYPE STATE_TYPE

      TYPE OVERLAP_TYPE
        COMPLEX(8), ALLOCATABLE :: PW(:,:) ! (NB2,NB1) PLANE WAVE OVERLAP
        COMPLEX(8), ALLOCATABLE :: AUG(:,:) ! (NB2,NB1) AUGMENTATION OVERLAP
        COMPLEX(8), ALLOCATABLE :: OV(:,:) ! (NB2,NB1) OVERLAP
!       IT IS CHECKED THAT NOCC1=NOCC2
!       OVERLAP MATRIX
!       | AMAT | BMAT |
!       |------+------|
!       | CMAT | DMAT |
        COMPLEX(8), ALLOCATABLE :: AMAT(:,:) ! (NOCC2,NOCC1) OCCUPIED OVERLAP
        COMPLEX(8), ALLOCATABLE :: BMAT(:,:) ! (NOCC2,NB1-NOCC1)
        COMPLEX(8), ALLOCATABLE :: CMAT(:,:) ! (NB2-NOCC2,NOCC1)
        COMPLEX(8), ALLOCATABLE :: DMAT(:,:) ! (NB2-NOCC2,NB1-NOCC1)
!       AINV = (AMAT)^-1
        COMPLEX(8), ALLOCATABLE :: AINV(:,:) ! (NOCC1,NOCC2) INVERSE AMAT
!       KMAT = CMAT * (AMAT)^-1
        COMPLEX(8), ALLOCATABLE :: KMAT(:,:) ! (NB2-NOCC2,NOCC1) K MATRIX ELEMENTS
!       HMAT = (BMAT)^T * ((AMAT)^T)^-1
! WARNING: INDEXING SHOULD BE CHECKED
        COMPLEX(8), ALLOCATABLE :: HMAT(:,:) ! (NB1-NOCC1,NOCC2) H MATRIX ELEMENTS
        COMPLEX(8), ALLOCATABLE :: DIPOLE(:,:) ! (3,NB2) DIPOLE MATRIX ELEMENTS
        COMPLEX(8) :: ADET ! DETERMINANT OF OCCUPIED OVERLAP
        COMPLEX(8), ALLOCATABLE :: ABSORP(:,:) ! (3,NB2-NOCC) ABSORP. AMPLITUDE
        COMPLEX(8), ALLOCATABLE :: LORENTZ(:,:) ! (NSPEC,NB2-NOCC) LORENTZIAN DENOMINATOR
        END TYPE OVERLAP_TYPE

      TYPE SETTINGS_TYPE
        INTEGER(4) :: NSPEC ! #(SPECTRA)
        CHARACTER(256) :: ATOM ! ATOM ID WITH CORE HOLE
        INTEGER(4) :: IATOM ! ATOM INDEX WITH CORE HOLE IN SIM1 (FOR SIM2 USE ATOMMAP)
        INTEGER(4) :: NCORE ! N QUANTUM NUMBER OF CORE HOLE
        INTEGER(4) :: LCORE ! L QUANTUM NUMBER OF CORE HOLE
!       ENERGY GRID PARAMETER
        REAL(8) :: EMIN ! MINIMUM ENERGY
        REAL(8) :: EMAX ! MAXIMUM ENERGY
        REAL(8) :: DE ! ENERGY STEP SIZE
        INTEGER(4) :: NE ! #(ENERGY POINTS)
!       FOLLOWING SETTINGS ARE USED AS DEFAULTS FOR SPECTRA
!       WILL BE OVERWRITTEN BY SPECTRA SETTINGS
        REAL(8) :: GAMMA ! LIFETIME BROADENING FROM LORENTZIAN (DEFAULT 0.3 EV)
        REAL(8) :: EBROAD ! GAUSSIAN BROADENING OF ENERGY GRID (DEFAULT 0.3 EV)
        LOGICAL(4) :: TOMEGA ! CHECK IF OMEGA IS GIVEN
        REAL(8) :: OMEGA ! ENERGY OF INCOMING PHOTON IN HARTREE
      END TYPE SETTINGS_TYPE

      TYPE OUTPUT_TYPE
        LOGICAL(4) :: TOVL ! WRITE OVERLAP_TYPE%OV
        LOGICAL(4) :: TOVLPW ! WRITE OVERLAP_TYPE%PW
        LOGICAL(4) :: TOVLAUG ! WRITE OVERLAP_TYPE%AUG
        LOGICAL(4) :: TAMAT ! WRITE OVERLAP_TYPE%AMAT
        LOGICAL(4) :: TBMAT ! WRITE OVERLAP_TYPE%BMAT
        LOGICAL(4) :: TCMAT ! WRITE OVERLAP_TYPE%CMAT
        LOGICAL(4) :: TDMAT ! WRITE OVERLAP_TYPE%DMAT
        LOGICAL(4) :: TDIPOLE ! WRITE OVERLAP_TYPE%DIPOLE
        LOGICAL(4) :: TKMAT ! WRITE OVERLAP_TYPE%KMAT
        LOGICAL(4) :: TADET ! WRITE OVERLAP_TYPE%ADET
        LOGICAL(4) :: TRAW  ! WRITE SPEC_TYPE%IRAW
        LOGICAL(4) :: TBINARY ! WRITE BINARY FILES
        LOGICAL(4) :: TKPTSPIN ! WRITE K-POINT AND SPIN SPECTRA SEPARATELY
      END TYPE OUTPUT_TYPE

      TYPE SPEC_TYPE
        CHARACTER(256) :: FILE ! FILENAME
        REAL(8) :: OMEGA ! ENERGY INCOMING PHOTON TAKEN FROM SETTINGS OR INPUT
        REAL(8) :: GAMMA ! LIFETIME BROADENING TAKEN FROM SETTINGS OR INPUT
!       INCOMING LIGHT
        REAL(8) :: NORMALI(3) ! NORMAL VECTOR OF COORDINATES
        REAL(8) :: KDIRI(3) ! DIRECTION OF K-VECTOR
        COMPLEX(8) :: POLI(2) ! POLARIZATION VECTOR
        COMPLEX(8) :: POLXYZI(3) ! POLARIZATION VECTOR IN CARTESIAN COORDINATES
        LOGICAL(4) :: TPOLXYZI ! CHECK IF POLXYZ IS IN INPUT
!       OUTGOING LIGHT
        REAL(8) :: NORMALO(3) ! NORMAL VECTOR OF COORDINATES
        REAL(8) :: KDIRO(3) ! DIRECTION OF K-VECTOR
        COMPLEX(8) :: POLO(2) ! POLARIZATION VECTOR
        COMPLEX(8) :: POLXYZO(3) ! POLARIZATION VECTOR IN CARTESIAN COORDINATES
        LOGICAL(4) :: TPOLXYZO ! CHECK IF POLXYZ IS IN INPUT

        REAL(8), ALLOCATABLE :: E(:) ! (NE) ENERGY GRID
        REAL(8), ALLOCATABLE :: RIXS(:,:,:) ! (NE,NKPT,NSPIN) CROSS SECTION
        ! REAL(8), ALLOCATABLE :: ERAW(:,:,:)  ! (NKPT,NSPIN,NB2-NOCC)
        ! REAL(8), ALLOCATABLE :: IRAW(:,:,:)  ! (NKPT,NSPIN,NB2-NOCC)
!       LAST INDEX 1=TOTAL 2=SPIN UP 3=SPIN DOWN
        REAL(8), ALLOCATABLE :: RIXSCONV(:,:,:)  ! (NKPT,NE,3) CONVOLUTED CROSS SECTION
        REAL(8) :: EBROAD ! GAUSSIAN BROADENING TAKEN FROM SETTINGS OR INPUT
        LOGICAL(4) :: TELASTIC ! CALCULATE ELASTIC PEAK
        CHARACTER(1) :: BROADMODE ! BROADENING MODE (N)ONE, (G)AUSSIAN, OR (L)ORENTZIAN
      END TYPE SPEC_TYPE

!     GENERAL SETTINGS OF A SIMULATION 
      TYPE SIMULATION_TYPE
        CHARACTER(11) :: ID ! SIMULATION IDENTIFIER (GROUNDSTATE,EXCITESTATE)
        CHARACTER(256) :: FILE ! FILENAME
        INTEGER(4) :: NAT ! #(ATOMS)
        INTEGER(4) :: NSP ! #(SETUPS)
        INTEGER(4) :: NKPT ! #(KPOINTS)
        INTEGER(4) :: NSPIN ! #(SPINS)
        INTEGER(4) :: NDIM ! #(DIMENSIONS)
        INTEGER(4) :: NPRO ! #(PROJECTIONS)
        INTEGER(4) :: LNXX
        CHARACTER(6) :: FLAG
        INTEGER(4), ALLOCATABLE :: LMNX(:) ! (NSP)
        INTEGER(4), ALLOCATABLE :: LNX(:) ! (NSP)
        INTEGER(4), ALLOCATABLE :: LOX(:,:) ! (LNXX,NSP)
        INTEGER(4), ALLOCATABLE :: MAP(:,:) ! (NAT,LNXX) INDEX-1 OF ATOM AND LN
        LOGICAL(4) :: TINV ! INVERSION SYMMETRY
        INTEGER(4) :: NKDIV(3) ! K-POINT DIVISIONS
        INTEGER(4) :: ISHIFT(3) ! K-POINT SHIFTS
        REAL(8) :: RNTOT
        REAL(8) :: NEL
        LOGICAL(4) :: TFERMI
        REAL(8) :: EFERMI ! FERMI ENERGY FROM CNTL FILE
        REAL(8) :: ETOT  ! TOTAL ENERGY
        REAL(8) :: EDFT  ! TOTAL DFT ENERGY
        REAL(8) :: ECORE  ! TOTAL CORE ENERGY
        INTEGER(4) :: SPACEGROUP
        LOGICAL(4) :: TSHIFT
        REAL(8) :: RBAS(3,3) ! BASIS VECTORS
        REAL(8), ALLOCATABLE :: R(:,:) ! (3,NAT) ATOMIC POSITIONS
        CHARACTER(16), ALLOCATABLE :: ATOMID(:) ! (NAT) ATOM IDENTIFIERS
        INTEGER(4), ALLOCATABLE :: ISPECIES(:) ! (NAT) SPECIES INDEX
        REAL(8), ALLOCATABLE :: XK(:,:) ! (3,NKPT) K-POINTS IN REL. COORD.
        REAL(8), ALLOCATABLE :: WKPT(:) ! (NKPT) K-POINT WEIGHTS
        COMPLEX(8), ALLOCATABLE :: DENMAT(:,:,:,:) ! (LMNXX,LMNXX,NDIM,NAT) DENSITY MATRIX
        TYPE(SETUP_TYPE), ALLOCATABLE :: SETUP(:) ! (NSP) ARRAY OF SETUPS
        TYPE(STATE_TYPE), ALLOCATABLE :: STATEARR(:,:) ! (NKPT,NSPIN) ARRAY OF STATES
        TYPE(STATE_TYPE), POINTER :: STATE ! CURRENT STATE
      END TYPE SIMULATION_TYPE

! WARNING: CHANGING THIS NUMBER MIGHT BREAK SOME CODE
!     INDEX 1 IS GROUNDSTATE AND 2 EXCITED STATE
      INTEGER(4), PARAMETER :: NSIM=2  ! #(SIMULATIONS)
      LOGICAL,SAVE :: SELECTED=.FALSE.
      TYPE(SIMULATION_TYPE), TARGET :: SIM(NSIM) ! (NSIM) ARRAY OF SIMULATIONS
      TYPE(SIMULATION_TYPE), POINTER :: THIS ! CURRENT SIMULATION

      TYPE(OVERLAP_TYPE), ALLOCATABLE, TARGET :: OVLARR(:,:) ! (NKPT,NSPIN)
      TYPE(OVERLAP_TYPE), POINTER :: OVL ! CURRENT OVERLAP

      TYPE(SETTINGS_TYPE) :: SETTINGS

      TYPE(SPEC_TYPE), ALLOCATABLE, TARGET :: SPECARR(:) ! (NSPEC)
      TYPE(SPEC_TYPE), POINTER :: SPEC ! CURRENT SPECTRUM

      REAL(8), ALLOCATABLE :: S(:,:,:) ! (NAT,LNXX1,LNXX2) ATOMIC OVERLAP MATRIX
      INTEGER(4), ALLOCATABLE :: ATOMMAP(:) ! (NAT) ATOM INDEX MAP SIM1->SIM2

      TYPE(OUTPUT_TYPE) :: OUTPUT

      LOGICAL(4) :: TSIM=.FALSE.
      LOGICAL(4) :: TOVERLAP=.FALSE.
      LOGICAL(4) :: TSPECTRUM=.FALSE.
      LOGICAL(4) :: TSETTINGS=.FALSE.
      LOGICAL(4) :: TRSTRT=.FALSE.

      INTEGER(4), ALLOCATABLE :: KSMAP(:,:) ! (NKPT,NSPIN) K AND S RESPONSIBILITY OF TASKS
      INTEGER(4) :: NKPTG  ! #(KPOINTS TOTAL)
      INTEGER(4) :: NSPING ! #(SPINS TOTAL)
      INTEGER(4) :: RTASK  ! TASK RESPONSIBLE FOR READ/WRITE
      END MODULE RIXS_MODULE

      MODULE RIXSCNTL_MODULE  ! MARK: RIXSCNTL_MODULE
        USE LINKEDLIST_MODULE, ONLY: LL_TYPE
        TYPE(LL_TYPE) :: LL_CNTL
        SAVE
      END MODULE RIXSCNTL_MODULE
!
      PROGRAM PAW_RIXS  ! MARK: PAW_RIXS
      ! USE RIXSPDOS_MODULE, ONLY: NPD,PD
      USE RIXSCNTL_MODULE, ONLY: LL_CNTL
      USE RIXS_MODULE, ONLY: TRSTRT
      USE LINKEDLIST_MODULE
      USE CLOCK_MODULE
      IMPLICIT NONE
      INTEGER(4) :: NFIL
      CHARACTER(32) :: DATIME
      INTEGER(4) :: NTASKS
      INTEGER(4) :: THISTASK
!     **************************************************************************
      CALL MPE$INIT
                          CALL TRACE$PUSH('MAIN')
! TODO: COMMAND LINE HANDLING AND HELP MESSAGE
                          CALL TIMING$START
      CALL MPE$QUERY('~',NTASKS,THISTASK)
!     INITIALIZE FILES
      CALL INITIALIZEFILEHANDLER
      CALL FILEHANDLER$UNIT('PROT',NFIL)
      IF(THISTASK.EQ.1) THEN
        WRITE(NFIL,FMT='()')
        CALL CPPAW_WRITEVERSION(NFIL)
        CALL CLOCK$NOW(DATIME)        
        WRITE(NFIL,FMT='(80("="))')
        WRITE(NFIL,FMT='(80("="),T15,"  PROGRAM STARTED ",A32,"  ")')DATIME
        WRITE(NFIL,FMT='(80("="))')
        WRITE(NFIL,FMT='(A,I3)')'NUMBER OF TASKS: ',NTASKS
      END IF
!     ==========================================================================
!     == READ XCNTL FILE                                                      ==
!     ==========================================================================
                          CALL TIMING$CLOCKON('XCNTL')
      CALL FILEHANDLER$UNIT('XCNTL',NFIL)
      CALL RIXSCNTL$READ(NFIL)
!     READ !RSTRT BLOCK
      CALL RIXSCNTL$RESTART
!     READ FILES FOR DFT CALCULATION DATA
      CALL RIXS$SELECT('GROUNDSTATE')
      CALL RIXSCNTL$FILES('GROUNDSTATE')
      CALL RIXS$UNSELECT
      CALL RIXS$SELECT('EXCITESTATE')
      CALL RIXSCNTL$FILES('EXCITESTATE')
      CALL RIXS$UNSELECT
      CALL RIXSCNTL$TFERMICHECK
!     READ GRID SETTINGS
      CALL RIXSCNTL$GRID
!     READ SETTINGS FOR CORE HOLE
      CALL RIXSCNTL$COREHOLE
!     READ SETTINGS FOR SPECTRA
      CALL RIXSCNTL$SPECTRUM
!     CALCULATE POLARISATION IN CARTESIAN COORDINATES FROM NORMAL, K, AND POL
      CALL RIXS$POLARISATION
!     READ OUTPUT SELECTION
      CALL RIXSCNTL$OUTPUT
                          CALL TIMING$CLOCKOFF('XCNTL')

      IF(TRSTRT) THEN
        CALL RIXS$READRESTART
      ELSE
!       READ DFT CALCULATION DATA
        CALL RIXS$READ

        CALL RIXS$DENMAT
!       REPORT DFT CALCULATION DATA
        CALL RIXS$SELECT('GROUNDSTATE')
        CALL RIXS$REPORTSIMULATION
        CALL RIXS$UNSELECT
        CALL RIXS$SELECT('EXCITESTATE')
        CALL RIXS$REPORTSIMULATION
        CALL RIXS$UNSELECT
        CALL DATACONSISTENCY
      END IF

      CALL RIXSCNTL$ATOMCHECK

      CALL RIXS$OVERLAP

      CALL RIXS$DIPOLEMATRIX

      CALL RIXS$ADET
      
      CALL RIXS$KMAT
      
      CALL RIXS$HMAT

      CALL RIXS$LORENTZIAN

      CALL RIXS$ABSORPTION

! WARNING: ASSUME FINAL STATE CAN BE REPRESENTED BY A SINGLE SLATER DETERMINANT
      CALL RIXS$FINALSTATELOOP


      ! CALL RIXS$CROSSSECTION

      CALL RIXS$OUTPUTGATHER

      CALL RIXS$SPINCONV

      CALL RIXS$OUTPUT

      ! CALL RIXS$REPORTSIMULATION

      CALL RIXS$REPORTSETTINGS

      ! CALL RIXS$WRITEDENMAT

      CALL RIXS$WRITERESTART

!     REPORT UNUSED LINKEDLISTS
      CALL FILEHANDLER$UNIT('PROT',NFIL)
      CALL LINKEDLIST$SELECT(LL_CNTL,'~')
      IF(THISTASK.EQ.1) THEN
        CALL LINKEDLIST$REPORT_UNUSED(LL_CNTL,NFIL)
      END IF

                          CALL TIMING$PRINT('~',NFIL)
      CALL MPE$CLOCKREPORT(NFIL)
      CALL USAGE$REPORT(NFIL)

      IF(THISTASK.EQ.1) THEN
        CALL CLOCK$NOW(DATIME)        
        WRITE(NFIL,FMT='(80("="))')
        WRITE(NFIL,FMT='(80("="),T15,"  PROGRAM FINISHED ",A32,"  ")')DATIME
        WRITE(NFIL,FMT='(80("="))')
      END IF
                          CALL TRACE$POP
      CALL ERROR$NORMALSTOP
      STOP
      END PROGRAM PAW_RIXS

      SUBROUTINE RIXS$ISELECT(I)  ! MARK: RIXS$ISELECT
!     **************************************************************************
!     **                                                                      **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: NSIM,SELECTED,THIS,SIM
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: I
!     **************************************************************************
      IF(I.GT.NSIM.OR.I.LT.0) THEN
        CALL ERROR$MSG('I NOT IN RANGE')
        CALL ERROR$I4VAL('I',I)
        CALL ERROR$I4VAL('NSIM',NSIM)
        CALL ERROR$STOP('RIXS$ISELECT')
      END IF
      IF(I.EQ.0) THEN
        IF(.NOT.SELECTED) THEN
          CALL ERROR$MSG('CANNOT UNSELECT A SIMULATION THAT IS NOT SELECTED')
          CALL ERROR$STOP('RIXS$ISELECT')
        END IF
        SELECTED=.FALSE.
        NULLIFY(THIS)
      ELSE
        IF(SELECTED) THEN
          CALL ERROR$MSG('ANOTHER SIMULATION IS ALREADY SELECTED')
          CALL ERROR$STOP('RIXS$ISELECT')
        END IF
        THIS=>SIM(I)
        SELECTED=.TRUE.
      END IF
      RETURN
      END SUBROUTINE RIXS$ISELECT


      SUBROUTINE RIXS$SELECT(ID)  ! MARK: RIXS$SELECT
!     **************************************************************************
!     **                                                                      **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: SELECTED,THIS,SIM
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
!     **************************************************************************
      IF(SELECTED) THEN
        CALL ERROR$MSG('ANOTHER SIMULATION IS ALREADY SELECTED')
        CALL ERROR$CHVAL('SELECTED ID',THIS%ID)
        CALL ERROR$CHVAL('ID',ID)
        CALL ERROR$STOP('RIXS$SELECT')
      END IF
      SELECTED=.TRUE.
      IF(ID.EQ.'GROUNDSTATE') THEN
        THIS=>SIM(1)
      ELSE IF(ID.EQ.'EXCITESTATE') THEN
        THIS=>SIM(2)
      ELSE
        CALL ERROR$MSG('ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID',ID)
        CALL ERROR$MSG('ID MUST BE GROUNDSTATE OR EXCITESTATE')
        CALL ERROR$STOP('RIXS$SELECT')
      END IF
      RETURN
      END SUBROUTINE RIXS$SELECT


      SUBROUTINE RIXS$UNSELECT()
!     **************************************************************************
!     **                                                                      **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: SELECTED,THIS
      IMPLICIT NONE
!     **************************************************************************
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('CANNOT UNSELECT A SIMULATION THAT IS NOT SELECTED')
        CALL ERROR$STOP('RIXS$UNSELECT')
      END IF
      SELECTED=.FALSE.
      NULLIFY(THIS)
      RETURN
      END SUBROUTINE RIXS$UNSELECT
!
!     ..................................................................
      SUBROUTINE DATACONSISTENCY  ! MARK: DATACONSISTENCY
!     **************************************************************************
!     ** CHECKS CONSISTENCY OF PDOS DATA                                      **
! TODO: IMPLEMENT THIS SUBROUTINE FURTHER, TEST THE CHECKS, ADD ADDITIONAL CHECKS
! TODO: COMBINE WITH TEST SUBROUTINE IN RIXS$READ
!     **************************************************************************
      USE RIXS_MODULE, ONLY: THIS,SIMULATION_TYPE,ATOMMAP
      IMPLICIT NONE
      TYPE(SIMULATION_TYPE), POINTER :: THIS1,THIS2
      INTEGER(4) :: IAT1,IAT2
      REAL(8),PARAMETER :: TOL=1.D-8
!     **************************************************************************
                          CALL TRACE$PUSH('DATACONSISTENCY')
      CALL RIXS$SELECT('GROUNDSTATE')
      THIS1=>THIS
      CALL RIXS$UNSELECT
      CALL RIXS$SELECT('EXCITESTATE')
      THIS2=>THIS
      CALL RIXS$UNSELECT
      
      IF(THIS1%NAT.NE.THIS2%NAT)THEN
        CALL ERROR$MSG('NAT INCONSISTENT BETWEEN SIMULATIONS')
        CALL ERROR$I4VAL('GROUNDSTATE%NAT',THIS1%NAT)
        CALL ERROR$I4VAL('EXCITESTATE%NAT',THIS2%NAT)
        CALL ERROR$STOP('DATACONSISTENCY')
      END IF
      IF(THIS1%NKPT.NE.THIS2%NKPT)THEN
        CALL ERROR$MSG('NKPT INCONSISTENT BETWEEN SIMULATIONS')
        CALL ERROR$I4VAL('GROUNDSTATE%NKPT',THIS1%NKPT)
        CALL ERROR$I4VAL('EXCITESTATE%NKPT',THIS2%NKPT)
        CALL ERROR$STOP('DATACONSISTENCY')
      END IF
      IF(THIS1%NSPIN.NE.THIS2%NSPIN)THEN
        CALL ERROR$MSG('NSPIN INCONSISTENT BETWEEN SIMULATIONS')
        CALL ERROR$I4VAL('GROUNDSTATE%NSPIN',THIS1%NSPIN)
        CALL ERROR$I4VAL('EXCITESTATE%NSPIN',THIS2%NSPIN)
        CALL ERROR$STOP('DATACONSISTENCY')
      END IF
      IF(THIS1%NDIM.NE.1.OR.THIS2%NDIM.NE.1)THEN
        CALL ERROR$MSG('ONLY IMPLEMENTED FOR NDIM=1')
        CALL ERROR$I4VAL('GROUNDSTATE%NDIM',THIS1%NDIM)
        CALL ERROR$I4VAL('EXCITESTATE%NDIM',THIS2%NDIM)
        CALL ERROR$STOP('DATACONSISTENCY')
      END IF
! TODO: CHECK IF NECESARRY
      IF(THIS1%TINV.NEQV.THIS2%TINV)THEN
        CALL ERROR$MSG('TINV INCONSISTENT BETWEEN SIMULATIONS')
        CALL ERROR$L4VAL('GROUNDSTATE%TINV',THIS1%TINV)
        CALL ERROR$L4VAL('EXCITESTATE%TINV',THIS2%TINV)
        CALL ERROR$STOP('DATACONSISTENCY')
      END IF
      IF(ANY(ABS(THIS1%NKDIV-THIS2%NKDIV).NE.0))THEN
        CALL ERROR$MSG('NKDIV INCONSISTENT BETWEEN SIMULATIONS')
        CALL ERROR$STOP('DATACONSISTENCY')
      END IF
      IF(ANY(ABS(THIS1%ISHIFT-THIS2%ISHIFT).NE.0))THEN
        CALL ERROR$MSG('ISHIFT INCONSISTENT BETWEEN SIMULATIONS')
        CALL ERROR$STOP('DATACONSISTENCY')
      END IF
      IF(THIS1%TSHIFT.NEQV.THIS2%TSHIFT)THEN
        CALL ERROR$MSG('TSHIFT INCONSISTENT BETWEEN SIMULATIONS')
        CALL ERROR$L4VAL('GROUNDSTATE%TSHIFT',THIS1%TSHIFT)
        CALL ERROR$L4VAL('EXCITESTATE%TSHIFT',THIS2%TSHIFT)
        CALL ERROR$STOP('DATACONSISTENCY')
      END IF
      IF(SUM(ABS(THIS1%RBAS-THIS2%RBAS)).GT.TOL) THEN
        CALL ERROR$MSG('RBAS INCONSISTENT BETWEEN SIMULATIONS')
        CALL ERROR$STOP('DATACONSISTENCY')
      END IF
      DO IAT1=1,THIS1%NAT
        IAT2=ATOMMAP(IAT1)
        IF(SUM(ABS(THIS1%R(:,IAT1)-THIS2%R(:,IAT2))).GT.TOL) THEN
          CALL ERROR$MSG('ATOMIC POSITIONS INCONSISTENT BETWEEN SIMULATIONS')
          CALL ERROR$I4VAL('IAT1',IAT1)
          CALL ERROR$I4VAL('IAT2',IAT2)
          CALL ERROR$CHVAL('ATOMID1',THIS1%ATOMID(IAT1))
          CALL ERROR$R8VAL('R1X',THIS1%R(1,IAT1))
          CALL ERROR$R8VAL('R1Y',THIS1%R(2,IAT1))
          CALL ERROR$R8VAL('R1Z',THIS1%R(3,IAT1))
          CALL ERROR$R8VAL('R2X',THIS2%R(1,IAT2))
          CALL ERROR$R8VAL('R2Y',THIS2%R(2,IAT2))
          CALL ERROR$R8VAL('R2Z',THIS2%R(3,IAT2))
          CALL ERROR$STOP('DATACONSISTENCY')
        END IF
      ENDDO
! TODO: CHECK FOR XK
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE DATACONSISTENCY

!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXSCNTL$READ(NFIL)  ! MARK: RIXSCNTL$READ
!     **************************************************************************
!     **                                                                      **
!     **************************************************************************
      USE RIXSCNTL_MODULE, ONLY: LL_CNTL
      USE LINKEDLIST_MODULE
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: NFIL
!     **************************************************************************
                          CALL TRACE$PUSH('RIXSCNTL$READ')
      CALL LINKEDLIST$NEW(LL_CNTL)
      CALL LINKEDLIST$READ(LL_CNTL,NFIL,'~')
      CALL LINKEDLIST$SELECT(LL_CNTL,'~')
      CALL LINKEDLIST$MARK(LL_CNTL,1)
                          CALL TRACE$POP
      END SUBROUTINE RIXSCNTL$READ
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXSCNTL$FILES(ID)  ! MARK: RIXSCNTL$FILES
!     **************************************************************************
!     **                                                                      **
!     **************************************************************************
      USE RIXSCNTL_MODULE, ONLY: LL_CNTL
      USE RIXS_MODULE, ONLY: SELECTED,TRSTRT,THIS
      USE LINKEDLIST_MODULE
      IMPLICIT NONE
      CHARACTER(11), INTENT(IN) :: ID ! GROUNDSTATE OR EXCITESTATE
      LOGICAL(4) :: TCHK
      CHARACTER(256) :: FILENAME
      REAL(8) :: EV
      REAL(8) :: EFERMI
!     **************************************************************************
                          CALL TRACE$PUSH('RIXSCNTL$FILES')
!     CHECK IF FLAG IS RECOGNIZED
      IF(ID.NE.'GROUNDSTATE'.AND.ID.NE.'EXCITESTATE') THEN
        CALL ERROR$MSG('ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID',ID)
        CALL ERROR$MSG('ID MUST BE GROUNDSTATE OR EXCITESTATE OR RSTRT')
        CALL ERROR$STOP('RIXSCNTL$FILES')
      END IF
!     CHECK IF A SIMULATION IS SELECTED
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SIMULATION SELECTED')
        CALL ERROR$STOP('RIXSCNTL$FILES')
      END IF
      CALL CONSTANTS('EV',EV)
      CALL LINKEDLIST$SELECT(LL_CNTL,'~')
      CALL LINKEDLIST$SELECT(LL_CNTL,'XCNTL')
      CALL LINKEDLIST$EXISTL(LL_CNTL,ID,1,TCHK)
      IF(TRSTRT.AND.TCHK) THEN
        CALL ERROR$MSG('!RSTRT NOT COMPATIBLE WITH !GROUNDSTATE AND !EXCITESTATE')
        CALL ERROR$STOP('RIXSCNTL$FILES')
      END IF
      IF(.NOT.TRSTRT.AND..NOT.TCHK) THEN
        CALL ERROR$MSG('!'//ID//' NOT FOUND')
        CALL ERROR$MSG('EITHER !GROUNDSTATE AND !EXCITESTATE, OR !RSTRT MUST BE DEFINE')
        CALL ERROR$STOP('RIXSCNTL$FILES')
      END IF
      IF(TRSTRT.AND..NOT.TCHK) THEN
                          CALL TRACE$POP
        RETURN
      END IF
      CALL LINKEDLIST$SELECT(LL_CNTL,ID)
      CALL LINKEDLIST$EXISTD(LL_CNTL,'FILE',1,TCHK)
      IF(.NOT.TCHK) THEN
        CALL ERROR$MSG('FILE NOT FOUND IN !'//ID)
        CALL ERROR$STOP('RIXSCNTL$FILES')
      END IF
      CALL LINKEDLIST$GET(LL_CNTL,'FILE',0,FILENAME)
      CALL LINKEDLIST$EXISTD(LL_CNTL,'EFERMI[EV]',1,TCHK)
      IF(TCHK) THEN
        CALL LINKEDLIST$GET(LL_CNTL,'EFERMI[EV]',1,EFERMI)
        THIS%EFERMI=EFERMI*EV
      END IF
      THIS%TFERMI=TCHK
      CALL RIXS$SETCH('FILE',FILENAME)
      CALL RIXS$SETCH('ID',ID)
      CALL FILEHANDLER$SETFILE(ID,.FALSE.,TRIM(FILENAME))
                          CALL TRACE$POP
      END SUBROUTINE RIXSCNTL$FILES
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXSCNTL$TFERMICHECK  ! MARK: RIXSCNTL$TFERMICHECK
!     **************************************************************************
!     ** CHECK IF EITHER BOTH OR NO FERMI LEVEL IS GIVEN                      **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: THIS
      IMPLICIT NONE
      LOGICAL(4) :: TFERMI1
      LOGICAL(4) :: TFERMI2
!     **************************************************************************
                          CALL TRACE$PUSH('RIXSCNTL$TFERMICHECK')
      CALL RIXS$SELECT('GROUNDSTATE')
      TFERMI1=THIS%TFERMI
      CALL RIXS$UNSELECT
      CALL RIXS$SELECT('EXCITESTATE')
      TFERMI2=THIS%TFERMI
      CALL RIXS$UNSELECT
      IF(TFERMI1.AND..NOT.TFERMI2) THEN
        CALL ERROR$MSG('FERMI LEVEL GIVEN FOR GROUNDSTATE BUT NOT FOR EXCITESTATE')
        CALL ERROR$STOP('RIXSCNTL$TFERMICHECK')
      END IF
      IF(.NOT.TFERMI1.AND.TFERMI2) THEN
        CALL ERROR$MSG('FERMI LEVEL GIVEN FOR EXCITESTATE BUT NOT FOR GROUNDSTATE')
        CALL ERROR$STOP('RIXSCNTL$TFERMICHECK')
      END IF
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE RIXSCNTL$TFERMICHECK
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXSCNTL$RESTART  ! MARK: RIXSCNTL$RESTART
!     **************************************************************************
!     **                                                                      **
!     **************************************************************************
      USE RIXSCNTL_MODULE, ONLY: LL_CNTL
      USE RIXS_MODULE, ONLY: TRSTRT,TSIM
      USE LINKEDLIST_MODULE
      IMPLICIT NONE
      LOGICAL(4) :: TCHK
      CHARACTER(256) :: FILENAME
!     **************************************************************************
                          CALL TRACE$PUSH('RIXSCNTL$RESTART')
      CALL LINKEDLIST$SELECT(LL_CNTL,'~')
      CALL LINKEDLIST$SELECT(LL_CNTL,'XCNTL')
      CALL LINKEDLIST$EXISTL(LL_CNTL,'RSTRT',1,TCHK)
      IF(.NOT.TCHK) THEN
        TRSTRT=.FALSE.
        CALL TRACE$POP
        RETURN
      END IF
      IF(TSIM) THEN
        CALL ERROR$MSG('RESTART FILE GIVEN BUT SIMULATION FILES READ BEFORE')
        CALL ERROR$STOP('RIXSCNTL$RESTART')
      END IF
      CALL LINKEDLIST$SELECT(LL_CNTL,'RSTRT')
      CALL LINKEDLIST$EXISTD(LL_CNTL,'FILE',1,TCHK)
      IF(.NOT.TCHK) THEN
        CALL ERROR$MSG('FILE NOT FOUND IN !RSTRT')
        CALL ERROR$STOP('RIXSCNTL$RESTART')
      END IF
      CALL LINKEDLIST$GET(LL_CNTL,'FILE',0,FILENAME)
      CALL FILEHANDLER$SETFILE('RSTRT_IN',.FALSE.,TRIM(FILENAME))
      TRSTRT=.TRUE.
                          CALL TRACE$POP
      END SUBROUTINE RIXSCNTL$RESTART
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXSCNTL$GRID  ! MARK: RIXSCNTL$GRID
!     **************************************************************************
!     ** READ SETTINGS FOR THE ENERGY GRID                                    **
!     **************************************************************************
      USE RIXSCNTL_MODULE, ONLY: LL_CNTL
      USE RIXS_MODULE, ONLY: SETTINGS
      USE LINKEDLIST_MODULE
      IMPLICIT NONE
      LOGICAL(4) :: TCHK
      REAL(8) :: EV
      REAL(8) :: KB
      REAL(8) :: SVAR
!     **************************************************************************
                          CALL TRACE$PUSH('RIXSCNTL$GRID')
      CALL CONSTANTS('EV',EV)
      CALL CONSTANTS('KB',KB)
!     == DEFAULT VALUES ========================================================
      SETTINGS%EBROAD=0.3D0*EV
      SETTINGS%DE=1.D-2*EV
!     == READ GRID BLOCK =======================================================
      CALL LINKEDLIST$SELECT(LL_CNTL,'~')
      CALL LINKEDLIST$SELECT(LL_CNTL,'XCNTL')
      CALL LINKEDLIST$EXISTL(LL_CNTL,'GRID',1,TCHK)
      IF(.NOT.TCHK) THEN
        CALL ERROR$MSG('GRID NOT FOUND IN XCNTL')
        CALL ERROR$STOP('RIXSCNTL$GRID')
      END IF
      CALL LINKEDLIST$SELECT(LL_CNTL,'GRID')
!     == READ ENERGY SPACING (OPTIONAL) ========================================
      CALL LINKEDLIST$EXISTD(LL_CNTL,'DE[EV]',1,TCHK)
      IF(TCHK) THEN
        CALL LINKEDLIST$GET(LL_CNTL,'DE[EV]',1,SVAR)
        SETTINGS%DE=SVAR*EV
      END IF
!     == READ BROADENING OF SPECTRUM (OPTIONAL) ================================
      CALL LINKEDLIST$EXISTD(LL_CNTL,'EBROAD[EV]',1,TCHK)
      IF(TCHK) THEN
        CALL LINKEDLIST$GET(LL_CNTL,'EBROAD[EV]',1,SVAR)
        SETTINGS%EBROAD=SVAR*EV
      END IF
!     == READ ENERGY RANGE (MANDATORY) =========================================
       CALL LINKEDLIST$EXISTD(LL_CNTL,'EMIN',1,TCHK)
       IF(.NOT.TCHK) THEN
         CALL ERROR$MSG('EMIN NOT FOUND IN !GRID')
         CALL ERROR$STOP('RIXSCNTL$GRID')
       END IF
       CALL LINKEDLIST$GET(LL_CNTL,'EMIN',1,SVAR)
       SETTINGS%EMIN=SVAR*EV
       CALL LINKEDLIST$EXISTD(LL_CNTL,'EMAX',1,TCHK)
       IF(.NOT.TCHK) THEN
         CALL ERROR$MSG('EMAX NOT FOUND IN !GRID')
         CALL ERROR$STOP('RIXSCNTL$GRID')
       END IF
       CALL LINKEDLIST$GET(LL_CNTL,'EMAX',1,SVAR)
       SETTINGS%EMAX=SVAR*EV
       SETTINGS%NE=INT((SETTINGS%EMAX-SETTINGS%EMIN)/SETTINGS%DE)+1
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE RIXSCNTL$GRID
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXSCNTL$SPECTRUM  ! MARK: RIXSCNTL$SPECTRUM
!     **************************************************************************
!     **                                                                      **
!     **************************************************************************
      USE RIXSCNTL_MODULE, ONLY: LL_CNTL
      USE RIXS_MODULE, ONLY: SPEC,SPECARR,TSPECTRUM,SETTINGS
      USE LINKEDLIST_MODULE
      USE STRINGS_MODULE
      IMPLICIT NONE
      LOGICAL(4) :: TCHK
      LOGICAL(4) :: TCHK1,TCHK2
      INTEGER(4) :: NSPEC
      INTEGER(4) :: ISPEC
      REAL(8) :: REALPOL(4)
      REAL(8) :: REALPOLXYZ(6)
      REAL(8) :: EV
      CHARACTER(1) :: MODE
!     *************************************************************************
! WARNING: READING OF COMPLEX POLARIZATION IS NOT IMPLEMENTED
! TODO: IMPLEMENT READING OF COMPLEX POLARIZATION
                          CALL TRACE$PUSH('RIXSCNTL$SPECTRUM')
      CALL CONSTANTS('EV',EV)
      CALL LINKEDLIST$SELECT(LL_CNTL,'~')
      CALL LINKEDLIST$SELECT(LL_CNTL,'XCNTL')
!     CHECK IF AT LEAST ONE SPECTRUM IS DEFINED
      CALL LINKEDLIST$EXISTL(LL_CNTL,'SPECTRUM',1,TCHK)
      IF(.NOT.TCHK) THEN
        CALL ERROR$MSG('SPECTRUM NOT FOUND IN XCNTL')
        CALL ERROR$STOP('RIXSCNTL$SPECTRUM')
      END IF
!     ALLOCATE CORRECT NUMBER OF SPECTRA
      CALL LINKEDLIST$NLISTS(LL_CNTL,'SPECTRUM',NSPEC)
      ALLOCATE(SPECARR(NSPEC))
      SETTINGS%NSPEC=NSPEC
!     LOOP OVER SPECTRA AND READ DATA
      DO ISPEC=1,NSPEC
        SPEC=>SPECARR(ISPEC)
        CALL LINKEDLIST$SELECT(LL_CNTL,'~')
        CALL LINKEDLIST$SELECT(LL_CNTL,'XCNTL')
        CALL LINKEDLIST$SELECT(LL_CNTL,'SPECTRUM',ISPEC)
!       OUTPUT FILE NAME
        CALL LINKEDLIST$EXISTD(LL_CNTL,'FILE',1,TCHK)
        IF(.NOT.TCHK) THEN
          CALL ERROR$MSG('FILE NOT FOUND IN !SPECTRUM')
          CALL ERROR$I4VAL('ISPEC',ISPEC)
          CALL ERROR$STOP('RIXSCNTL$SPECTRUM')
        END IF
        CALL LINKEDLIST$GET(LL_CNTL,'FILE',1,SPEC%FILE)
!       GAMMA (OPTIONAL)
        CALL LINKEDLIST$EXISTD(LL_CNTL,'GAMMA[EV]',1,TCHK)
        IF(TCHK) THEN
          CALL LINKEDLIST$GET(LL_CNTL,'GAMMA[EV]',1,SPEC%GAMMA)
          SPEC%GAMMA=SPEC%GAMMA*EV
        ELSE
          SPEC%GAMMA=SETTINGS%GAMMA
        END IF
!       EBROAD (OPTIONAL)
        CALL LINKEDLIST$EXISTD(LL_CNTL,'EBROAD[EV]',1,TCHK)
        IF(TCHK) THEN
          CALL LINKEDLIST$GET(LL_CNTL,'EBROAD[EV]',1,SPEC%EBROAD)
          SPEC%EBROAD=SPEC%EBROAD*EV
        ELSE
          SPEC%EBROAD=SETTINGS%EBROAD
        END IF
!       BROADMODE (OPTIONAL)
        CALL LINKEDLIST$EXISTD(LL_CNTL,'BROADMODE',1,TCHK)
        IF(TCHK) THEN
          CALL LINKEDLIST$GET(LL_CNTL,'BROADMODE',1,MODE)
          MODE=+MODE
          IF(MODE.EQ.'G') THEN
            SPEC%BROADMODE=MODE
          ELSE IF(MODE.EQ.'L') THEN
            SPEC%BROADMODE=MODE
          ELSE IF(MODE.EQ.'N') THEN
            SPEC%BROADMODE=MODE
          ELSE
            CALL ERROR$MSG('!SPECTRUM:BROADMODE MUST BE N, G OR L')
            CALL ERROR$MSG('N: NO BROADENING')
            CALL ERROR$MSG('G: GAUSSIAN BROADENING')
            CALL ERROR$MSG('L: LORENTZIAN BROADENING')
            CALL ERROR$I4VAL('ISPEC',ISPEC)
            CALL ERROR$STOP('RIXSCNTL$SPECTRUM')
          END IF
        ELSE
          SPEC%BROADMODE='N'
        ENDIF
!       ELASTIC (OPTIONAL)
        CALL LINKEDLIST$EXISTD(LL_CNTL,'ELASTIC',1,TCHK)
        IF(TCHK) THEN
          CALL LINKEDLIST$GET(LL_CNTL,'ELASTIC',1,SPEC%TELASTIC)
        ELSE
          SPEC%TELASTIC=.FALSE.
        END IF
!       OMEGA (MANDATORY, IF !COREHOLE:OMEGA NOT GIVEN)
        CALL LINKEDLIST$EXISTD(LL_CNTL,'OMEGA[EV]',1,TCHK)
!       OMEGA NOT DEFINED IN !SPECTRUM OR !COREHOLE
        IF(.NOT.(TCHK.OR.SETTINGS%TOMEGA)) THEN
          CALL ERROR$MSG('OMEGA[EV] NOT FOUND IN EITHER !COREHOLE OR !SPECTRUM')
          CALL ERROR$MSG('NEEDS TO BE DEFINED IN ONE OF THE TWO')
          CALL ERROR$MSG('!SPECTRUM OVERWRITES !COREHOLE')
          CALL ERROR$I4VAL('ISPEC',ISPEC)
          CALL ERROR$STOP('RIXSCNTL$SPECTRUM')
        END IF
        IF(TCHK) THEN
          CALL LINKEDLIST$GET(LL_CNTL,'OMEGA[EV]',1,SPEC%OMEGA)
          SPEC%OMEGA=SPEC%OMEGA*EV
        ELSE
          SPEC%OMEGA=SETTINGS%OMEGA
        END IF
!
!       INCOMING LIGHT
!       POLARISATION IN CARTHESIAN COORDINATES
        CALL LINKEDLIST$EXISTD(LL_CNTL,'POLXYZI',1,TCHK)
        IF(TCHK) THEN
          CALL LINKEDLIST$GET(LL_CNTL,'POLXYZI',1,REALPOLXYZ)
          SPEC%TPOLXYZI=.TRUE.
          SPEC%POLXYZI(1)=CMPLX(REALPOLXYZ(1),REALPOLXYZ(2),KIND=8)
          SPEC%POLXYZI(2)=CMPLX(REALPOLXYZ(3),REALPOLXYZ(4),KIND=8)
          SPEC%POLXYZI(3)=CMPLX(REALPOLXYZ(5),REALPOLXYZ(6),KIND=8)
        ELSE
          SPEC%TPOLXYZI=.FALSE.
        END IF
!       NORMAL OF THE SYSTEM
        CALL LINKEDLIST$EXISTD(LL_CNTL,'NORMALI',1,TCHK)
        CALL LINKEDLIST$EXISTD(LL_CNTL,'KDIRI',1,TCHK1)
        CALL LINKEDLIST$EXISTD(LL_CNTL,'POLI',1,TCHK2)

        IF(SPEC%TPOLXYZI) THEN
          IF(TCHK.OR.TCHK1.OR.TCHK2) THEN
            CALL ERROR$MSG('NORMALI, KDIRI, OR POLI NOT COMPATIBLE WITH POLXYZI')
            CALL ERROR$I4VAL('ISPEC',ISPEC)
            CALL ERROR$STOP('RIXSCNTL$SPECTRUM')
          END IF
        ELSE
          IF(.NOT.(TCHK.AND.TCHK1.AND.TCHK2)) THEN
            CALL ERROR$MSG('!SPECTRUM REQUIRES ONE OF TWO OPTIONS:')
            CALL ERROR$MSG(' - NORMALI, KDIRI, AND POLI')
            CALL ERROR$MSG(' - POLXYZI')
            CALL ERROR$I4VAL('ISPEC',ISPEC)
            CALL ERROR$STOP('RIXSCNTL$SPECTRUM')
          END IF
!         NORMAL OF THE SYSTEM
          CALL LINKEDLIST$GET(LL_CNTL,'NORMALI',1,SPEC%NORMALI)
!         DIRECTION OF THE K-VECTOR
          CALL LINKEDLIST$GET(LL_CNTL,'KDIRI',1,SPEC%KDIRI)
!         POLARISATION
          CALL LINKEDLIST$GET(LL_CNTL,'POLI',1,REALPOL)
          SPEC%POLI(1)=CMPLX(REALPOL(1),REALPOL(2),KIND=8)
          SPEC%POLI(2)=CMPLX(REALPOL(3),REALPOL(4),KIND=8)
        END IF
!
!       OUTGOING LIGHT
!       POLARISATION IN CARTHESIAN COORDINATES
        CALL LINKEDLIST$EXISTD(LL_CNTL,'POLXYZO',1,TCHK)
        IF(TCHK) THEN
          CALL LINKEDLIST$GET(LL_CNTL,'POLXYZO',1,REALPOLXYZ)
          SPEC%TPOLXYZO=.TRUE.
          SPEC%POLXYZO(1)=CMPLX(REALPOLXYZ(1),REALPOLXYZ(2),KIND=8)
          SPEC%POLXYZO(2)=CMPLX(REALPOLXYZ(3),REALPOLXYZ(4),KIND=8)
          SPEC%POLXYZO(3)=CMPLX(REALPOLXYZ(5),REALPOLXYZ(6),KIND=8)
        ELSE
          SPEC%TPOLXYZO=.FALSE.
        END IF
!       NORMAL OF THE SYSTEM
        CALL LINKEDLIST$EXISTD(LL_CNTL,'NORMALO',1,TCHK)
        CALL LINKEDLIST$EXISTD(LL_CNTL,'KDIRO',1,TCHK1)
        CALL LINKEDLIST$EXISTD(LL_CNTL,'POLO',1,TCHK2)
        IF(SPEC%TPOLXYZO) THEN
          IF(TCHK.OR.TCHK1.OR.TCHK2) THEN
            CALL ERROR$MSG('NORMALO, KDIRO, OR POLO NOT COMPATIBLE WITH POLXYZO')
            CALL ERROR$I4VAL('ISPEC',ISPEC)
            CALL ERROR$STOP('RIXSCNTL$SPECTRUM')
          END IF
        ELSE
          IF(.NOT.(TCHK.AND.TCHK1.AND.TCHK2)) THEN
            CALL ERROR$MSG('!SPECTRUM REQUIRES ONE OF TWO OPTIONS:')
            CALL ERROR$MSG(' - NORMALO, KDIRO, AND POLO')
            CALL ERROR$MSG(' - POLXYZO')
            CALL ERROR$I4VAL('ISPEC',ISPEC)
            CALL ERROR$STOP('RIXSCNTL$SPECTRUM')
          END IF
!         NORMAL OF THE SYSTEM
          CALL LINKEDLIST$GET(LL_CNTL,'NORMALO',1,SPEC%NORMALO)
!         DIRECTION OF THE K-VECTOR
          CALL LINKEDLIST$GET(LL_CNTL,'KDIRO',1,SPEC%KDIRO)
!         POLARISATION
          CALL LINKEDLIST$GET(LL_CNTL,'POLO',1,REALPOL)
          SPEC%POLO(1)=CMPLX(REALPOL(1),REALPOL(2),KIND=8)
          SPEC%POLO(2)=CMPLX(REALPOL(3),REALPOL(4),KIND=8)
        END IF
      ENDDO
      TSPECTRUM=.TRUE.
                          CALL TRACE$POP
      END SUBROUTINE RIXSCNTL$SPECTRUM
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXSCNTL$COREHOLE  ! MARK: RIXSCNTL$COREHOLE
!     **************************************************************************
!     **                                                                      **
!     **************************************************************************
      USE RIXSCNTL_MODULE, ONLY: LL_CNTL
      USE RIXS_MODULE, ONLY: SETTINGS,TSIM,TSETTINGS,TRSTRT,THIS
      USE LINKEDLIST_MODULE
      IMPLICIT NONE
      LOGICAL(4) :: TCHK
      INTEGER(4) :: NCORE
      INTEGER(4) :: LCORE
      CHARACTER(256) :: ATOM
      INTEGER(4) :: IAT
      REAL(8) :: EV
      REAL(8) :: SVAR
!     **************************************************************************
                          CALL TRACE$PUSH('RIXSCNTL$COREHOLE')
      CALL CONSTANTS('EV',EV)
      CALL LINKEDLIST$SELECT(LL_CNTL,'~')
      CALL LINKEDLIST$SELECT(LL_CNTL,'XCNTL')
      CALL LINKEDLIST$EXISTL(LL_CNTL,'COREHOLE',1,TCHK)
      IF(.NOT.TCHK) THEN
        CALL ERROR$MSG('!COREHOLE NOT FOUND IN !XCNTL')
        CALL ERROR$STOP('RIXSCNTL$COREHOLE')
      END IF
      CALL LINKEDLIST$SELECT(LL_CNTL,'COREHOLE')
!     == READ ENERGY OF INCOMING LIGHT (MANDATORY, IF NOT GIVEN IN SPECTRUM) ===
      CALL LINKEDLIST$EXISTD(LL_CNTL,'OMEGA[EV]',1,SETTINGS%TOMEGA)
      IF(SETTINGS%TOMEGA) THEN
        CALL LINKEDLIST$GET(LL_CNTL,'OMEGA[EV]',1,SETTINGS%OMEGA)
        SETTINGS%OMEGA=SETTINGS%OMEGA*EV
      END IF
!     == READ LIFETIME (OPTIONAL) ==============================================
      CALL LINKEDLIST$EXISTD(LL_CNTL,'GAMMA[EV]',1,TCHK)
      IF(TCHK) THEN
        CALL LINKEDLIST$GET(LL_CNTL,'GAMMA[EV]',1,SVAR)
        SETTINGS%GAMMA=SVAR*EV
      ELSE
        SETTINGS%GAMMA=0.3D0*EV
      END IF
!     THE FOLLOWING SETTINGS ARE NOT NECESSARY WHEN READING FROM RESTART FILE
      IF(TRSTRT) THEN
                          CALL TRACE$POP
        TSETTINGS=.TRUE.
        RETURN
      END IF
!     == READ ATOM AND COREHOLE SETTINGS =======================================
      CALL LINKEDLIST$EXISTD(LL_CNTL,'ATOM',1,TCHK)
      IF(.NOT.TCHK) THEN
        CALL ERROR$MSG('ATOM NOT FOUND IN !COREHOLE')
        CALL ERROR$STOP('RIXSCNTL$COREHOLE')
      END IF
      CALL LINKEDLIST$GET(LL_CNTL,'ATOM',1,ATOM)
      SETTINGS%ATOM=TRIM(ATOM)

      CALL LINKEDLIST$EXISTD(LL_CNTL,'NCORE',1,TCHK)
      IF(.NOT.TCHK) THEN
        CALL ERROR$MSG('NCORE NOT FOUND IN !COREHOLE')
        CALL ERROR$STOP('RIXSCNTL$COREHOLE')
      END IF
      CALL LINKEDLIST$GET(LL_CNTL,'NCORE',1,NCORE)
      SETTINGS%NCORE=NCORE
! TODO: CHECK IF LCORE IS VALID FOR GIVEN NCORE
      CALL LINKEDLIST$EXISTD(LL_CNTL,'LCORE',1,TCHK)
      IF(.NOT.TCHK) THEN
        CALL ERROR$MSG('LCORE NOT FOUND IN !COREHOLE')
        CALL ERROR$STOP('RIXSCNTL$COREHOLE')
      END IF
      CALL LINKEDLIST$GET(LL_CNTL,'LCORE',1,LCORE)
      IF(LCORE.NE.0) THEN
        CALL ERROR$MSG('IMPLEMENTATION ONLY FOR S COREHOLES (LCORE=0)')
        CALL ERROR$I4VAL('LCORE',LCORE)
        CALL ERROR$STOP('RIXSCNTL$COREHOLE')
      END IF
      SETTINGS%LCORE=LCORE

      TSETTINGS=.TRUE.
                          CALL TRACE$POP
      END SUBROUTINE RIXSCNTL$COREHOLE
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXSCNTL$ATOMCHECK  ! MARK: RIXSCNTL$ATOMCHECK
!     **************************************************************************
!     ** CHECK IF ATOM SELECTED IN !COREHOLE IS IN SIMULATION                 **
!     ** NOT NECESSARY WHEN READING FROM RESTART FILE AS DIPOLE IS CALCULATED **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: TSIM,THIS,SETTINGS,TSETTINGS,TRSTRT
      IMPLICIT NONE
      LOGICAL(4) :: TCHK
      INTEGER(4) :: IAT
!     **************************************************************************
                          CALL TRACE$PUSH('RIXSCNTL$ATOMCHECK')
      IF(TRSTRT) THEN
                          CALL TRACE$POP
        RETURN
      END IF
      IF(.NOT.TSIM) THEN
        CALL ERROR$MSG('SIMULATION DATA NOT ALLOCATED')
        CALL ERROR$MSG('MUST BE CALLED AFTER RIXS$READ TO ACCESS ATOM NAMES')
        CALL ERROR$STOP('RIXSCNTL$ATOMCHECK')
      END IF
      IF(.NOT.TSETTINGS) THEN
        CALL ERROR$MSG('SETTINGS NOT FULLY READ')
        CALL ERROR$MSG('MUST BE CALLED AFTER RIXSCNTL$COREHOLE')
        CALL ERROR$STOP('RIXSCNTL$ATOMCHECK')
      END IF
      TCHK=.FALSE.
      CALL RIXS$SELECT('GROUNDSTATE')
      DO IAT=1,THIS%NAT
        IF(TRIM(SETTINGS%ATOM).EQ.TRIM(THIS%ATOMID(IAT))) THEN
          TCHK=.TRUE.
          EXIT
        END IF
      ENDDO
      CALL RIXS$UNSELECT
      IF(TCHK) THEN
        SETTINGS%IATOM=IAT
      ELSE
        CALL ERROR$MSG('!COREHOLE:ATOM ID NOT FOUND IN SIMULATION')
        CALL ERROR$CHVAL('ATOM',SETTINGS%ATOM)
        CALL ERROR$STOP('RIXSCNTL$ATOMCHECK')
      END IF
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE RIXSCNTL$ATOMCHECK
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXSCNTL$OUTPUT  ! MARK: RIXSCNTL$OUTPUT
!     **************************************************************************
!     **                                                                      **
!     **************************************************************************
      USE RIXSCNTL_MODULE, ONLY: LL_CNTL
      USE RIXS_MODULE, ONLY: OUTPUT
      USE LINKEDLIST_MODULE
      IMPLICIT NONE
      LOGICAL(4) :: TCHK
                          CALL TRACE$PUSH('RIXSCNTL$OUTPUT')
      OUTPUT%TOVL=.FALSE.
      OUTPUT%TOVLPW=.FALSE.
      OUTPUT%TOVLAUG=.FALSE.
      OUTPUT%TAMAT=.FALSE.
      OUTPUT%TBMAT=.FALSE.
      OUTPUT%TCMAT=.FALSE.
      OUTPUT%TDMAT=.FALSE.
      OUTPUT%TKMAT=.FALSE.
      OUTPUT%TDIPOLE=.FALSE.
      OUTPUT%TADET=.FALSE.
      OUTPUT%TRAW=.FALSE.
      OUTPUT%TKPTSPIN=.FALSE.
      OUTPUT%TBINARY=.FALSE.
      CALL LINKEDLIST$SELECT(LL_CNTL,'~')
      CALL LINKEDLIST$SELECT(LL_CNTL,'XCNTL')
      CALL LINKEDLIST$EXISTL(LL_CNTL,'OUTPUT',1,TCHK)
      IF(.NOT.TCHK) THEN
                          CALL TRACE$POP
        RETURN
      END IF
      CALL LINKEDLIST$SELECT(LL_CNTL,'OUTPUT')
! !     TOVL
!       CALL LINKEDLIST$EXISTD(LL_CNTL,'OVL',1,TCHK)
!       IF(TCHK) CALL LINKEDLIST$GET(LL_CNTL,'OVL',1,OUTPUT%TOVL)
! !     TOVLPW
!       CALL LINKEDLIST$EXISTD(LL_CNTL,'OVLPW',1,TCHK)
!       IF(TCHK) CALL LINKEDLIST$GET(LL_CNTL,'OVLPW',1,OUTPUT%TOVLPW)
! !     TOVLAUG
!       CALL LINKEDLIST$EXISTD(LL_CNTL,'OVLAUG',1,TCHK)
!       IF(TCHK) CALL LINKEDLIST$GET(LL_CNTL,'OVLAUG',1,OUTPUT%TOVLAUG)
! !     TAMAT
!       CALL LINKEDLIST$EXISTD(LL_CNTL,'AMAT',1,TCHK)
!       IF(TCHK) CALL LINKEDLIST$GET(LL_CNTL,'AMAT',1,OUTPUT%TAMAT)
! !     TBMAT
!       CALL LINKEDLIST$EXISTD(LL_CNTL,'BMAT',1,TCHK)
!       IF(TCHK) CALL LINKEDLIST$GET(LL_CNTL,'BMAT',1,OUTPUT%TBMAT)
! !     TCMAT
!       CALL LINKEDLIST$EXISTD(LL_CNTL,'CMAT',1,TCHK)
!       IF(TCHK) CALL LINKEDLIST$GET(LL_CNTL,'CMAT',1,OUTPUT%TCMAT)
! !     TDMAT
!       CALL LINKEDLIST$EXISTD(LL_CNTL,'DMAT',1,TCHK)
!       IF(TCHK) CALL LINKEDLIST$GET(LL_CNTL,'DMAT',1,OUTPUT%TDMAT)
! !     TKMAT
!       CALL LINKEDLIST$EXISTD(LL_CNTL,'KMAT',1,TCHK)
!       IF(TCHK) CALL LINKEDLIST$GET(LL_CNTL,'KMAT',1,OUTPUT%TKMAT)
! !     TDIPOLE
!       CALL LINKEDLIST$EXISTD(LL_CNTL,'DIPOLE',1,TCHK)
!       IF(TCHK) CALL LINKEDLIST$GET(LL_CNTL,'DIPOLE',1,OUTPUT%TDIPOLE)
!     TADET
      CALL LINKEDLIST$EXISTD(LL_CNTL,'ADET',1,TCHK)
      IF(TCHK) CALL LINKEDLIST$GET(LL_CNTL,'ADET',1,OUTPUT%TADET)
! !     TRAW
!       CALL LINKEDLIST$EXISTD(LL_CNTL,'RAW',1,TCHK)
!       IF(TCHK) CALL LINKEDLIST$GET(LL_CNTL,'RAW',1,OUTPUT%TRAW)
!     TKPTSPIN
      CALL LINKEDLIST$EXISTD(LL_CNTL,'KPTSPIN',1,TCHK)
      IF(TCHK) CALL LINKEDLIST$GET(LL_CNTL,'KPTSPIN',1,OUTPUT%TKPTSPIN)
! !     TBINARY
!       CALL LINKEDLIST$EXISTD(LL_CNTL,'BINARY',1,TCHK)
!       IF(TCHK) CALL LINKEDLIST$GET(LL_CNTL,'BINARY',1,OUTPUT%TBINARY)
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE RIXSCNTL$OUTPUT
!      
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE INITIALIZEFILEHANDLER
!     **************************************************************************
      USE STRINGS_MODULE
      IMPLICIT NONE
      CHARACTER(256) :: ROOTNAME
      CHARACTER(256) :: RIXSINNAME
      INTEGER(4)     :: ISVAR
      INTEGER(4)     :: NARGS
!     **************************************************************************
                          CALL TRACE$PUSH('INITIALIZEFILEHANDLER')
      NARGS=COMMAND_ARGUMENT_COUNT()
      IF(NARGS.LT.1) THEN
        CALL ERROR$MSG('ARGUMENT LIST OF EXECUTABLE IS EMPTY')
        CALL ERROR$MSG('THE CONTROL FILE OF THE RIXS TOOL IS MANDATORY')
        CALL ERROR$STOP('INITIALIZEFILEANDLER')
      END IF
      CALL GET_COMMAND_ARGUMENT(1,RIXSINNAME)
      ISVAR=INDEX(RIXSINNAME,-'.XCNTL',BACK=.TRUE.)
      IF(ISVAR.NE.0) THEN
        ROOTNAME=RIXSINNAME(1:ISVAR-1)
      ELSE
        ROOTNAME=' '
      END IF
      CALL FILEHANDLER$SETROOT(ROOTNAME)
      CALL STANDARDFILES
      CALL FILEHANDLER$SETFILE('XCNTL',.FALSE.,RIXSINNAME)
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE INITIALIZEFILEHANDLER
!
!      ..1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE STANDARDFILES
!     **************************************************************************
      USE STRINGS_MODULE
      IMPLICIT NONE
      CHARACTER(32)        :: ID
      INTEGER(4)          :: THISTASK
      INTEGER(4)          :: NTASKS
!     **************************************************************************
                                   CALL TRACE$PUSH('STANDARDFILES')
!     ==========================================================================
!     == SET STANDARD FILENAMES                                               ==
!     ==========================================================================
!     ==  ERROR FILE ===========================================================
      ID=+'ERR'
      CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.XERR')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','REPLACE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','APPEND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','WRITE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')
!     ==  PROTOCOL FILE ========================================================
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      ID=+'PROT'
      IF(THISTASK.GT.1) THEN
        CALL FILEHANDLER$SETFILE(ID,.FALSE.,-'/DEV/NULL')
      ELSE
        CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.XPROT')
      END IF
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','REPLACE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','APPEND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','WRITE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')
!     ==  CONTROL FILE  == =====================================================
      ID=+'XCNTL'
      CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.XCNTL')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','OLD')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','REWIND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','READ')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')
!     ==  GROUNDSTATE RIXS FILE   ===============================================
      ID=+'GROUNDSTATE'
      CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.GROUND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','OLD')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','REWIND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','READ')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','UNFORMATTED')
!     ==  EXCITED STATE RIXS FILE   =============================================
      ID=+'EXCITESTATE'
      CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.EXCITE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','OLD')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','REWIND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','READ')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','UNFORMATTED')
!     ==  RIXS SPECTRUM FILE PRODUCES AS OUTPUT =================================
!     ==  RESTART FILE WRITING =================================================
      ID=+'RSTRT_OUT'
      CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.RIXSRSTRT')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','REPLACE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','REWIND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','WRITE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','UNFORMATTED')
!     ==  RESTART FILE WRITING =================================================
      ID=+'RSTRT_IN'
      CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.RIXSRSTRT')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','OLD')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','REWIND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','READ')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','UNFORMATTED')
!     ==  WILL BE ATTACHED TO DIFFERENT FILES DURING EXECUTION =================
      ID=+'RIXSOUT'
      CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.RIXSOUT')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','REPLACE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','REWIND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','WRITE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')
!     ==  WILL BE ATTACHED TO DIFFERENT FILES DURING EXECUTION =================
      ID=+'RIXSOUT_KS'
      CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.RIXSOUTKS')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','REPLACE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','REWIND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','WRITE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')

      ! ID=+'OVL'
      ! CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.OVL')
      ! CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','REPLACE')
      ! CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','REWIND')
      ! CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','WRITE')
      ! CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')

      ! ID=+'OVLPW'
      ! CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.OVLPW')
      ! CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','REPLACE')
      ! CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','REWIND')
      ! CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','WRITE')
      ! CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')

      ! ID=+'OVLAUG'
      ! CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.OVLAUG')
      ! CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','REPLACE')
      ! CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','REWIND')
      ! CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','WRITE')
      ! CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')

      ! ID=+'AMAT'
      ! CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.AMAT')
      ! CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','REPLACE')
      ! CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','REWIND')
      ! CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','WRITE')
      ! CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')

      ! ID=+'BMAT'
      ! CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.AMAT')
      ! CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','REPLACE')
      ! CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','REWIND')
      ! CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','WRITE')
      ! CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')

      ! ID=+'CMAT'
      ! CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.CMAT')
      ! CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','REPLACE')
      ! CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','REWIND')
      ! CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','WRITE')
      ! CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')

      ! ID=+'DMAT'
      ! CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.AMAT')
      ! CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','REPLACE')
      ! CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','REWIND')
      ! CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','WRITE')
      ! CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')

      ! ID=+'DIPOLE'
      ! CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.DIPOLE')
      ! CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','REPLACE')
      ! CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','REWIND')
      ! CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','WRITE')
      ! CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')

      ! ID=+'KMAT'
      ! CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.KMAT')
      ! CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','REPLACE')
      ! CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','REWIND')
      ! CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','WRITE')
      ! CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')

      ID=+'ADET'
      CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.ADET')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','REPLACE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','REWIND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','WRITE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')

      ! ID=+'RIXSRAW'
      ! CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.RIXSRAW')
      ! CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','REPLACE')
      ! CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','REWIND')
      ! CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','WRITE')
      ! CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')
                                   CALL TRACE$POP
      RETURN
      END SUBROUTINE STANDARDFILES
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS$READ  ! MARK: RIXS$READ
!     **************************************************************************
!     **  READ FILE PRODUCED BY SIMULATION CODE                               **
!     **************************************************************************
      USE MPE_MODULE
      USE RIXS_MODULE, ONLY: THIS,SIMULATION_TYPE,SIM,TSIM,OVL,OVLARR, &
     &                      TRSTRT,KSMAP,NKPTG,NSPING,RTASK,STATE_TYPE
      USE RADIAL_MODULE, ONLY: NGID
      IMPLICIT NONE
      INTEGER(4), PARAMETER :: NSIM=2
      REAL(8), PARAMETER :: TOL=1.D-8
      LOGICAL(4), PARAMETER :: TPR=.FALSE.
      TYPE(STATE_TYPE), POINTER :: S
      INTEGER(4) :: NFIL(NSIM)
      INTEGER(4) :: IS
      INTEGER(4) :: ILOGICAL
      INTEGER(4) :: ISP
      INTEGER(4) :: GID
      INTEGER(4) :: IGID
      CHARACTER(8) :: GRIDTYPE
      CHARACTER(8) :: GRIDTYPE_
      INTEGER(4) :: NR
      INTEGER(4) :: NR_
      REAL(8) :: DEX
      REAL(8) :: DEX_
      REAL(8) :: R1
      REAL(8) :: R1_
      REAL(8) :: V
      REAL(8) :: OCCLIMIT
      INTEGER(4) :: LNX
      INTEGER(4) :: IB
      INTEGER(4) :: IAT
      INTEGER(4) :: LN
      INTEGER(4) :: L
      INTEGER(4) :: M
      INTEGER(4) :: IPRO
      INTEGER(4) :: IB1,IB2
      INTEGER(4) :: IKPT
      INTEGER(4) :: NKPT_
      INTEGER(4) :: NB_
      INTEGER(4) :: NSPIN_
      INTEGER(4) :: ISPIN
      LOGICAL(4) :: TCHK
      CHARACTER(8) :: KEY(NSIM)
      INTEGER(4) :: NGG(NSIM)
      INTEGER(4) :: NDIM(NSIM)
      INTEGER(4) :: NB(NSIM)
      LOGICAL(4) :: TSUPER(NSIM)
      INTEGER(4), ALLOCATABLE :: IGVEC(:,:,:) ! (NSIM,3,NGG)
      REAL(8) :: XK(NSIM,3)
      COMPLEX(8), ALLOCATABLE :: PSIK1(:,:,:) ! (NGG,NDIM,NB)
      COMPLEX(8), ALLOCATABLE :: PSIK2(:,:,:) ! (NGG,NDIM,NB)
      REAL(8), ALLOCATABLE :: OCC(:,:,:) ! (NB,NKPT,NSPIN)
      INTEGER(4) :: NTASKS,THISTASK
!     **************************************************************************
                          CALL TRACE$PUSH('RIXS$READ')
                          CALL TIMING$CLOCKON('RIXS$READ')
      IF(TRSTRT) THEN
        CALL ERROR$MSG('RIXS$READ CANNOT BE CALLED WHEN RESTART FILE IS GIVEN')
        CALL ERROR$STOP('RIXS$READ')
      END IF
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      IF(ALLOCATED(KSMAP)) THEN
        CALL ERROR$MSG('KSMAP ALREADY ALLOCATED')
        CALL ERROR$STOP('RIXS$READ')
      END IF
!     ==========================================================================
!     == LOOP OVER BOTH SIMULATIONS                                           ==
!     == REQUIRED TO CALCULATE OVERLAP ON READ AND NOT STORE PLANE WAVE BASIS ==
!     ==========================================================================
      DO IS=1,NSIM
        CALL RIXS$ISELECT(IS)
        IF(THISTASK.EQ.1) THEN
          IF(TPR) CALL TRACE$PASS('READING GENERAL QUANTITIES')
          CALL FILEHANDLER$UNIT(THIS%ID,NFIL(IS))
          REWIND(NFIL(IS))
!         ======================================================================
!         == READ GENERAL QUANTATIES                                          ==
!         ======================================================================
!         NAT,NSP,NKPT,NSPIN,NDIM,NPRO,LNXX,FLAG
          READ(NFIL(IS))THIS%NAT,THIS%NSP,THIS%NKPT,THIS%NSPIN,THIS%NDIM, &
&                       THIS%NPRO,THIS%LNXX,THIS%FLAG
        END IF
        CALL MPE$BROADCAST('~',1,THIS%NAT)
        CALL MPE$BROADCAST('~',1,THIS%NSP)
        CALL MPE$BROADCAST('~',1,THIS%NKPT)
        CALL MPE$BROADCAST('~',1,THIS%NSPIN)
        CALL MPE$BROADCAST('~',1,THIS%NDIM)
        CALL MPE$BROADCAST('~',1,THIS%NPRO)
        CALL MPE$BROADCAST('~',1,THIS%LNXX)
        CALL MPE$BROADCAST('~',1,THIS%FLAG)
!       DISTRIBUTE WORKLOAD FOR K-POINT LOOP WHILE READING FOR SIMULATION
        IF(IS.EQ.1) THEN
          NKPTG=THIS%NKPT
          NSPING=THIS%NSPIN
          ALLOCATE(KSMAP(NKPTG,NSPING))
          CALL KSMAPINIT(NKPTG,NSPING,RTASK,KSMAP)
        END IF
        ALLOCATE(THIS%LNX(THIS%NSP))
        ALLOCATE(THIS%LOX(THIS%LNXX,THIS%NSP))
        IF(THISTASK.EQ.RTASK) THEN
!         LNX(NSP),LOX(LNXX,NSP)
          READ(NFIL(IS))THIS%LNX,THIS%LOX
!         NKDIV(3),ISHIFT(3),RNTOT,NEL,TINV
          READ(NFIL(IS))THIS%NKDIV,THIS%ISHIFT,THIS%RNTOT,THIS%NEL, &
&                       THIS%EDFT,ILOGICAL
          THIS%TINV=.FALSE.
          IF(ILOGICAL.EQ.1) THIS%TINV=.TRUE.
!         SPACEGROUP,TSHIFT
          READ(NFIL(IS))THIS%SPACEGROUP,ILOGICAL
          THIS%TSHIFT=.FALSE.
          IF(ILOGICAL.EQ.1) THIS%TSHIFT=.TRUE.
        END IF
        CALL MPE$BROADCAST('~',RTASK,THIS%LNX)
        CALL MPE$BROADCAST('~',RTASK,THIS%LOX)
        CALL MPE$BROADCAST('~',RTASK,THIS%NKDIV)
        CALL MPE$BROADCAST('~',RTASK,THIS%ISHIFT)
        CALL MPE$BROADCAST('~',RTASK,THIS%RNTOT)
        CALL MPE$BROADCAST('~',RTASK,THIS%NEL)
        CALL MPE$BROADCAST('~',RTASK,THIS%EDFT)
        CALL MPE$BROADCAST('~',RTASK,THIS%TINV)
        CALL MPE$BROADCAST('~',RTASK,THIS%SPACEGROUP)
        CALL MPE$BROADCAST('~',RTASK,THIS%TSHIFT)
        ALLOCATE(THIS%LMNX(THIS%NSP))
        THIS%LMNX=0
        DO ISP=1,THIS%NSP
          DO LN=1,THIS%LNX(ISP)
            THIS%LMNX(ISP)=THIS%LMNX(ISP)+2*THIS%LOX(LN,ISP)+1
          ENDDO
        ENDDO
!       ========================================================================
!       == READ ATOMIC STRUCTURE                                              ==
!       ========================================================================
        ALLOCATE(THIS%R(3,THIS%NAT))
        ALLOCATE(THIS%ATOMID(THIS%NAT))
        ALLOCATE(THIS%ISPECIES(THIS%NAT))
        IF(THISTASK.EQ.RTASK) THEN
          IF(TPR) CALL TRACE$PASS('READING ATOMIC STRUCTURE')
!         RBAS(3,3),R(3,NAT),ATOMID(NAT),ISPECIES(NAT)
          READ(NFIL(IS))THIS%RBAS,THIS%R,THIS%ATOMID,THIS%ISPECIES
        END IF
        CALL MPE$BROADCAST('~',RTASK,THIS%RBAS)
        CALL MPE$BROADCAST('~',RTASK,THIS%R)
        CALL MPE$BROADCAST('~',RTASK,THIS%ATOMID)
        CALL MPE$BROADCAST('~',RTASK,THIS%ISPECIES)
        V=THIS%RBAS(1,1)*(THIS%RBAS(2,2)*THIS%RBAS(3,3)-THIS%RBAS(2,3)*THIS%RBAS(3,2)) &
&         +THIS%RBAS(2,1)*(THIS%RBAS(3,2)*THIS%RBAS(1,3)-THIS%RBAS(3,3)*THIS%RBAS(1,2)) &
&         +THIS%RBAS(3,1)*(THIS%RBAS(1,2)*THIS%RBAS(2,3)-THIS%RBAS(1,3)*THIS%RBAS(2,2)) 
!       ========================================================================
!       == ELEMENT SPECIFIC QUANTITIES                                        ==
!       ========================================================================
        ALLOCATE(THIS%SETUP(THIS%NSP))
!       LOOP THROUGH SPECIES
        DO ISP=1,THIS%NSP
          IF(THISTASK.EQ.RTASK) THEN
            IF(TPR) CALL TRACE$PASS('READING ELEMENT SPECIFIC QUANTITIES')
!           GRIDTYPE,NR,DEX,R1
            READ(NFIL(IS))GRIDTYPE,NR,DEX,R1
!           CHECK IF RADIAL GRID WITH SAME PROPERTIES ALREADY EXISTS
            TCHK=.FALSE.
            IF(NGID.GT.0) THEN
              DO IGID=1,NGID
                CALL RADIAL$GETCH(IGID,'TYPE',GRIDTYPE_)
                CALL RADIAL$GETI4(IGID,'NR',NR_)
                CALL RADIAL$GETR8(IGID,'DEX',DEX_)
                CALL RADIAL$GETR8(IGID,'R1',R1_)
                IF(GRIDTYPE.EQ.GRIDTYPE_.AND.NR.EQ.NR_.AND.DEX.EQ.DEX_.AND.R1.EQ.R1_) THEN
                  GID=IGID
                  TCHK=.TRUE.
                  EXIT
                END IF
              ENDDO ! END IGID
            END IF
          END IF
          CALL MPE$BROADCAST('~',RTASK,GRIDTYPE)
          CALL MPE$BROADCAST('~',RTASK,NR)
          CALL MPE$BROADCAST('~',RTASK,DEX)
          CALL MPE$BROADCAST('~',RTASK,R1)
          CALL MPE$BROADCAST('~',RTASK,TCHK)
          CALL MPE$BROADCAST('~',RTASK,GID)
!         IF GRID ALREADY EXISTS, USE ITS GID. ELSE CREATE NEW GRID
          IF(TCHK) THEN
            THIS%SETUP(ISP)%GID=GID
          ELSE
            CALL RADIAL$NEW(GRIDTYPE,THIS%SETUP(ISP)%GID)
            CALL RADIAL$SETI4(THIS%SETUP(ISP)%GID,'NR',NR)
            CALL RADIAL$SETR8(THIS%SETUP(ISP)%GID,'DEX',DEX)
            CALL RADIAL$SETR8(THIS%SETUP(ISP)%GID,'R1',R1)
          END IF
!         ECORE
          IF(THISTASK.EQ.RTASK) READ(NFIL(IS))THIS%SETUP(ISP)%ECORE
          CALL MPE$BROADCAST('~',RTASK,THIS%SETUP(ISP)%ECORE)
!         ALLOCATE AND READ (AUXILIARY) PARTIAL WAVES
          LNX=THIS%LNX(ISP)
          ALLOCATE(THIS%SETUP(ISP)%PSPHI(NR,LNX))
          ALLOCATE(THIS%SETUP(ISP)%AEPHI(NR,LNX))
          IF(THISTASK.EQ.RTASK) THEN
!           PSPHI(NR,LNX)
            READ(NFIL(IS))THIS%SETUP(ISP)%PSPHI
!           AEPHI(NR,LNX)
            READ(NFIL(IS))THIS%SETUP(ISP)%AEPHI
!           NBATOM
            READ(NFIL(IS))THIS%SETUP(ISP)%NBATOM
          END IF
          CALL MPE$BROADCAST('~',RTASK,THIS%SETUP(ISP)%PSPHI)
          CALL MPE$BROADCAST('~',RTASK,THIS%SETUP(ISP)%AEPHI)
          CALL MPE$BROADCAST('~',RTASK,THIS%SETUP(ISP)%NBATOM)
!         ALLOCATE AND READ ATOMIC WAVE FUNCTIONS
          ALLOCATE(THIS%SETUP(ISP)%LATOM(THIS%SETUP(ISP)%NBATOM))
          ALLOCATE(THIS%SETUP(ISP)%AEPSI(NR,THIS%SETUP(ISP)%NBATOM))
          IF(THISTASK.EQ.RTASK) THEN
!           LATOM(NBATOM)
            READ(NFIL(IS))THIS%SETUP(ISP)%LATOM       
!           AEPSI(NR,NBATOM)
            READ(NFIL(IS))THIS%SETUP(ISP)%AEPSI
          END IF
          CALL MPE$BROADCAST('~',RTASK,THIS%SETUP(ISP)%LATOM)
          CALL MPE$BROADCAST('~',RTASK,THIS%SETUP(ISP)%AEPSI)
        ENDDO ! END ISP
!       ========================================================================
!       == OCCUPATIONS AND K-POINTS AND THEIR WEIGHTS                         ==
!       ========================================================================
        IF(THISTASK.EQ.RTASK) THEN
          IF(TPR) CALL TRACE$PASS('READING OCC, KPTS, WEIGHTS')
          READ(NFIL(IS))NB_,NKPT_,NSPIN_
        END IF
        CALL MPE$BROADCAST('~',RTASK,NB_)
        CALL MPE$BROADCAST('~',RTASK,NKPT_)
        CALL MPE$BROADCAST('~',RTASK,NSPIN_)

        ALLOCATE(THIS%STATEARR(NKPT_,NSPIN_))
        ALLOCATE(THIS%XK(3,NKPT_))
        ALLOCATE(THIS%WKPT(NKPT_))
        ALLOCATE(OCC(NB_,NKPT_,NSPIN_))
!       OCC(NB,NKPT,NSPIN),XK(3,NKPT),WKPT(NKPT)
        IF(THISTASK.EQ.RTASK) READ(NFIL(IS))OCC,THIS%XK,THIS%WKPT
        CALL MPE$BROADCAST('~',RTASK,OCC)
        CALL MPE$BROADCAST('~',RTASK,THIS%XK)
        CALL MPE$BROADCAST('~',RTASK,THIS%WKPT)
        DO IKPT=1,NKPT_
          DO ISPIN=1,NSPIN_
            IF(KSMAP(IKPT,ISPIN).NE.THISTASK.AND.THISTASK.NE.RTASK) CYCLE
            S=>THIS%STATEARR(IKPT,ISPIN)
            S%NB=NB_
            ALLOCATE(S%OCC(NB_))
            S%OCC(:)=OCC(:,IKPT,ISPIN)
!           COUNT NUMBER OF OCCUPIED STATES BASED ON OCCUPATION 
!           (INTEGRATION WEIGHTS)IF NO FERMI LEVEL IS GIVEN
! ERROR: INVALID METHOD TO COUNT OCCUPIED STATES
            IF(.NOT.THIS%TFERMI) THEN
              OCCLIMIT=S%OCCPERCENT*(MOD(NSPING,2)+1)
              S%NOCC=-1
              DO IB=1,NB_
                IF(S%OCC(IB)/THIS%WKPT(IKPT).LT.OCCLIMIT) THEN
                  S%NOCC=IB-1
                  EXIT
                END IF
              ENDDO ! END IB
              IF(S%NOCC.EQ.-1) THEN
                IF(THIS%ID.EQ.'EXCITESTATE') THEN
                  CALL ERROR$MSG('NO UNOCCUPIED STATES FOUND FOR EXCITESTATE')
                  CALL ERROR$STOP('RIXS$READ')
                END IF
                S%NOCC=NB_
              END IF
            END IF
          ENDDO ! END ISPIN
        ENDDO ! END IKPT
        DEALLOCATE(OCC)
!       ========================================================================
!       == MAPPING OF PROJECTION INDICES                                      ==
!       ========================================================================
        ALLOCATE(THIS%MAP(THIS%NAT,THIS%LNXX))
        THIS%MAP(:,:)=0
        IPRO=0
        DO IAT=1,THIS%NAT
          ISP=THIS%ISPECIES(IAT)
          DO LN=1,THIS%LNX(ISP)
            THIS%MAP(IAT,LN)=IPRO
            L=THIS%LOX(LN,ISP)
            DO M=1,2*L+1
              IPRO=IPRO+1
            ENDDO ! END M
          ENDDO ! END LN
        ENDDO ! END IAT
        CALL RIXS$UNSELECT
      ENDDO ! END IS (NSIM)
!     MAP ATOM INDICES BASED ON NAMES
      CALL ATOMMAPPING
!     CALCULATE TOTAL CORE ENERGY
      CALL RIXS_COREENERGY
!     ADD TOGETHER FOR TOTAL ENERGY
      CALL RIXS$SELECT('GROUNDSTATE')
      THIS%ETOT=THIS%EDFT+THIS%ECORE
      CALL RIXS$UNSELECT
      CALL RIXS$SELECT('EXCITESTATE')
      THIS%ETOT=THIS%EDFT+THIS%ECORE
      CALL RIXS$UNSELECT
!     ==================================================================
!     == DATA CONSISTENCY CHECKS BETWEEN BOTH SIMULATIONS             ==
!     ==================================================================
      CALL DATACONSISTENCY

!     ALLOCATE STORAGE ARRAYS FOR OVERLAP_TYPES AND STATE_TYPES
      ALLOCATE(OVLARR(NKPTG,NSPING))
!
!     ==================================================================
!     == WAVE FUNCTIONS AND PROJECTIONS                               ==
!     ==================================================================
!     LOOP OVER K POINTS
      DO IKPT=1,NKPTG
        IF(ALL(KSMAP(IKPT,:).NE.THISTASK).AND.THISTASK.NE.RTASK) CYCLE
        IF(THISTASK.EQ.RTASK) THEN
          CALL TRACE$I4VAL(' READ/SEND IKPT',IKPT)
!         READ GENERAL INFORMATION ABOUT K POINT
          DO IS=1,NSIM
!           KEY,NGG,NDIM,NB,NBH,TSUPER
            READ(NFIL(IS))KEY(IS),NGG(IS),NDIM(IS),NB(IS),ILOGICAL
            TSUPER(IS)=.FALSE.
            IF(ILOGICAL.EQ.1) TSUPER(IS)=.TRUE.
            IF(KEY(IS).NE.'PSI') THEN
              CALL ERROR$MSG('KEY NOT "PSI"')
              CALL ERROR$MSG('FILE IS CORRUPTED')
              CALL ERROR$CHVAL('KEY',KEY(IS))
              CALL ERROR$I4VAL('IKPT',IKPT)
              CALL ERROR$STOP('RIXS$READ')
            END IF
          ENDDO ! END LOOP OVER IS
!         READ K POINT AND G VECTORS (PREVIOUSLY CHECKED IF #(NGG1,NGG2) SAME)
          ALLOCATE(IGVEC(NSIM,3,NGG(1)))
          DO IS=1,NSIM
!           XK(3),IGVEC(3,NGG)
            READ(NFIL(IS))XK(IS,:),IGVEC(IS,:,:)
          ENDDO ! END LOOP OVER IS
!         ==================================================================
!         == DATA CHECKS                                                  ==
!         ==================================================================
! NOTE: DATA CHECKS USE VARIABLES FROM THIS SUBROUTINE, POSITION OF CALL MATTERS     
          CALL TEST
          DEALLOCATE(IGVEC)
        END IF
        DO ISPIN=1,NSPING
          CALL MPE$SENDRECEIVE('~',RTASK,KSMAP(IKPT,ISPIN),NGG)
          CALL MPE$SENDRECEIVE('~',RTASK,KSMAP(IKPT,ISPIN),NDIM)
          CALL MPE$SENDRECEIVE('~',RTASK,KSMAP(IKPT,ISPIN),NB)
        ENDDO
! WARNING: REQUIRES SUPER WAVE FUNCTIONS TO BE UNRAVELED
        ALLOCATE(PSIK1(NGG(1),NDIM(1),NB(1)))
        ALLOCATE(PSIK2(NGG(2),NDIM(2),NB(2)))
!       LOOP OVER SPIN
        DO ISPIN=1,NSPING
          IF(KSMAP(IKPT,ISPIN).NE.THISTASK.AND.THISTASK.NE.RTASK) CYCLE
!         SET STATE POINTER
          DO IS=1,NSIM
!           SET POINTER TO SPECIFIC STATE(IKPT,ISPIN)
            SIM(IS)%STATE=>SIM(IS)%STATEARR(IKPT,ISPIN)
            S=>SIM(IS)%STATEARR(IKPT,ISPIN)
!           CHECK IF NB CONSISTENT FOR OCCUPATIONS AND EIGENVALUES/PROJECTIONS
            IF(NB(IS).NE.S%NB) THEN
              CALL ERROR$MSG('NB FOR PROJECTIONS AND EIGENVALUES NOT THE SAME')
              CALL ERROR$MSG('FOR OCCUPATIONS AND EIGENVALUES/PROJECTIONS')
              CALL ERROR$I4VAL('NB_OCC',S%NB)
              CALL ERROR$I4VAL('NB_PROJ',NB(IS))
              CALL ERROR$STOP('RIXS$READ')
            END IF
!           ALLOCATE STORAGE FOR PROJECTIONS
            ALLOCATE(S%PROJ(NDIM(IS),NB(IS),SIM(IS)%NPRO))
!           ALLOCATE STORAGE FOR EIGENVALUES
            ALLOCATE(S%EIG(NB(IS)))
          ENDDO ! END LOOP OVER IS
!         SET POINTER TO SPECIFIC OVERLAP(IKPT,ISPIN)
          OVL=>OVLARR(IKPT,ISPIN)
! WARNING: FIND OUT REQUIRED ORDER OF OVERLAP
!         ALLOCATE STORAGE FOR OVERLAP
          IF(THISTASK.EQ.KSMAP(IKPT,ISPIN)) THEN
            ALLOCATE(OVL%PW(NB(2),NB(1)))
          END IF
          IF(THISTASK.EQ.RTASK) THEN
!           READ PLANE WAVE BASIS
            READ(NFIL(1))PSIK1
            READ(NFIL(2))PSIK2
!           READ PROJECTIONS
            READ(NFIL(1))SIM(1)%STATE%PROJ
            READ(NFIL(2))SIM(2)%STATE%PROJ
!           READ EIGENVALUES
            READ(NFIL(1))SIM(1)%STATE%EIG
            READ(NFIL(2))SIM(2)%STATE%EIG
          END IF
          CALL MPE$SENDRECEIVE('~',RTASK,KSMAP(IKPT,ISPIN),PSIK1)
          CALL MPE$SENDRECEIVE('~',RTASK,KSMAP(IKPT,ISPIN),PSIK2)
          DO IS=1,NSIM
            CALL MPE$SENDRECEIVE('~',RTASK,KSMAP(IKPT,ISPIN),SIM(IS)%STATE%PROJ)
            CALL MPE$SENDRECEIVE('~',RTASK,KSMAP(IKPT,ISPIN),SIM(IS)%STATE%EIG)
          ENDDO
          CALL TIMING$CLOCKON('RIXS$READ_SCALARPRODUCT')
          IF(THISTASK.EQ.KSMAP(IKPT,ISPIN)) THEN
            CALL TRACE$I4VAL(' CALCULATING IKPT',IKPT)
            DO IB2=1,NB(2) ! LOOP OVER BANDS
              DO IB1=1,NB(1) ! LOOP OVER BANDS
!               NO NDIM LOOP AS NDIM=1
!               SCALARPRODUCT (SUM OVER G VECTORS)
!               PW(I,J)=<PSI1(J)|PSI2(I)>
! WARNING: CHECK IF SCALARPRODUCT IS CORRECT ALSO WITH CONJG
!          SHOULD BE THE CASE AS CALL OF ZGEMM IS DONE WITH 'C' OPTION
! WARNING: CHECK WILL NOT WORK IF ONLY USING REAL WAVE FUNCTIONS AT GAMMA POINT
                CALL LIB$SCALARPRODUCTC8(.FALSE.,NGG(1),1,PSIK1(:,1,IB1),1,PSIK2(:,1,IB2),OVL%PW(IB2,IB1))
              ENDDO ! END LOOP OVER BANDS
            ENDDO ! END LOOP OVER BANDS
            OVL%PW=OVL%PW*V
          END IF
          CALL TIMING$CLOCKOFF('RIXS$READ_SCALARPRODUCT')
          IF(THISTASK.EQ.KSMAP(IKPT,ISPIN).OR.THISTASK.EQ.RTASK) THEN
!           DETECTION OF OCCUPIED STATES THROUGH FERMI ENERGY
            DO IS=1,NSIM
              CALL RIXS$ISELECT(IS)
              IF(THIS%TFERMI) THEN
                S=>THIS%STATEARR(IKPT,ISPIN)
                S%NOCC=-1
                DO IB=1,S%NB
                  IF(S%EIG(IB).GT.THIS%EFERMI) THEN
                    S%NOCC=IB-1
                    EXIT
                  END IF
                ENDDO
                IF(S%NOCC.EQ.-1) THEN
                  IF(THIS%ID.EQ.'EXCITESTATE') THEN
                    CALL ERROR$MSG('NO UNOCCUPIED STATES FOUND FOR EXCITESTATE')
                    CALL ERROR$STOP('RIXS$READ')
                  END IF
                  S%NOCC=S%NB
                END IF
              END IF
              CALL RIXS$UNSELECT
            ENDDO
          END IF
        ENDDO ! END LOOP OVER SPIN
        DEALLOCATE(PSIK1)
        DEALLOCATE(PSIK2)
      ENDDO ! END IKPT LOOP OVER K POINTS
                          CALL TRACE$PASS('READING RIXS FILE DONE, START DATA DISTRIBUTION')
      CALL TRACE$I4VAL(' NB1',SIM(1)%STATEARR(1,1)%NB)
      CALL TRACE$I4VAL(' NB2',SIM(2)%STATEARR(1,1)%NB)
      TSIM=.TRUE.
                          CALL TIMING$CLOCKOFF('RIXS$READ')
                          CALL TRACE$POP
      RETURN

      CONTAINS
        SUBROUTINE TEST!(NSIM,KEY,NGG,NDIM,TSUPER,XK,IGVEC)
        ! INTEGER(4), INTENT(IN) :: NSIM
        ! CHARACTER(8), INTENT(IN) :: KEY(NSIM)
        ! INTEGER(4), INTENT(IN) :: NGG(NSIM)
        ! INTEGER(4), INTENT(IN) :: NDIM(NSIM)
        ! LOGICAL(4), INTENT(IN) :: TSUPER(NSIM)
        ! REAL(8), INTENT(IN) :: XK(NSIM,3)
        ! INTEGER(4), INTENT(IN) :: IGVEC(NSIM,3,NGG(1))
        IF(KEY(1).NE.KEY(2)) THEN
          CALL ERROR$MSG('KEYS NOT THE SAME IN BOTH SIMULATIONS')
          CALL ERROR$I4VAL('IKPT',IKPT)
          CALL ERROR$CHVAL('KEY1',KEY(1))
          CALL ERROR$CHVAL('KEY2',KEY(2))
          CALL ERROR$STOP('RIXS$READ')
        END IF
        IF(NGG(1).NE.NGG(2)) THEN
          CALL ERROR$MSG('NGG NOT THE SAME IN BOTH SIMULATIONS')
          CALL ERROR$I4VAL('IKPT',IKPT)
          CALL ERROR$I4VAL('NGG1',NGG(1))
          CALL ERROR$I4VAL('NGG2',NGG(2))
          CALL ERROR$STOP('RIXS$READ')
        END IF
        IF(NDIM(1).NE.NDIM(2)) THEN
          CALL ERROR$MSG('NDIM NOT THE SAME IN BOTH SIMULATIONS')
          CALL ERROR$I4VAL('IKPT',IKPT)
          CALL ERROR$I4VAL('NDIM1',NDIM(1))
          CALL ERROR$I4VAL('NDIM2',NDIM(2))
          CALL ERROR$STOP('RIXS$READ')
        END IF
! TODO: CHECK NDIM AGAINST PREVIOUSLY READ ONE
        IF(TSUPER(1).NEQV.TSUPER(2)) THEN
          CALL ERROR$MSG('TSUPER NOT THE SAME IN BOTH SIMULATIONS')
          CALL ERROR$I4VAL('IKPT',IKPT)
          CALL ERROR$L4VAL('TSUPER1',TSUPER(1))
          CALL ERROR$L4VAL('TSUPER2',TSUPER(2))
          CALL ERROR$STOP('RIXS$READ')
        END IF
!       CHECK IF XK SAME IN BOTH SIMULATIONS
        IF(SUM(ABS(XK(1,:)-XK(2,:)))>TOL) THEN
          CALL ERROR$MSG('XK NOT THE SAME IN BOTH SIMULATIONS')
          CALL ERROR$I4VAL('IKPT',IKPT)
          CALL ERROR$R8VAL('XK1',XK(1,:))
          CALL ERROR$R8VAL('XK2',XK(2,:))
          CALL ERROR$STOP('RIXS$READ')
        END IF
!       CHECK IF IGVEC SAME IN BOTH SIMULATIONS
        IF(ANY(IGVEC(1,:,:).NE.IGVEC(2,:,:))) THEN
          CALL ERROR$MSG('IGVEC NOT THE SAME IN BOTH SIMULATIONS')
          CALL ERROR$I4VAL('IKPT',IKPT)
          CALL ERROR$STOP('RIXS$READ')
        END IF
        END SUBROUTINE TEST
      END SUBROUTINE RIXS$READ
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS$REPORTSIMULATION  ! MARK: RIXS$REPORTSIMULATION
!     **************************************************************************
!     ** REPORT DATA FOR A SELECTED SIMULATION                                **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: THIS,SELECTED,RTASK
      IMPLICIT NONE
      INTEGER(4) :: NFIL
      INTEGER(4) :: IAT,ISP,ISPIN,IKPT
      CHARACTER(256) :: FORMAT
      REAL(8) :: EV
      INTEGER(4) :: NTASKS,THISTASK
!     **************************************************************************
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      IF(THISTASK.NE.RTASK) RETURN
                          CALL TRACE$PUSH('RIXS$REPORTSIMULATION')
      CALL CONSTANTS('EV',EV)
      CALL FILEHANDLER$UNIT('PROT',NFIL)
      IF(SELECTED) THEN
        WRITE(NFIL,'(80("#"))')
        WRITE(NFIL,FMT='(A14,A14)')'SIMULATION',THIS%ID
        WRITE(NFIL,'(80("#"))')
        WRITE(NFIL,FMT='(A10,A)')'FILE:',TRIM(THIS%FILE)
        WRITE(NFIL,FMT='(A10,I10)')'NAT:',THIS%NAT
        WRITE(NFIL,FMT='(A10,I10)')'NSP:',THIS%NSP
        WRITE(NFIL,FMT='(A10,I10)')'NKPT:',THIS%NKPT
        WRITE(NFIL,FMT='(A10,I10)')'NSPIN:',THIS%NSPIN
        WRITE(NFIL,FMT='(A10,I10)')'NDIM:',THIS%NDIM
        WRITE(NFIL,FMT='(A10,I10)')'NPRO:',THIS%NPRO
        WRITE(NFIL,FMT='(A10,I10)')'LNXX:',THIS%LNXX
        WRITE(NFIL,FMT='(A10,L10)')'TINV:',THIS%TINV
        WRITE(NFIL,FMT='(A10,3I10)')'NKDIV:',THIS%NKDIV(:)
        WRITE(NFIL,FMT='(A10,3I10)')'ISHIFT:',THIS%ISHIFT(:)
        WRITE(NFIL,FMT='(A10,F10.4)')'RNTOT:',THIS%RNTOT
        WRITE(NFIL,FMT='(A10,F10.4)')'NEL:',THIS%NEL
        IF(THIS%TFERMI) THEN
          WRITE(NFIL,FMT='(A10,F10.4)')'EFERMI:',THIS%EFERMI/EV
        END IF
        WRITE(NFIL,FMT='(A10,F20.8)')'ETOT [EV]:',THIS%ETOT/EV
        WRITE(NFIL,FMT='(A10,F20.8)')'EDFT [EV]:',THIS%EDFT/EV
        WRITE(NFIL,FMT='(A10,F20.8)')'ECORE [EV]:',THIS%ECORE/EV
        WRITE(NFIL,FMT='(A10,I10)')'SPACEGR.:',THIS%SPACEGROUP
        WRITE(NFIL,FMT='(A10,L10)')'TSHIFT:',THIS%TSHIFT
        WRITE(NFIL,FMT='(A10,3F10.4)')'RBAS:',THIS%RBAS(:,1)
        DO IAT=2,3
          WRITE(NFIL,FMT='(A10,3F10.4)')' ',THIS%RBAS(:,IAT)
        ENDDO
        WRITE(NFIL,FMT='(5A10)')'ATOM','X','Y','Z','SPECIES'
        DO IAT=1,THIS%NAT
          WRITE(NFIL,FMT='(A10,3F10.4,I10)')THIS%ATOMID(IAT),THIS%R(:,IAT),THIS%ISPECIES(IAT)
        ENDDO
        WRITE(NFIL,FMT='(5A10)')'SETUP','GID','ECORE[H]','LNX','LOX'
        IF(THIS%LNXX.GT.9) THEN
          WRITE(FORMAT,'("(2I10,F10.4,I10,",I2,"I10)")')THIS%LNXX
        ELSE
          WRITE(FORMAT,'("(2I10,F10.4,I10,",I1,"I10)")')THIS%LNXX
        END IF
        DO ISP=1,THIS%NSP
          WRITE(NFIL,FMT=FORMAT)ISP,THIS%SETUP(ISP)%GID,THIS%SETUP(ISP)%ECORE, &
     &                          THIS%LNX(ISP),THIS%LOX(:,ISP)
        ENDDO
        WRITE(NFIL,FMT='(A)')'MAPPING OF PROJECTIONS (INDEX-1)'
        WRITE(NFIL,FMT='(A10,A10)')'ATOM','MAP'
        IF(THIS%LNXX.GT.9) THEN
          WRITE(FORMAT,'("(I10,",I2,"I10)")')THIS%LNXX
        ELSE
          WRITE(FORMAT,'("(I10,",I1,"I10)")')THIS%LNXX
        END IF
        DO IAT=1,THIS%NAT
          WRITE(NFIL,FMT=FORMAT)IAT,THIS%MAP(IAT,:)
        ENDDO
        WRITE(NFIL,FMT='(A)')'RADIAL REPORT'
        CALL RADIAL$REPORT(NFIL)
        WRITE(NFIL,FMT='(8A10)')'IKPT','ISPIN','XK1','XK2','XK3', &
&                               'WKPT','NB','NOCC'
        DO IKPT=1,THIS%NKPT
          DO ISPIN=1,THIS%NSPIN
            THIS%STATE=>THIS%STATEARR(IKPT,ISPIN)
            WRITE(NFIL,FMT='(2I10,4F10.6,2I10)')IKPT,ISPIN,THIS%XK(:,IKPT), &
&                                  THIS%WKPT(IKPT),THIS%STATE%NB,THIS%STATE%NOCC
          ENDDO
        ENDDO
      ELSE
        WRITE(*,*) 'NO OUTPUT FOR GENERAL INFORMATION IMPLEMENTED'
      END IF
                          CALL TRACE$POP
      END SUBROUTINE RIXS$REPORTSIMULATION
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS$REPORTSETTINGS  ! MARK: RIXS$REPORTSETTINGS
!     **************************************************************************
!     ** REPORT SETTINGS FOR RIXS CALCULATION                                  **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: SETTINGS,SPEC,SPECARR,OUTPUT,TRSTRT
      USE STRINGS_MODULE
      IMPLICIT NONE
      INTEGER(4) :: NFIL
      INTEGER(4) :: ISPEC
      REAL(8) :: EV
      INTEGER(4) :: NTASKS,THISTASK
!     **************************************************************************
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      IF(THISTASK.NE.1) RETURN
                          CALL TRACE$PUSH('RIXS$REPORTSETTINGS')
      CALL CONSTANTS('EV',EV)
      CALL FILEHANDLER$UNIT('PROT',NFIL)
      WRITE(NFIL,'(80("#"))')
      WRITE(NFIL,FMT='(A19)')'SETTINGS'
      WRITE(NFIL,'(80("#"))')
      WRITE(NFIL,FMT='(A10,I10)')'NSPECTRA:',SETTINGS%NSPEC
!     DATA NOT AVAILABLE FROM RESTART FILE
      IF(.NOT.TRSTRT) THEN
        WRITE(NFIL,FMT='(A10,A)')'HOLE ATOM:',TRIM(SETTINGS%ATOM)
        WRITE(NFIL,FMT='(A10,I10)')'IND1 ATOM:',SETTINGS%IATOM
        WRITE(NFIL,FMT='(A10,I10)')'NCORE:',SETTINGS%NCORE
        WRITE(NFIL,FMT='(A10,I10)')'LCORE:',SETTINGS%LCORE
      END IF
      WRITE(NFIL,FMT='(A10,F10.6)')'DE:',SETTINGS%DE/EV
      WRITE(NFIL,FMT='(A10,F20.10)')'EMIN:',SETTINGS%EMIN/EV
      WRITE(NFIL,FMT='(A10,F20.10)')'EMAX:',SETTINGS%EMAX/EV
      WRITE(NFIL,FMT='(A10,F10.6)')'EBROAD:',SETTINGS%EBROAD/EV
      IF(SETTINGS%TOMEGA) THEN
        WRITE(NFIL,FMT='(A10,F20.8)')'OMEGA:',SETTINGS%OMEGA/EV
      END IF
      WRITE(NFIL,FMT='(A10,F10.6)')'GAMMA:',SETTINGS%GAMMA/EV
      DO ISPEC=1,SETTINGS%NSPEC
        SPEC=>SPECARR(ISPEC)
        WRITE(NFIL,'(80("#"))')
        WRITE(NFIL,FMT='(A10,I10)')'SPECTRUM:',ISPEC
        WRITE(NFIL,FMT='(A10,A)')'FILE:',TRIM(ADJUSTL(SPEC%FILE))
        WRITE(NFIL,FMT='(A10,F10.6)')'OMEGA:',SPEC%OMEGA/EV
        WRITE(NFIL,FMT='(A10,F10.6)')'GAMMA:',SPEC%GAMMA/EV
        WRITE(NFIL,FMT='(A10,L10)')'ELASTIC:',SPEC%TELASTIC
        WRITE(NFIL,FMT='(A10,F10.6)')'EBROAD:',SPEC%EBROAD/EV
        WRITE(NFIL,FMT='(A10,A10)')'BROADMODE:',SPEC%BROADMODE
        IF(.NOT.SPEC%TPOLXYZI) THEN
          WRITE(NFIL,FMT='(A10,3F10.4)')'NORMALI:',SPEC%NORMALI(:)
          WRITE(NFIL,FMT='(A10,3F10.4)')'KDIRI:',SPEC%KDIRI(:)
          WRITE(NFIL,FMT=-'(A10,2(F8.5,SP,F8.5,"I ",S))')'POLI:',SPEC%POLI(:)
        END IF
        WRITE(NFIL,FMT=-'(A10,3(F8.5,SP,F8.5,"I ",S))')'POLXYZI:',SPEC%POLXYZI(:)
        IF(.NOT.SPEC%TPOLXYZO) THEN
          WRITE(NFIL,FMT='(A10,3F10.4)')'NORMALI:',SPEC%NORMALO(:)
          WRITE(NFIL,FMT='(A10,3F10.4)')'KDIRI:',SPEC%KDIRO(:)
          WRITE(NFIL,FMT=-'(A10,2(F8.5,SP,F8.5,"I ",S))')'POLI:',SPEC%POLO(:)
        END IF
        WRITE(NFIL,FMT=-'(A10,3(F8.5,SP,F8.5,"I ",S))')'POLXYZI:',SPEC%POLXYZO(:)
      ENDDO
      WRITE(NFIL,'(80("#"))')
      WRITE(NFIL,FMT='(A19)')'OUTPUT'
      WRITE(NFIL,'(80("#"))')
      ! WRITE(NFIL,FMT='(A10,L10)')'OVL:',OUTPUT%TOVL
      ! WRITE(NFIL,FMT='(A10,L10)')'OVLPW:',OUTPUT%TOVLPW
      ! WRITE(NFIL,FMT='(A10,L10)')'OVLAUG:',OUTPUT%TOVLAUG
      ! WRITE(NFIL,FMT='(A10,L10)')'AMAT:',OUTPUT%TAMAT
      ! WRITE(NFIL,FMT='(A10,L10)')'BMAT:',OUTPUT%TBMAT
      ! WRITE(NFIL,FMT='(A10,L10)')'CMAT:',OUTPUT%TCMAT
      ! WRITE(NFIL,FMT='(A10,L10)')'DMAT:',OUTPUT%TDMAT
      ! WRITE(NFIL,FMT='(A10,L10)')'KMAT:',OUTPUT%TKMAT
      ! WRITE(NFIL,FMT='(A10,L10)')'DIPOLE:',OUTPUT%TDIPOLE
      WRITE(NFIL,FMT='(A10,L10)')'ADET:',OUTPUT%TADET
                          CALL TRACE$POP
      END SUBROUTINE RIXS$REPORTSETTINGS
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS$AMPL(NB,NOCC,IEMP,LINMAT,DIPOLE,ADET,AMPL)  ! MARK: RIXS$AMPL
!     **************************************************************************
!     ** CALCULATE TRANSITION AMPLITUDE FOR A GIVEN INTERMEDIATE              **
!     **    STATE (IKPT,ISPIN,K) WITH A GIVEN LINEAR DEPENDENCY MATRIX        **
!     ** THREE COMPONENTS ARE FOR THE THREE CARTESIAN DIRECTIONS              **
!     **************************************************************************
      IMPLICIT NONE
!     REDUCE CALCULATION TO SINGLE PARTICLE SPECTRUM
      LOGICAL(4), PARAMETER :: SINGLEPARTICLE=.FALSE.
      INTEGER(4), INTENT(IN) :: NB ! NUMBER OF BANDS
      INTEGER(4), INTENT(IN) :: NOCC ! NUMBER OF OCCUPIED STATES
      INTEGER(4), INTENT(IN) :: IEMP ! FINAL STATE ORBITAL INDEX WITHIN UNOCCUPIED
      COMPLEX(8), INTENT(IN) :: LINMAT(NB-NOCC,NOCC) ! LINEAR DEPENDENCE MATRIX
      COMPLEX(8), INTENT(IN) :: DIPOLE(3,NB) ! DIPOLE MATRIX
      COMPLEX(8), INTENT(IN) :: ADET ! DETERMINANT OF OCCUPIED OVERLAP MATRIX
      COMPLEX(8), INTENT(OUT) :: AMPL(3) ! TRANSITION AMPLITUDE
      INTEGER(4) :: IFINAL ! INDEX FOR FINAL STATE WITHIN ALL STATES
      INTEGER(4) :: IB
!     **************************************************************************
      IFINAL=IEMP+NOCC
!     CHECK IF FINAL STATE ORBITAL INDEX IS VALID
      IF(IFINAL.GT.NB) THEN
        CALL ERROR$MSG('FINAL STATE ORBITAL INDEX OUT OF BOUNDS')
        CALL ERROR$I4VAL('IEMP',IEMP)
        CALL ERROR$I4VAL('NB',NB)
        CALL ERROR$STOP('RIXS$AMPL')
      END IF
      IF(IFINAL.LE.NOCC) THEN
        CALL ERROR$MSG('FINAL STATE ORBITAL INDEX OCCUPIED')
        CALL ERROR$I4VAL('IEMP',IEMP)
        CALL ERROR$I4VAL('NOCC',NOCC)
        CALL ERROR$STOP('RIXS$AMPL')
      END IF
      AMPL=(0.D0,0.D0)
! WARNING: CHECK INDICES
      DO IB=1,NOCC
        AMPL(:)=AMPL(:)+CONJG(LINMAT(IEMP,IB))*DIPOLE(:,IB)
      ENDDO
      AMPL(:)=DIPOLE(:,IFINAL)-AMPL(:)
      AMPL(:)=(-1.D0)**NOCC*AMPL(:)*CONJG(ADET)
      IF(SINGLEPARTICLE) AMPL(:)=DIPOLE(:,IFINAL)
      RETURN
      END SUBROUTINE RIXS$AMPL
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS$FINALSTATELOOP  ! MARK: RIXS$FINALSTATELOOP
!     **************************************************************************
!     ** LOOP OVER FINAL STATES TO CALCULATE RIXS SPECTRUM                    **
!     **************************************************************************
! WARNING: ASSUMPTION THAT FINAL STATE IS A SINGLE SLATER DETERMINANT
!     FINAL STATE DEFINED BY (IOCC,IEMP)
!       IOCC: OCCUPIED STATE INDEX THAT IS UNOCCUPIED IN FINAL STATE
!       IEMP: UNOCCUPIED STATE INDEX THAT IS OCCUPIED IN FINAL STATE
      USE RIXS_MODULE, ONLY: SIM,NKPTG,NSPING,KSMAP,STATE_TYPE,SETTINGS, &
     &                       OVL,OVLARR,SPEC,SPECARR
      USE MPE_MODULE
      IMPLICIT NONE
      INTEGER(4) :: IOCC
      INTEGER(4) :: IEMP
      INTEGER(4) :: IEMPTOT
      INTEGER(4) :: IKPT
      INTEGER(4) :: ISPIN
      INTEGER(4) :: IK
      INTEGER(4) :: I
      TYPE(STATE_TYPE), POINTER :: S1,S2
      INTEGER(4) :: NOCC1,NOCC2
      INTEGER(4) :: NB1,NB2
      REAL(8) :: ELOSS ! EFINAL-EGROUND
      COMPLEX(8), ALLOCATABLE :: LMAT(:,:) ! (NB2-NOCC,NOCC)
      COMPLEX(8) :: AMPL(3)
      COMPLEX(8), ALLOCATABLE :: TAMPL(:) ! (NSPEC) RIXS AMPLITUDE
      INTEGER(4) :: ISPEC
      INTEGER(4) :: NTASKS,THISTASK
      COMPLEX(8) :: CVAR
      REAL(8) :: SVAR
!     **************************************************************************
                          CALL TRACE$PUSH('RIXS$FINALSTATELOOP')
                          CALL TIMING$CLOCKON('RIXS$FINALSTATELOOP')
      CALL MPE$QUERY('~',NTASKS,THISTASK)
!     ALLOCATE STORAGE FOR SUMMING UP RIXS AMPLITUDE FOR (IKPT,ISPIN,IOCC,IEMP)
      ALLOCATE(TAMPL(SETTINGS%NSPEC))
      DO ISPEC=1,SETTINGS%NSPEC
        SPEC=>SPECARR(ISPEC)
        IF (.NOT.ALLOCATED(SPEC%RIXS)) THEN
          ALLOCATE(SPEC%RIXS(SETTINGS%NE,NKPTG,NSPING))
        END IF
        SPEC%RIXS(:,:,:)=0.D0
        IF (.NOT.ALLOCATED(SPEC%E)) THEN
          ALLOCATE(SPEC%E(SETTINGS%NE))
          DO I=1,SETTINGS%NE
            SPEC%E(I)=SETTINGS%EMIN+REAL(I-1,8)*SETTINGS%DE
          ENDDO
        END IF
      ENDDO
!     INITIALIZE CLOCK FOR LMAT, RTASK MIGHT NEVER CALL IT, TIMING WOULD BE LOST
      CALL TIMING$CLOCKON('RIXS$LMAT')
      CALL TIMING$CLOCKOFF('RIXS$LMAT')
!     LOOP OVER K POINTS
      DO IKPT=1,NKPTG
!       LOOP OVER SPIN
        DO ISPIN=1,NSPING
          IF(KSMAP(IKPT,ISPIN).NE.THISTASK) CYCLE
          CALL TRACE$I4VAL(' FINALSTATELOOP IKPT:',IKPT)
          CALL TRACE$I4VAL(' FINALSTATELOOP ISPIN:',ISPIN)
          OVL=>OVLARR(IKPT,ISPIN)
          S1=>SIM(1)%STATEARR(IKPT,ISPIN)
          NB1=S1%NB
          NOCC1=S1%NOCC
          S2=>SIM(2)%STATEARR(IKPT,ISPIN)
          NB2=S2%NB
          NOCC2=S2%NOCC
!         == ELASTIC PEAK ======================================================
          TAMPL=(0.D0,0.D0)
          DO IK=1,NB2-NOCC2
!           EMISSION AMPLITUDE
            CALL RIXS$AMPL(NB2,NOCC2,IK,OVL%KMAT,OVL%DIPOLE,OVL%ADET,AMPL)
            DO ISPEC=1,SETTINGS%NSPEC
              SPEC=>SPECARR(ISPEC)
              IF(.NOT.SPEC%TELASTIC) CYCLE
              CVAR=CONJG(OVL%ADET)*OVL%ADET
              CVAR=CVAR*DOT_PRODUCT(SPEC%POLXYZI,OVL%ABSORP(:,IK))
              CVAR=CVAR*CONJG(DOT_PRODUCT(SPEC%POLXYZO,AMPL))
              CVAR=CVAR*OVL%LORENTZ(ISPEC,IK)
              TAMPL(ISPEC)=TAMPL(ISPEC)+CVAR
            ENDDO
          ENDDO
          ELOSS=0.D0
          DO ISPEC=1,SETTINGS%NSPEC
            SPEC=>SPECARR(ISPEC)
            IF(.NOT.SPEC%TELASTIC) CYCLE
            SVAR=REAL(CONJG(TAMPL(ISPEC))*TAMPL(ISPEC),KIND=8)
            CALL MAPGRID(ELOSS,SVAR,SETTINGS%NE,SPEC%RIXS(:,IKPT,ISPIN), &
      &                     SETTINGS%EMIN,SETTINGS%DE)
          ENDDO
!
!         ALLOCATE STORAGE FOR LINEAR DEPENDENCE MATRIX LMAT
          ALLOCATE(LMAT(NB2-NOCC2,NOCC1))
!         LOOP OVER FINAL STATES (IOCC,IEMP)
          DO IOCC=1,NOCC1
            CALL TRACE$I4VAL(' FINAL STATE IOCC',IOCC)
            DO IEMP=1,NB1-NOCC1
              IEMPTOT=IEMP+NOCC1
!             CALCULATE ENERGY LOSS
!             LOSS=EFINAL-EGROUND=(EGROUND+EIG(IEMPTOT)-EIG(IOCC))-EGROUND
              ELOSS=S1%EIG(IEMPTOT)-S1%EIG(IOCC)
!             SKIP CALCULATION OF FINAL STATE OUTSIDE SET ENERGY RANGE
              IF(ELOSS.GT.SETTINGS%EMAX.OR.ELOSS.LT.SETTINGS%EMIN) CYCLE
!             RESET AMPLITUDE FOR NEW FINAL STATE
              TAMPL=(0.D0,0.D0)
!             CALCULATE LINEAR DEPENDENCE MATRIX
              CALL RIXS$LMAT(IOCC,IEMP,NB1,NB2,NOCC1,OVL%AMAT,OVL%AINV, &
     &                       OVL%BMAT,OVL%CMAT,OVL%DMAT,LMAT)
              DO IK=1,NB2-NOCC2
!               CALCULATE TRANSITION AMPLITUDE
                CALL RIXS$AMPL(NB2,NOCC2,IK,LMAT,OVL%DIPOLE,OVL%ADET,AMPL)
!               SUM UP AMPLITUDE FOR ALL SPECTRA
                DO ISPEC=1,SETTINGS%NSPEC
                  SPEC=>SPECARR(ISPEC)
                  CVAR=CONJG(OVL%ADET)*OVL%ADET
                  CVAR=CVAR*DOT_PRODUCT(SPEC%POLXYZI,OVL%ABSORP(:,IK))
                  CVAR=CVAR*CONJG(DOT_PRODUCT(SPEC%POLXYZO,AMPL))
                  CVAR=CVAR*OVL%LORENTZ(ISPEC,IK)
                  TAMPL(ISPEC)=TAMPL(ISPEC)+CVAR
                ENDDO
              ENDDO ! IK
              TAMPL=TAMPL*OVL%HMAT(IEMP,IOCC)
              DO ISPEC=1,SETTINGS%NSPEC
                SPEC=>SPECARR(ISPEC)
                SVAR=REAL(CONJG(TAMPL(ISPEC))*TAMPL(ISPEC),KIND=8)
                CALL MAPGRID(ELOSS,SVAR,SETTINGS%NE,SPEC%RIXS(:,IKPT,ISPIN), &
     &                       SETTINGS%EMIN,SETTINGS%DE)
              ENDDO ! ISPEC
            ENDDO ! IEMP
          ENDDO ! IOCC
          DEALLOCATE(LMAT)
        ENDDO ! NSPIN
      ENDDO ! IKPT
      DEALLOCATE(TAMPL)

                          CALL TIMING$CLOCKOFF('RIXS$FINALSTATELOOP')
                          CALL TIMING$CLOCKON('RIXS$FINALSTATELOOP COMBINE')
!     COMBINE ALL SPECTRA INFORMATION FROM ALL K POINTS TO SYNC ARRAYS
      DO ISPEC=1,SETTINGS%NSPEC
        SPEC=>SPECARR(ISPEC)
        CALL TRACE$PASS('COMBINING RIXS SPECTRA')
        CALL MPE$COMBINE('~','+',SPEC%RIXS)
        CALL TRACE$R8VAL(' MAXVAL',MAXVAL(SPEC%RIXS(:,:,:)))
        IF(SPEC%BROADMODE.EQ.'N') CYCLE
        DO IKPT=1,NKPTG
          DO ISPIN=1,NSPING
            IF(SPEC%BROADMODE.EQ.'G') THEN
              CALL GAUSSCONV(SETTINGS%NE,SPEC%E,SPEC%RIXS(:,IKPT,ISPIN),SPEC%EBROAD)
            ELSE IF(SPEC%BROADMODE.EQ.'L') THEN
              CALL LORENTZCONV(SETTINGS%NE,SPEC%E,SPEC%RIXS(:,IKPT,ISPIN),SPEC%EBROAD)
            ELSE
              CALL ERROR$MSG('UNKNOWN BROADENING MODE')
              CALL ERROR$MSG('SHOULD HAVE BEEN CAUGHT BEFORE')
              CALL ERROR$STOP('RIXS$FINALSTATELOOP')
            END IF
!           BROADENING CAN CAUSE VERY SMALL VALUES, SET TO ZERO
            WHERE(ABS(SPEC%RIXS(:,IKPT,ISPIN)).LT.1.D-50) SPEC%RIXS(:,IKPT,ISPIN)=0.D0
          ENDDO
        ENDDO
      ENDDO
                          CALL TIMING$CLOCKOFF('RIXS$FINALSTATELOOP COMBINE')
                          CALL TRACE$POP
      END SUBROUTINE RIXS$FINALSTATELOOP

!
!     ...1.........2.........3.........4.........5.........6.........7.........8
!       SUBROUTINE RIXS$CROSSSECTION  ! MARK: RIXS$CROSSSECTION
! !     **************************************************************************
! !     ** CALCULATE RIXS CROSS SECTION                                          **
! !     **************************************************************************
!       USE RIXS_MODULE, ONLY: SPEC,SPECARR,SETTINGS,SIM,STATE_TYPE, &
! &                           KMAP,NKPTG,NSPING,RTASK,OVL,OVLARR
!       USE MPE_MODULE
!       IMPLICIT NONE
!       INTEGER(4) :: ISPEC
!       INTEGER(4) :: IKPT
!       INTEGER(4) :: ISPIN
!       INTEGER(4) :: IFINAL
!       TYPE(STATE_TYPE), POINTER :: S
!       COMPLEX(8) :: AMPL(3)
!       COMPLEX(8) :: CVAR
!       INTEGER(4) :: NB,NOCC
!       REAL(8) :: SIGMA
!       REAL(8) :: EGROUND,EEXCITE  ! TOTAL ENERGY OF CALCULATION
!       REAL(8) :: EF
!       REAL(8) :: EV
!       REAL(8) :: EMIN,EMAX
!       REAL(8) :: E
!       INTEGER(4) :: NE
!       INTEGER(4) :: I
!       INTEGER(4) :: NTASKS,THISTASK
! !     **************************************************************************
!                           CALL TRACE$PUSH('RIXS$CROSSSECTION')
!                           CALL TIMING$CLOCKON('RIXS$CROSSSECTION')
!       CALL MPE$QUERY('~',NTASKS,THISTASK)
!       EMIN=HUGE(EMIN)
!       EMAX=-HUGE(EMAX)
!       CALL CONSTANTS('EV',EV)
!       EGROUND=SIM(1)%ETOT
!       EEXCITE=SIM(2)%ETOT
! !     AUTOMATICALLY FIND ENERGY RANGE (ONLY RTASK HAS ALL ENERGIES)
!       IF(THISTASK.EQ.RTASK) THEN
!         DO IKPT=1,NKPTG
!           DO ISPIN=1,NSPING
!             S=>SIM(2)%STATEARR(IKPT,ISPIN)
!             DO IFINAL=1,S%NB-S%NOCC
!               EF=EEXCITE+S%EIG(IFINAL+S%NOCC)
!               E=EF-EGROUND!+DEATOM
!               IF(E.LT.EMIN) EMIN=E
!               IF(E.GT.EMAX) EMAX=E
!             ENDDO
!           ENDDO
!         ENDDO
!         S=>SIM(2)%STATEARR(1,1)
!         NB=S%NB
!         NOCC=S%NOCC
!       END IF
!       CALL MPE$BROADCAST('~',RTASK,EMIN)
!       CALL MPE$BROADCAST('~',RTASK,EMAX)
!       CALL MPE$BROADCAST('~',RTASK,NB)
!       CALL MPE$BROADCAST('~',RTASK,NOCC)
! !     WARNING: ENERGY RANGE EXTENDED BY 2 EV
!       EMIN=EMIN-2.D0*EV
!       EMAX=EMAX+2.D0*EV
!       NE=INT((EMAX-EMIN)/SETTINGS%DE)+1
!       SETTINGS%EMIN=EMIN
!       SETTINGS%EMAX=EMAX
!       SETTINGS%NE=NE

!       DO ISPEC=1,SETTINGS%NSPEC
!         SPEC=>SPECARR(ISPEC)
!         ALLOCATE(SPEC%E(NE))
!         ALLOCATE(SPEC%I(NKPTG,NSPING,NE))
!         SPEC%I(:,:,:)=0.D0
! ! ERROR: ALLOCATION OF SPECTRUM%ERAW AND SPECTRUM%IRAW CAN BE WRONG IF NB OR 
! !        NOCC ARE NOT THE SAME FOR ALL K POINTS
!         ALLOCATE(SPEC%ERAW(NKPTG,NSPING,NB-NOCC))
!         SPEC%ERAW(:,:,:)=0.D0
!         ALLOCATE(SPEC%IRAW(NKPTG,NSPING,NB-NOCC))
!         SPEC%IRAW(:,:,:)=0.D0
!         SPEC%I(:,:,:)=0.D0
!         DO I=1,NE
!           SPEC%E(I)=EMIN+REAL(I-1,KIND=8)*SETTINGS%DE
!         ENDDO
!       ENDDO

! ! TODO: CLEANUP
!       CALL TRACE$PASS('RIXS$CROSSSECTION LOOP')
! !     LOOP OVER K POINTS
!       DO IKPT=1,NKPTG
!         IF(KMAP(IKPT).NE.THISTASK) CYCLE
!         CALL TRACE$I4VAL(' IKPT',IKPT)
! !       LOOP OVER SPIN
!         DO ISPIN=1,NSPING
!           S=>SIM(2)%STATEARR(IKPT,ISPIN)
!           OVL=>OVLARR(IKPT,ISPIN)
!           DO IFINAL=1,S%NB-S%NOCC
! ! TODO: CHECK IMPLEMENTATION WEIGHT OF K POINT AND ROLE OF INVERSION SYMMETRY
!             CALL RIXS$AMPL(S%NB,S%NOCC,IFINAL,OVL%KMAT,OVL%DIPOLE,OVL%ADET,AMPL)
!             EF=EEXCITE+S%EIG(IFINAL+S%NOCC)
!             E=EF-EGROUND!+DEATOM
! !           LOOP OVER SPECTRA
!             DO ISPEC=1,SETTINGS%NSPEC
!               SPEC=>SPECARR(ISPEC)
!               CVAR=DOT_PRODUCT(SPEC%POLXYZ,AMPL)
! !             ABSOLUTE SQUARE AND WEIGHT OF K POINT
!               SIGMA=SIM(1)%WKPT(IKPT)*REAL(CONJG(CVAR)*CVAR,KIND=8)
!               SPEC%ERAW(IKPT,ISPIN,IFINAL)=E
!               SPEC%IRAW(IKPT,ISPIN,IFINAL)=SIGMA
!               CALL RIXS$MAPGRID(E,SIGMA,NE,SPEC%I(IKPT,ISPIN,:), &
!      &                         EMIN,SETTINGS%DE)
!             ENDDO
!           ENDDO
!         ENDDO
!       ENDDO
      
!       DO ISPEC=1,SETTINGS%NSPEC
!         SPEC=>SPECARR(ISPEC)
!         CALL MPE$COMBINE('~','+',SPEC%I)
!         CALL MPE$COMBINE('~','+',SPEC%ERAW)
!         CALL MPE$COMBINE('~','+',SPEC%IRAW)
!         DO IKPT=1,NKPTG
!           DO ISPIN=1,NSPING
!             ! CALL LORENTZCONV(NE,SPECTRUM%E,SPECTRUM%I(IKPT,ISPIN,:),SETTINGS%GAMMA)
!             CALL GAUSSCONV(NE,SPEC%E,SPEC%I(IKPT,ISPIN,:),SETTINGS%GAMMA)
!           ENDDO
!         ENDDO
!       ENDDO
!                           CALL TIMING$CLOCKOFF('RIXS$CROSSSECTION')
!                           CALL TRACE$POP
!       RETURN
!       END SUBROUTINE RIXS$CROSSSECTION
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS$OVERLAP  ! MARK: RIXS$OVERLAP
!     **************************************************************************
!     ** CALCULATE OVERLAP MATRIX                                             **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: S,OVL,OVLARR,SIM,STATE_TYPE,TOVERLAP,TRSTRT, &
&                           KSMAP,NKPTG,NSPING
      IMPLICIT NONE
      LOGICAL(4), PARAMETER :: TTEST=.TRUE. ! TEST EIGENVALUES OF OVERLAP
      TYPE(STATE_TYPE), POINTER :: S1,S2
      INTEGER(4) :: IKPT,ISPIN
      INTEGER(4) :: NOCC
      INTEGER(4) :: NTASKS,THISTASK
      INTEGER(4) :: MINOCC,MAXOCC
      INTEGER(4) :: IB
      CHARACTER(1024) :: ERRORMSG
      REAL(8) :: EV
!     **************************************************************************
                          CALL TRACE$PUSH('RIXS$OVERLAP')
                          CALL TIMING$CLOCKON('RIXS$OVERLAP')
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      CALL CONSTANTS('EV',EV)
!     CALCULATION UF AUGMENTATION MATRIX NOT NECESSARY WITH RESTART FILE
      IF(.NOT.TRSTRT) THEN
        IF(ALLOCATED(S)) THEN
          CALL ERROR$MSG('ATOMIC OVERLAP MATRIX ALREADY CALCULATED')
          CALL ERROR$STOP('RIXS$OVERLAP')
        END IF
        IF(.NOT.ALLOCATED(OVLARR)) THEN
          CALL ERROR$MSG('PLANE WAVE OVERLAP MATRIX NOT AVAILABLE')
          CALL ERROR$MSG('SHOULD BE CALCULATED ON READ')
          CALL ERROR$MSG('USE RIXS$READ TO READ DATA')
          CALL ERROR$STOP('RIXS$OVERLAP')
        END IF
        CALL RIXS$OVERLAPATOMMATRIX

        CALL RIXS$OVERLAPAUGMENTATION
      END IF

      DO IKPT=1,NKPTG
        DO ISPIN=1,NSPING
          IF(KSMAP(IKPT,ISPIN).NE.THISTASK) CYCLE
          OVL=>OVLARR(IKPT,ISPIN)
          S1=>SIM(1)%STATEARR(IKPT,ISPIN)
          S2=>SIM(2)%STATEARR(IKPT,ISPIN)
          ALLOCATE(OVL%OV(S2%NB,S1%NB))
          OVL%OV(:,:)=OVL%PW(:,:)+OVL%AUG(:,:)
!         CHECK OF NUMBER OF OCCUPIED STATES IS THE SAME TO PRODUCE SQUARE MATRIX
          IF(S1%NOCC.NE.S2%NOCC) THEN
            WRITE(ERRORMSG,FMT='(A,I4,A,I2)') &
     &        'WARNING: NUMBER OCCUPIED STATES NOT EQUAL ON IKPT=',IKPT,&
     &        ' ISPIN=',ISPIN
            CALL TRACE$PASS(TRIM(ERRORMSG))
            WRITE(ERRORMSG,FMT='(A5,A8,A8)')' ','GROUND','EXCITED'
            CALL TRACE$PASS(TRIM(ERRORMSG))
            WRITE(ERRORMSG,FMT='(A5,I8,I8)')'NOCC',S1%NOCC,S2%NOCC
            CALL TRACE$PASS(TRIM(ERRORMSG))
            MINOCC=MIN(S1%NOCC,S2%NOCC)
            MAXOCC=MAX(S1%NOCC,S2%NOCC)
            DO IB=MINOCC,MAXOCC
              WRITE(ERRORMSG,FMT='(A1,I4,F8.3,F8.3)') &
     &          'E',IB,S1%EIG(IB)/EV,S2%EIG(IB)/EV
              CALL TRACE$PASS(TRIM(ERRORMSG))
            ENDDO
            WRITE(ERRORMSG,FMT='(A)')'SETTING EXCITED NOCC TO GROUND NOCC'
            CALL TRACE$PASS(TRIM(ERRORMSG))
            S2%NOCC=S1%NOCC
          END IF
          NOCC=S1%NOCC
! TODO: BE MORE EFFICIENT WITH MEMORY USAGE
!       OVL%PW, OVL%AUG, OVL%OV NOT REALLY NEEDED ANYMORE BESIDES OUTPUT
!       OVL%OV CAN BE CONSTRUCTED FROM OVL%AMAT, OVL%BMAT, OVL%CMAT, OVL%DMAT
          ALLOCATE(OVL%AMAT(NOCC,NOCC))
          ALLOCATE(OVL%BMAT(NOCC,S1%NB-NOCC))
          ALLOCATE(OVL%CMAT(S2%NB-NOCC,NOCC))
          ALLOCATE(OVL%DMAT(S2%NB-NOCC,S1%NB-NOCC))
          OVL%AMAT(:,:)=OVL%OV(1:NOCC,1:NOCC)
          OVL%BMAT(:,:)=OVL%OV(1:NOCC,NOCC+1:S1%NB)
          OVL%CMAT(:,:)=OVL%OV(NOCC+1:S2%NB,1:NOCC)
          OVL%DMAT(:,:)=OVL%OV(NOCC+1:S2%NB,NOCC+1:S1%NB)
        ENDDO
      ENDDO  
      TOVERLAP=.TRUE.  
                          CALL TIMING$CLOCKOFF('RIXS$OVERLAP')
                          CALL TRACE$POP
      END SUBROUTINE RIXS$OVERLAP
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS$OVERLAPAUGMENTATION  ! MARK: RIXS$OVERLAPAUGMENTATION
!     **************************************************************************
!     ** OVERLAP CONTRIBUTION FROM PAW AUGMENTATION                           **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: OVL,OVLARR,SIM,STATE_TYPE,NKPTG,NSPING,KSMAP
      USE MPE_MODULE
      IMPLICIT NONE
      TYPE(STATE_TYPE), POINTER :: S1,S2
      INTEGER(4) :: IKPT,ISPIN
      INTEGER(4) :: IB1,IB2
      COMPLEX(8) :: CVAR
      INTEGER(4) :: NTASKS,THISTASK
!     **************************************************************************
                          CALL TRACE$PUSH('RIXS$OVERLAPAUGMENTATION')
                          CALL TIMING$CLOCKON('RIXS$OVERLAPAUGMENTATION')
      CALL MPE$QUERY('~',NTASKS,THISTASK)
  !   LOOP OVER K POINTS
      DO IKPT=1,NKPTG
  !     LOOP OVER SPIN
        DO ISPIN=1,NSPING
          IF(KSMAP(IKPT,ISPIN).NE.THISTASK) CYCLE
          S1=>SIM(1)%STATEARR(IKPT,ISPIN)
          S2=>SIM(2)%STATEARR(IKPT,ISPIN)
          OVL=>OVLARR(IKPT,ISPIN)
          ALLOCATE(OVL%AUG(S2%NB,S1%NB))
          OVL%AUG(:,:)=(0.D0,0.D0)
  !       LOOP OVER BANDS OF FIRST SIMULATION
          DO IB2=1,S2%NB
  !         LOOP OVER BANDS OF SECOND SIMULATION
            DO IB1=1,S1%NB
              CALL RIXS$OVERLAPSTATE(S1,IB1,S2,IB2,CVAR)
!             AUG(I,J)=<PSI1(J)|PSI2(I)>
              OVL%AUG(IB2,IB1)=CVAR
            ENDDO ! END LOOP OVER BANDS OF SECOND SIMULATION
          ENDDO ! END LOOP OVER BANDS OF FIRST SIMULATION
        ENDDO ! END LOOP OVER SPIN
      ENDDO ! END LOOP OVER K POINTS
                          CALL TIMING$CLOCKOFF('RIXS$OVERLAPAUGMENTATION')
                          CALL TRACE$POP
      END SUBROUTINE RIXS$OVERLAPAUGMENTATION
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS$OVERLAPSTATE(STATE1,NB1,STATE2,NB2,OVLAP)  ! MARK: RIXS$OVERLAPSTATE
!     **************************************************************************
!     ** CALCULATE ATOMIC OVERLAP BETWEEN TWO STATES                          **
!     ** <STATE1|STATE2>                                                      **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: STATE_TYPE,S,SIM,ATOMMAP
      IMPLICIT NONE
      TYPE(STATE_TYPE), INTENT(IN) :: STATE1
      INTEGER(4), INTENT(IN) :: NB1
      TYPE(STATE_TYPE), INTENT(IN) :: STATE2
      INTEGER(4), INTENT(IN) :: NB2
      COMPLEX(8), INTENT(OUT) :: OVLAP
      INTEGER(4) :: IAT1,IAT2
      INTEGER(4) :: ISP1,ISP2
      INTEGER(4) :: LN1,LN2
      INTEGER(4) :: IPRO1,IPRO2
      INTEGER(4) :: L1,L2
      INTEGER(4) :: M1,M2
      COMPLEX(8) :: CVAR
!     **************************************************************************
      OVLAP=(0.D0,0.D0)
      DO IAT1=1,SIM(1)%NAT
        ISP1=SIM(1)%ISPECIES(IAT1)
        IAT2=ATOMMAP(IAT1)
        ISP2=SIM(2)%ISPECIES(IAT2)
        DO LN1=1,SIM(1)%LNX(ISP1)
          DO LN2=1,SIM(2)%LNX(ISP2)
            L1=SIM(1)%LOX(LN1,ISP1)
            L2=SIM(2)%LOX(LN2,ISP2)
            IF(L1.NE.L2) CYCLE
            IPRO1=SIM(1)%MAP(IAT1,LN1)
            DO M1=1,2*L1+1
              IPRO1=IPRO1+1
              IPRO2=SIM(2)%MAP(IAT2,LN2)
              DO M2=1,2*L2+1
                IPRO2=IPRO2+1
                IF(M1.NE.M2) CYCLE
                CVAR=CONJG(STATE1%PROJ(1,NB1,IPRO1))*STATE2%PROJ(1,NB2,IPRO2)
                OVLAP=OVLAP+CVAR*S(IAT1,LN1,LN2)
              ENDDO
            ENDDO
          ENDDO
        ENDDO
      END DO
      END SUBROUTINE RIXS$OVERLAPSTATE
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS$OVERLAPATOMMATRIX  ! MARK: RIXS$OVERLAPATOMMATRIX
!     **************************************************************************
!     ** CALCULATE ATOMIC OVERLAP MATRIX                                      **
!     ** REAL SPHERICAL HARMONICS GIVE L1=L2 AND M1=M2                        **
!     ** ONLY CALCULATE FOR ONE ARBITRARY M1=M2 AS RESULT IS THE SAME WITHIN  **
!     ** THE SAME L-SHELL; M1=M2 MUST BE ENSURED ELSEWHERE                    **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: SIM,S,ATOMMAP
      IMPLICIT NONE
      INTEGER(4) :: IAT1,IAT2
      INTEGER(4) :: ISP1,ISP2
      INTEGER(4) :: LN1,LN2
      INTEGER(4) :: L1,L2
      REAL(8) :: SVAL
      REAL(8), ALLOCATABLE :: PSPHI1(:),PSPHI2(:)
      REAL(8), ALLOCATABLE :: AEPHI1(:),AEPHI2(:)
      REAL(8), ALLOCATABLE :: AUX(:)
      REAL(8), ALLOCATABLE :: R(:)
      INTEGER(4) :: NR1,NR2
      INTEGER(4) :: GID1,GID2
!     **************************************************************************
                          CALL TRACE$PUSH('RIXS$OVERLAPATOMMATRIX')
                          CALL TIMING$CLOCKON('RIXS$OVERLAPATOMMATRIX')
      ALLOCATE(S(SIM(1)%NAT,SIM(1)%LNXX,SIM(2)%LNXX))
      S=0.D0
      DO IAT1=1,SIM(1)%NAT
        ISP1=SIM(1)%ISPECIES(IAT1)
        GID1=SIM(1)%SETUP(ISP1)%GID
        CALL RADIAL$GETI4(GID1,'NR',NR1)
        ALLOCATE(PSPHI1(NR1))
        ALLOCATE(AEPHI1(NR1))
        ALLOCATE(PSPHI2(NR1))
        ALLOCATE(AEPHI2(NR1))
        ALLOCATE(AUX(NR1))
        ALLOCATE(R(NR1))
        CALL RADIAL$R(GID1,NR1,R)

        DO LN1=1,SIM(1)%LNX(ISP1)
          L1=SIM(1)%LOX(LN1,ISP1)
          IAT2=ATOMMAP(IAT1)
          ISP2=SIM(2)%ISPECIES(IAT2)
          GID2=SIM(2)%SETUP(ISP2)%GID
          CALL RADIAL$GETI4(GID2,'NR',NR2)

          DO LN2=1,SIM(2)%LNX(ISP2)
            L2=SIM(2)%LOX(LN2,ISP2)
            IF(L1.NE.L2) CYCLE
!           GET RADIAL FUNCTIONS
            PSPHI1=SIM(1)%SETUP(ISP1)%PSPHI(:,LN1)
            AEPHI1=SIM(1)%SETUP(ISP1)%AEPHI(:,LN1)  
!           IF GRIDS ARE DIFFERENT, MAP ONTO FIRST GRID   
            IF(GID1.NE.GID2) THEN
              CALL RADIAL$CHANGEGRID(GID2,NR2,SIM(2)%SETUP(ISP2)%PSPHI(:,LN2), &
     &                               GID1,NR1,PSPHI2)
              CALL RADIAL$CHANGEGRID(GID2,NR2,SIM(2)%SETUP(ISP2)%AEPHI(:,LN2), &
     &                               GID1,NR1,AEPHI2)
            ELSE
              PSPHI2=SIM(2)%SETUP(ISP2)%PSPHI(:,LN2)
              AEPHI2=SIM(2)%SETUP(ISP2)%AEPHI(:,LN2)
            END IF
! TODO: CHECK IF ORDER IS CORRECT
            AUX=AEPHI1*AEPHI2-PSPHI1*PSPHI2
            AUX=AUX*R**2
! TODO: CHECK IF AUX IS ZERO OUTSIDE OF R_AUG
            CALL RADIAL$INTEGRAL(GID1,NR1,AUX,SVAL)
            S(IAT1,LN1,LN2)=SVAL
          ENDDO
        ENDDO
        DEALLOCATE(PSPHI1)
        DEALLOCATE(AEPHI1)
        DEALLOCATE(PSPHI2)
        DEALLOCATE(AEPHI2)
        DEALLOCATE(AUX)
        DEALLOCATE(R)
      ENDDO
      ! IPRO=0
      ! WRITE(*,FMT='(6A10)')'IAT','ISP','LN','L','M','IPRO'
      ! DO IAT1=1,SIM(1)%NAT
      !   ISP1=SIM(1)%ISPECIES(IAT1)
      !   DO LN1=1,SIM(1)%LNX(ISP1)
      !     L1=SIM(1)%LOX(LN1,ISP1)
      !     DO M1=1,2*L1+1
      !       IPRO=IPRO+1
      !       WRITE(*,FMT='(6I10)')IAT1,ISP1,LN1,L1,M1,IPRO
      !     ENDDO
      !   ENDDO
      ! ENDDO
                          CALL TIMING$CLOCKOFF('RIXS$OVERLAPATOMMATRIX')
                          CALL TRACE$POP
      END SUBROUTINE RIXS$OVERLAPATOMMATRIX
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS$POLARISATION  ! MARK: RIXS$POLARISATION
!     **************************************************************************
!     **  CALCULATE POLARISATION FROM K VECTOR, SURFACE NORMAL,               **
!     **  AND POLARISATION OF INCIDENT LIGHT                                  **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: SPEC,SPECARR,SETTINGS
      IMPLICIT NONE
      REAL(8), PARAMETER :: TOL=1.D-10
      INTEGER(4) :: ISPEC
      REAL(8) :: KVEC(3)
      REAL(8) :: WORK(3)
      REAL(8) :: WORK2(3)
      REAL(8) :: SVAR
!     **************************************************************************
                          CALL TRACE$PUSH('RIXS$POLARISATION')
      IF(.NOT.ALLOCATED(SPECARR)) THEN
        CALL ERROR$MSG('NO SPECTRUM AVAILABLE')
        CALL ERROR$STOP('RIXS$POLARISATION')
      END IF
!     LOOP OVER SPECTRA
      DO ISPEC=1,SETTINGS%NSPEC
        SPEC=>SPECARR(ISPEC)
!       INCOMING LIGHT
!       ONLY CALCULATE CARTHESIAN POLARISATION IF IT WAS NOT SET IN CNTL FILE
        IF(.NOT.SPEC%TPOLXYZI) THEN
          CALL POLARISATIONCONVERT(SPEC%KDIRI,SPEC%NORMALI,SPEC%POLI,SPEC%POLXYZI)
        END IF
!       OUTGOING LIGHT
!       ONLY CALCULATE CARTHESIAN POLARISATION IF IT WAS NOT SET IN CNTL FILE
        IF(.NOT.SPEC%TPOLXYZO) THEN
          CALL POLARISATIONCONVERT(SPEC%KDIRO,SPEC%NORMALO,SPEC%POLO,SPEC%POLXYZO)
        END IF
      ENDDO
                          CALL TRACE$POP
      END SUBROUTINE RIXS$POLARISATION
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS$DIPOLEMATRIX ! MARK: RIXS$DIPOLEMATRIX
!     **************************************************************************
!     ** CALCULATE DIPOLE MATRIX ELEMENTS IN EXCITED ORBITAL BASIS            **
!     ** SIMULATION 2 IS THE EXCITED STATE, SIMULATION 1 IS THE GROUND STATE  **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: SETTINGS,SIM,SETUP_TYPE,STATE_TYPE,OVL, &
&                           OVLARR,TRSTRT,ATOMMAP,KSMAP,NKPTG,NSPING
      IMPLICIT NONE
      LOGICAL(4), PARAMETER :: TTEST=.FALSE.
      REAL(8), PARAMETER :: PI=4.D0*ATAN(1.D0)
      INTEGER(4) :: NFIL
      INTEGER(4) :: IATOM ! ATOM WITH CORE HOLE
      INTEGER(4) :: ISP   ! SETUP INDEX OF ATOM WITH CORE HOLE
      TYPE(SETUP_TYPE), POINTER :: STP ! POINTER TO SETUP
      TYPE(STATE_TYPE), POINTER :: S
      INTEGER(4) :: N
      INTEGER(4) :: IB
      INTEGER(4) :: LN
      INTEGER(4) :: NR
      REAL(8), ALLOCATABLE :: AEPSI(:) ! (NR) ATOMIC RADIAL PART
      REAL(8) :: GAUNT(3)
      INTEGER(4) :: LLCORE ! LL OF CORE HOLE
      INTEGER(4) :: LLVAL ! LL OF VALENCE ORBITAL
      INTEGER(4) :: L
      INTEGER(4) :: M
      INTEGER(4) :: IKPT
      INTEGER(4) :: ISPIN
      INTEGER(4) :: IPRO
      REAL(8), ALLOCATABLE :: RADINT(:) ! (LNX(ISP)) RADIAL INTEGRAL VALUES
      REAL(8), ALLOCATABLE :: R(:)
      REAL(8), ALLOCATABLE :: WORK(:)
      COMPLEX(8) :: CVAR(3)
      INTEGER(4) :: NTASKS,THISTASK
!     **************************************************************************
      !     CALCULATION NOT NECESSARY WITH RESTART FILE
      IF(TRSTRT) RETURN
                          CALL TRACE$PUSH('RIXS$DIPOLEMATRIX')
                          CALL TIMING$CLOCKON('RIXS$DIPOLEMATRIX')
      IF(TTEST) THEN
        CALL FILEHANDLER$UNIT('PROT',NFIL)
        WRITE(NFIL,'(80("#"))')
        WRITE(NFIL,FMT='(A)')'DIPOLE MATRIX CALCULATION'
        WRITE(NFIL,'(80("#"))')
      END IF
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      IATOM=ATOMMAP(SETTINGS%IATOM)
      ISP=SIM(2)%ISPECIES(IATOM)
      STP=>SIM(2)%SETUP(ISP)
      CALL RADIAL$GETI4(STP%GID,'NR',NR)
      ALLOCATE(AEPSI(NR))
      ALLOCATE(R(NR))
      CALL RADIAL$R(STP%GID,NR,R)
      ALLOCATE(WORK(NR))
!     ==========================================================================
!     == SELECT CORRECT RADIAL PART FOR CORE ORBITAL                          ==
!     == NOTE: THIS ASSUME THE FOLLOWING STRUCTURE                            ==
!     ==       |IB | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |10 |                  ==
!     ==       |---|---|---|---|---|---|---|---|---|---|---|                  ==
!     ==       | N | 1 | 2 | 2 | 3 | 3 | 3 | 4 | 4 | 4 | 4 |                  ==
!     ==       | L | 0 | 0 | 1 | 0 | 1 | 2 | 0 | 1 | 2 | 3 |                  ==
!     ==========================================================================
      N=0
      DO IB=1,STP%NBATOM
        IF(STP%LATOM(IB).EQ.0) N=N+1
        IF(N.EQ.SETTINGS%NCORE.AND.STP%LATOM(IB).EQ.SETTINGS%LCORE) THEN
          AEPSI(:)=STP%AEPSI(:,IB)
          IF(TTEST) WRITE(NFIL,FMT='(A10,I10)')'INDEX RAD:',IB
        END IF
      ENDDO
! WARING: THIS ASSUMES THAT THE CORE ORBITAL IS AN S ORBITAL
! TODO: GENERALISE TO ARBITRARY ORBITALS
! ERROR: DOES IT REQUIRE A PHASE ON THE CORE ORBITAL?
      CALL LLOFLM(SETTINGS%LCORE,0,LLCORE)
      IF(TTEST) WRITE(NFIL,FMT='(A10,I10)')'LLCORE:',LLCORE
!     PRE-CALCULATE RADIAL INTEGRALS
      ALLOCATE(RADINT(SIM(2)%LNX(ISP)))
      DO LN=1,SIM(2)%LNX(ISP)
        WORK=STP%AEPHI(:,LN)*R**3*AEPSI
        CALL RADIAL$INTEGRAL(STP%GID,NR,WORK,RADINT(LN))
      ENDDO
!     LOOP OVER K POINTS
      DO IKPT=1,NKPTG
!       LOOP OVER SPIN
        DO ISPIN=1,NSPING
          IF(KSMAP(IKPT,ISPIN).NE.THISTASK) CYCLE
          S=>SIM(2)%STATEARR(IKPT,ISPIN)
          OVL=>OVLARR(IKPT,ISPIN)
          ALLOCATE(OVL%DIPOLE(3,S%NB))
          IF(TTEST) WRITE(NFIL,FMT='(A10,I10,A10,I10)')'IKPT:',IKPT,'ISPIN:',ISPIN
!         LOOP OVER BANDS
          DO IB=1,S%NB
            IF(TTEST) WRITE(NFIL,FMT='(A10,I10)')'BAND:',IB
            CVAR=(0.D0,0.D0)
            DO LN=1,SIM(2)%LNX(ISP)
              L=SIM(2)%LOX(LN,ISP)
              IPRO=SIM(2)%MAP(IATOM,LN)
              DO M=-L,L
                IPRO=IPRO+1
                CALL LLOFLM(L,M,LLVAL)
!               CALCULATE GAUNT COEFFICIENT VECTOR
!               X COMPONENT
                CALL SPHERICAL$GAUNT(LLVAL,2,LLCORE,GAUNT(1))
!               Y COMPONENT
                CALL SPHERICAL$GAUNT(LLVAL,4,LLCORE,GAUNT(2))
!               Z COMPONENT
                CALL SPHERICAL$GAUNT(LLVAL,3,LLCORE,GAUNT(3))
                CVAR=CVAR+CONJG(S%PROJ(1,IB,IPRO))*RADINT(LN)*GAUNT
              ENDDO
            ENDDO
            CVAR=SQRT(4.D0*PI/3.D0)*CVAR
            IF(TTEST) WRITE(NFIL,FMT='(A10,3(F8.5,SP,F8.5,"I ",S))')'DIPOLE:',CVAR(:)
            OVL%DIPOLE(:,IB)=CVAR
          ENDDO ! END LOOP OVER BANDS
        ENDDO ! END LOOP OVER SPINS
      ENDDO ! END LOOP OVER K POINTS          
      DEALLOCATE(AEPSI)
      DEALLOCATE(R)
      DEALLOCATE(WORK)
      DEALLOCATE(RADINT)
                          CALL TIMING$CLOCKOFF('RIXS$DIPOLEMATRIX')
                          CALL TRACE$POP
      END SUBROUTINE RIXS$DIPOLEMATRIX
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS$ADET ! MARK: RIXS$ADET
!     **************************************************************************
!     ** CALCULATE DETERMINANT ADET FOR OCCUPIED OVERLAP MATRIX               **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: OVL,OVLARR,SIM,KSMAP,NKPTG,NSPING
      IMPLICIT NONE
      INTEGER(4) :: IKPT
      INTEGER(4) :: ISPIN
      INTEGER(4) :: NOCC
      INTEGER(4) :: NTASKS,THISTASK
!     **************************************************************************
                          CALL TRACE$PUSH('RIXS$ADET')
                          CALL TIMING$CLOCKON('RIXS$ADET')
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      DO IKPT=1,NKPTG
        DO ISPIN=1,NSPING
          IF(KSMAP(IKPT,ISPIN).NE.THISTASK) CYCLE
          OVL=>OVLARR(IKPT,ISPIN)
          NOCC=SIM(1)%STATEARR(IKPT,ISPIN)%NOCC
          CALL LIB$DETC8(NOCC,OVL%AMAT,OVL%ADET)
          ! WRITE(*,*)'ADET:',OVL%ADET
        ENDDO
      ENDDO
                          CALL TIMING$CLOCKOFF('RIXS$ADET')
                          CALL TRACE$POP
      END SUBROUTINE RIXS$ADET
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS$KMAT  ! MARK: RIXS$KMAT
!     **************************************************************************
!     ** CALCULATE K MATRIX FOR RIXS CALCULATION                              **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: OVL,OVLARR,SIM,KSMAP,NKPTG,NSPING
      IMPLICIT NONE
      INTEGER(4) :: IKPT
      INTEGER(4) :: ISPIN
      INTEGER(4) :: NOCC
      INTEGER(4) :: NB1,NB2
      INTEGER(4) :: NTASKS,THISTASK
!     **************************************************************************
                          CALL TRACE$PUSH('RIXS$KMAT')
                          CALL TIMING$CLOCKON('RIXS$KMAT')
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      DO IKPT=1,NKPTG
        DO ISPIN=1,NSPING
          IF(KSMAP(IKPT,ISPIN).NE.THISTASK) CYCLE
          OVL=>OVLARR(IKPT,ISPIN)
          SIM(1)%STATE=>SIM(1)%STATEARR(IKPT,ISPIN)
          SIM(2)%STATE=>SIM(2)%STATEARR(IKPT,ISPIN)
          NOCC=SIM(1)%STATE%NOCC
          NB1=SIM(1)%STATE%NB
          NB2=SIM(2)%STATE%NB
          ALLOCATE(OVL%KMAT(NB2-NOCC,NOCC))
          ALLOCATE(OVL%AINV(NOCC,NOCC))
          CALL LIB$INVERTC8(NOCC,OVL%AMAT,OVL%AINV)
          CALL LIB$MATMULC8(NB2-NOCC,NOCC,NOCC,OVL%CMAT,OVL%AINV,OVL%KMAT)
        ENDDO
      ENDDO
                          CALL TIMING$CLOCKOFF('RIXS$KMAT')
                          CALL TRACE$POP
      END SUBROUTINE RIXS$KMAT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS$HMAT  ! MARK: RIXS$HMAT
!     **************************************************************************
!     ** CALCULATE H MATRIX FOR RIXS CALCULATION                              **
!     ** H=TRANSPOSE(B)*TRANSPOSE(A)^-1                                       **
!     **  =TRANSPOSE(B)*TRANSPOSE(A^-1)                                       **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: OVL,OVLARR,SIM,KSMAP,NKPTG,NSPING
      IMPLICIT NONE
      INTEGER(4) :: IKPT
      INTEGER(4) :: ISPIN
      INTEGER(4) :: NOCC
      INTEGER(4) :: NB1,NB2
      INTEGER(4) :: NTASKS,THISTASK
!     **************************************************************************
                          CALL TRACE$PUSH('RIXS$HMAT')
                          CALL TIMING$CLOCKON('RIXS$HMAT')
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      DO IKPT=1,NKPTG
        DO ISPIN=1,NSPING
          IF(KSMAP(IKPT,ISPIN).NE.THISTASK) CYCLE
          OVL=>OVLARR(IKPT,ISPIN)
          NOCC=SIM(1)%STATEARR(IKPT,ISPIN)%NOCC
          NB1=SIM(1)%STATEARR(IKPT,ISPIN)%NB
          NB2=SIM(2)%STATEARR(IKPT,ISPIN)%NB
          ALLOCATE(OVL%HMAT(NB1-NOCC,NOCC))
          CALL LIB$MATMULC8(NB1-NOCC,NOCC,NOCC,TRANSPOSE(OVL%BMAT),TRANSPOSE(OVL%AINV),OVL%HMAT)
        ENDDO ! ISPIN
      ENDDO ! IKPT
                          CALL TIMING$CLOCKOFF('RIXS$HMAT')
                          CALL TRACE$POP
      END SUBROUTINE RIXS$HMAT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS$LMAT(IOCC,IEMP,NB1,NB2,NOCC,AMAT,AINV,BMAT,CMAT,DMAT,LMAT)  ! MARK: RIXS$LMAT
!     **************************************************************************
!     ** CALCULATE L MATRIX FOR RIXS CALCULATION                              **
!     **************************************************************************
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: IOCC
      INTEGER(4), INTENT(IN) :: IEMP
      INTEGER(4), INTENT(IN) :: NB1
      INTEGER(4), INTENT(IN) :: NB2
      INTEGER(4), INTENT(IN) :: NOCC
      COMPLEX(8), INTENT(IN) :: AMAT(NOCC,NOCC)
      COMPLEX(8), INTENT(IN) :: AINV(NOCC,NOCC)
      COMPLEX(8), INTENT(IN) :: BMAT(NOCC,NB1-NOCC)
      COMPLEX(8), INTENT(IN) :: CMAT(NB2-NOCC,NOCC)
      COMPLEX(8), INTENT(IN) :: DMAT(NB2-NOCC,NB1-NOCC)
      COMPLEX(8), INTENT(OUT) :: LMAT(NB2-NOCC,NOCC)

      COMPLEX(8) :: U(NOCC)
      COMPLEX(8), ALLOCATABLE :: MATINV(:,:)
      COMPLEX(8), ALLOCATABLE :: MATP(:,:)
!     **************************************************************************
                          CALL TIMING$CLOCKON('RIXS$LMAT')
      ALLOCATE(MATINV(NOCC,NOCC))
      ALLOCATE(MATP(NB2-NOCC,NOCC))
!     MAT=AMAT WITH ONE COLUMN REPLACED BY ONE IN BMAT
!     MAT=AMAT+U*E_IEMP
      U=BMAT(:,IEMP)-AMAT(:,IOCC)
!     INVERSE OF MAT USING SHERMAN MORRISSON FORMULA
      CALL LIB$SMFASTINVERTC8('V',NOCC,AINV,U,IOCC,MATINV)
!     MATP=CMAT WITH ONE COLUMN REPLACED BY ONE IN DMAT
      MATP=CMAT
      MATP(:,IOCC)=DMAT(:,IEMP)
!     LMAT=MATP*INV(MAT)
      CALL LIB$MATMULC8(NB2-NOCC,NOCC,NOCC,MATP,MATINV,LMAT)
      DEALLOCATE(MATINV)
      DEALLOCATE(MATP)
                          CALL TIMING$CLOCKOFF('RIXS$LMAT')
      RETURN
      END SUBROUTINE RIXS$LMAT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS$LORENTZIAN
!     **************************************************************************
!     ** CALCULATE LORENTZIAN DENOMINATOR HBAR*OMEGA_IN - (EK-EGS) + I*GAMMA  **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: SIM,KSMAP,SETTINGS,NKPTG,NSPING,OVL,OVLARR, &
     &                       STATE_TYPE,SPEC,SPECARR
      IMPLICIT NONE
      COMPLEX(8), PARAMETER :: CI=(0.D0,1.D0)
      INTEGER(4) :: IKPT
      INTEGER(4) :: ISPIN
      INTEGER(4) :: IB
      COMPLEX(8) :: CVAR
      INTEGER(4) :: ISPEC
      TYPE(STATE_TYPE), POINTER :: S1
      TYPE(STATE_TYPE), POINTER :: S2
      INTEGER(4) :: NTASKS,THISTASK
!     **************************************************************************
                          CALL TRACE$PUSH('RIXS$LORENTZIAN')
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      DO IKPT=1,NKPTG
        DO ISPIN=1,NSPING
          IF(KSMAP(IKPT,ISPIN).NE.THISTASK) CYCLE
          OVL=>OVLARR(IKPT,ISPIN)
          S1=>SIM(1)%STATEARR(IKPT,ISPIN)
          S2=>SIM(2)%STATEARR(IKPT,ISPIN)
          ALLOCATE(OVL%LORENTZ(SETTINGS%NSPEC,S2%NB-S2%NOCC))
          DO IB=S2%NOCC+1,S2%NB
            DO ISPEC=1,SETTINGS%NSPEC
              CVAR=SIM(2)%ETOT+S2%EIG(IB)-SIM(1)%ETOT
              SPEC=>SPECARR(ISPEC)
              CVAR=SPEC%OMEGA-CVAR+CI*SPEC%GAMMA
              OVL%LORENTZ(ISPEC,IB-S2%NOCC)=1/CVAR
            ENDDO ! ISPEC
          ENDDO ! IB
        ENDDO ! ISPIN
      ENDDO ! IKPT
                          CALL TRACE$POP
      END SUBROUTINE RIXS$LORENTZIAN
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS$ABSORPTION  ! MARK: RIXS$ABSORPTION
!     **************************************************************************
!     ** CALCULATE ABSORPTION SPECTRUM FROM RIXS DATA                         **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: OVL,OVLARR,NKPTG,NSPING,SIM,KSMAP
      IMPLICIT NONE
      INTEGER(4) :: IKPT
      INTEGER(4) :: ISPIN
      INTEGER(4) :: IEMP
      COMPLEX(8) :: AMPL(3)
      INTEGER(4) :: NOCC2,NB2
      INTEGER(4) :: NTASKS,THISTASK
!     **************************************************************************
                          CALL TRACE$PUSH('RIXS$ABSORPTION')
                          CALL TIMING$CLOCKON('RIXS$ABSORPTION')
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      DO IKPT=1,NKPTG
        DO ISPIN=1,NSPING
          IF(KSMAP(IKPT,ISPIN).NE.THISTASK) CYCLE
          OVL=>OVLARR(IKPT,ISPIN)
          NOCC2=SIM(2)%STATEARR(IKPT,ISPIN)%NOCC
          NB2=SIM(2)%STATEARR(IKPT,ISPIN)%NB
          ALLOCATE(OVL%ABSORP(3,NB2-NOCC2))
          DO IEMP=1,NB2-NOCC2
            CALL RIXS$AMPL(NB2,NOCC2,IEMP,OVL%KMAT,OVL%DIPOLE,OVL%ADET,AMPL)
            OVL%ABSORP(:,IEMP)=AMPL(:)
          ENDDO ! IFINAL
        ENDDO ! ISPIN
      ENDDO ! IKPT
                          CALL TIMING$CLOCKOFF('RIXS$ABSORPTION')
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE RIXS$ABSORPTION
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS$OUTPUT  ! MARK: RIXS$OUTPUT
!     **************************************************************************
!     ** OUTPUT RIXS DATA TO FILE                                               **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: SPEC,SPECARR,SETTINGS,OUTPUT,SIM, &
     &                      OVL,OVLARR,STATE_TYPE,NKPTG,NSPING
      IMPLICIT NONE
      INTEGER(4) :: NFIL
      INTEGER(4) :: ISPEC
      INTEGER(4) :: I
      INTEGER(4) :: IFINAL
      REAL(8) :: EV
      INTEGER(4) :: IKPT,ISPIN
      INTEGER(4) :: NB1,NB2,NOCC
      REAL(8), ALLOCATABLE :: ISUM(:,:) ! SUM OF SPECTRUM OVER K POINTS
      TYPE(STATE_TYPE), POINTER :: S1,S2
      INTEGER(4) :: NTASKS,THISTASK
!     **************************************************************************
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      IF(THISTASK.NE.1) RETURN
                          CALL TRACE$PUSH('RIXS$OUTPUT')
                          CALL TIMING$CLOCKON('RIXS$OUTPUT')
      CALL CONSTANTS('EV',EV)
! WARNING: THERE IS A MAXIMUM LINE LENGTH THAT CAN CRASH THE PROGRAM
!          RECL=1000 IN PAW_FILEHANDLER.F90, LINE 721
      IF(OUTPUT%TKPTSPIN.AND.NKPTG*NSPING.GT.70) THEN
        CALL FILEHANDLER$UNIT('PROT',NFIL)
        WRITE(NFIL,FMT='(A)')'WARNING: LINE LENGTH TOO LONG FOR OUTPUT, SWITCHING TO TOTAL SPECTRUM'
        OUTPUT%TKPTSPIN=.FALSE.
      END IF   
      DO ISPEC=1,SETTINGS%NSPEC
        SPEC=>SPECARR(ISPEC)
!       == FINISHED SPECTRUM ===================================================
!       OPEN FILE
        CALL RIXS$FILEHANDLER(ISPEC,'RIXSOUT','O')
        CALL FILEHANDLER$UNIT('RIXSOUT',NFIL)
!       SUM UP K-POINTS
        ALLOCATE(ISUM(SETTINGS%NE,3))
        ISUM=0.D0
        DO IKPT=1,NKPTG
          ISUM(:,:)=ISUM(:,:)+SPEC%RIXSCONV(IKPT,:,:)
        ENDDO
        DO I=1,SETTINGS%NE
          WRITE(NFIL,*) SPEC%E(I)/EV,ISUM(I,:)
        ENDDO
        DEALLOCATE(ISUM)
!       CLOSE FILE
        CALL RIXS$FILEHANDLER(ISPEC,'RIXSOUT','C')
!       == SPECTRUM FOR EACH K-POINT AND SPIN ==================================
        CALL RIXS$FILEHANDLER(ISPEC,'RIXSOUT_KS','O')
        CALL FILEHANDLER$UNIT('RIXSOUT_KS',NFIL)
        WRITE(NFIL,FMT='(A14)',ADVANCE='NO') '# ENERGY[EV] |'
        DO IKPT=1,NKPTG
          DO ISPIN=1,NSPING
            WRITE(NFIL,FMT='(A4,I4,A4,I1,A1)',ADVANCE='NO') ' KP=',IKPT,' SP=',ISPIN,'|'
          ENDDO
        ENDDO
        WRITE(NFIL,*)
        DO I=1,SETTINGS%NE
          WRITE(NFIL,FMT='(E14.7E2)',ADVANCE='NO')SPEC%E(I)/EV
          DO IKPT=1,NKPTG
            DO ISPIN=1,NSPING
              WRITE(NFIL,FMT='(E14.7E2)',ADVANCE='NO')SPEC%RIXS(I,IKPT,ISPIN)
            ENDDO
          ENDDO
          WRITE(NFIL,*)
        ENDDO
        CALL RIXS$FILEHANDLER(ISPEC,'RIXSOUT_KS','C')
      ENDDO   
!       IF(OUTPUT%TRAW) THEN
!         DO ISPEC=1,SETTINGS%NSPEC
!           SPEC=>SPECARR(ISPEC)
!           CALL RIXS$FILEHANDLER(ISPEC,'RIXSRAW','O')
!           CALL FILEHANDLER$UNIT('RIXSRAW',NFIL)
!           DO IKPT=1,NKPTG
!             DO ISPIN=1,NSPING
!               NB2=SIM(2)%STATEARR(IKPT,ISPIN)%NB
!               NOCC=SIM(1)%STATEARR(IKPT,ISPIN)%NOCC
!               WRITE(NFIL,FMT='(A10,I5,A10,I3)')'# KPOINT=',IKPT,' SPIN=',ISPIN
!               WRITE(NFIL,FMT='(3A14)')'# ENERGY','CROSSSECTION','FINAL BAND'
!               DO IFINAL=1,NB2-NOCC
!                 I=IFINAL+NOCC
!                 WRITE(NFIL,*)SPEC%ERAW(IKPT,ISPIN,IFINAL)/EV, &
! &                            SPEC%IRAW(IKPT,ISPIN,IFINAL),I
!               ENDDO
!             ENDDO
!           ENDDO
!           CALL RIXS$FILEHANDLER(ISPEC,'RIXSRAW','C')
!         ENDDO
!       END IF

      DO IKPT=1,NKPTG
        DO ISPIN=1,NSPING
          OVL=>OVLARR(IKPT,ISPIN)
          S1=>SIM(1)%STATEARR(IKPT,ISPIN)
          S2=>SIM(2)%STATEARR(IKPT,ISPIN)
          NB1=S1%NB
          NB2=S2%NB
          NOCC=S1%NOCC
          IF(NOCC.NE.S2%NOCC) THEN
            CALL ERROR$MSG('NUMBER OF OCCUPIED STATES NOT THE SAME')
            CALL ERROR$MSG('SHOULD HAVE BEEN CAUGHT/CORRECTED EARLIER')
            CALL ERROR$STOP('RIXS$OUTPUT')
          END IF
! ERROR: THERE IS A MAXIMUM LINE LENGTH THAT CAN CRASH THE PROGRAM
!        EFFECTED BY SIZE OF SECOND WRITEMATC8 ARGUMENT
!           IF(OUTPUT%TOVL) THEN
!             ! CALL WRITEMATC8ABS(NB2,NB1,OVL%OV,'OVL',IKPT,ISPIN)
!             CALL WRITEMATC8(NB2,NB1,OVL%OV,'OVL',IKPT,ISPIN)
!           END IF
!           IF(OUTPUT%TOVLPW) THEN
!             ! CALL WRITEMATC8ABS(NB2,NB1,OVL%PW,'OVLPW',IKPT,ISPIN)
!             CALL WRITEMATC8(NB2,NB1,OVL%PW,'OVLPW',IKPT,ISPIN)
!           END IF
!           IF(OUTPUT%TOVLAUG) THEN
!             ! CALL WRITEMATC8ABS(NB2,NB1,OVL%AUG,'OVLAUG',IKPT,ISPIN)
!             CALL WRITEMATC8(NB2,NB1,OVL%AUG,'OVLAUG',IKPT,ISPIN)
!           END IF
!           IF(OUTPUT%TOVLOCC) THEN
!             ! CALL WRITEMATC8ABS(NOCC,NOCC,OVL%OVOCC,'OVLOCC',IKPT,ISPIN)
!             CALL WRITEMATC8(NOCC,NOCC,OVL%OVOCC,'OVLOCC',IKPT,ISPIN)
!           END IF
!           IF(OUTPUT%TOVLEMP) THEN
!             ! CALL WRITEMATC8ABS(NB2-NOCC,NOCC,OVL%OVEMP,'OVLEMP',IKPT,ISPIN)
!             CALL WRITEMATC8(NB2-NOCC,NOCC,OVL%OVEMP,'OVLEMP',IKPT,ISPIN)
!           END IF
!           IF(OUTPUT%TKMAT) THEN
!             ! CALL WRITEMATC8ABS(NB2-NOCC,NOCC,OVL%KMAT,'KMAT',IKPT,ISPIN)
!             CALL WRITEMATC8(NB2-NOCC,NOCC,OVL%KMAT,'KMAT',IKPT,ISPIN)
!           END IF
!           IF(OUTPUT%TDIPOLE) THEN
!             ! CALL WRITEMATC8ABS(NB2,3,TRANSPOSE(OVL%DIPOLE),'DIPOLE',IKPT,ISPIN)
!             CALL WRITEMATC8(NB2,3,TRANSPOSE(OVL%DIPOLE),'DIPOLE',IKPT,ISPIN)
!           END IF
          IF(OUTPUT%TADET) THEN
            CALL FILEHANDLER$UNIT('ADET',NFIL)
            WRITE(NFIL,FMT='(A,I5,A,I3)')'# KPOINT:',IKPT,' SPIN:',ISPIN
            WRITE(NFIL,FMT='("(",F14.8,",",F14.8,")")')OVL%ADET
          END IF
        ENDDO
      ENDDO
! !     WRITE BINARY FILES
!       IF(OUTPUT%TBINARY) THEN
!         IF(OUTPUT%TOVL)    CALL BINCOMPMAT('OVL')
!         IF(OUTPUT%TOVLPW)  CALL BINCOMPMAT('OVLPW')
!         IF(OUTPUT%TOVLAUG) CALL BINCOMPMAT('OVLAUG')
!         IF(OUTPUT%TOVLOCC) CALL BINCOMPMAT('OVLOCC')
!         IF(OUTPUT%TOVLEMP) CALL BINCOMPMAT('OVLEMP')
!         IF(OUTPUT%TKMAT)   CALL BINCOMPMAT('KMAT')
!         IF(OUTPUT%TDIPOLE) CALL BINCOMPMAT('DIPOLE')
!       END IF
                          CALL TIMING$CLOCKOFF('RIXS$OUTPUT')
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE RIXS$OUTPUT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS$OUTPUTGATHER  ! MARK: RIXS$OUTPUTGATHER
!     **************************************************************************
!     ** GATHER RIXS DATA FROM ALL TASKS AND WRITE TO FILE                     **
!     **************************************************************************
      USE MPE_MODULE
      USE RIXS_MODULE, ONLY: OUTPUT,SIM,NKPTG,NSPING,NSIM,KSMAP,RTASK, &
     &                       OVL,OVLARR,STATE_TYPE
      IMPLICIT NONE
      INTEGER(4) :: IKPT
      INTEGER(4) :: ISPIN
      INTEGER(4) :: IS
      INTEGER(4) :: NTASKS,THISTASK
      TYPE(STATE_TYPE), POINTER :: S,S1,S2
!     **************************************************************************
                          CALL TRACE$PUSH('RIXS$OUTPUTGATHER')
                          CALL TIMING$CLOCKON('RIXS$OUTPUTGATHER')
      CALL MPE$QUERY('~',NTASKS,THISTASK)
!     SEND NOCC AND NB TO READ TASK
      DO IS=1,NSIM
        DO IKPT=1,NKPTG
          DO ISPIN=1,NSPING
            IF(KSMAP(IKPT,ISPIN).NE.THISTASK.AND.THISTASK.NE.RTASK) CYCLE
            S=>SIM(IS)%STATEARR(IKPT,ISPIN)
            CALL MPE$SENDRECEIVE('~',KSMAP(IKPT,ISPIN),RTASK,S%NOCC)
            CALL MPE$SENDRECEIVE('~',KSMAP(IKPT,ISPIN),RTASK,S%NB)
          ENDDO
        ENDDO
      ENDDO
      DO IKPT=1,NKPTG
        DO ISPIN=1,NSPING
          IF(KSMAP(IKPT,ISPIN).NE.THISTASK.AND.THISTASK.NE.RTASK) CYCLE
          OVL=>OVLARR(IKPT,ISPIN)
          S1=>SIM(1)%STATEARR(IKPT,ISPIN)
          S2=>SIM(2)%STATEARR(IKPT,ISPIN)
!         OVERLAP PW, AUG AND DIPOLE MANDATORY FOR RESTART FILE
          IF(.NOT.ALLOCATED(OVL%PW)) THEN
            ALLOCATE(OVL%PW(S2%NB,S1%NB))
          END IF
          CALL MPE$SENDRECEIVE('~',KSMAP(IKPT,ISPIN),RTASK,OVL%PW)
          IF(.NOT.ALLOCATED(OVL%AUG)) THEN
            ALLOCATE(OVL%AUG(S2%NB,S1%NB))
          END IF
          CALL MPE$SENDRECEIVE('~',KSMAP(IKPT,ISPIN),RTASK,OVL%AUG)
          IF(.NOT.ALLOCATED(OVL%DIPOLE)) THEN
            ALLOCATE(OVL%DIPOLE(3,S2%NB))
          END IF
          CALL MPE$SENDRECEIVE('~',KSMAP(IKPT,ISPIN),RTASK,OVL%DIPOLE)

          ! IF(OUTPUT%TOVL) THEN
          !   IF(.NOT.ALLOCATED(OVL%OV)) THEN
          !     ALLOCATE(OVL%OV(S2%NB,S1%NB))
          !   END IF
          !   CALL MPE$SENDRECEIVE('~',KMAP(IKPT),RTASK,OVL%OV)
          ! END IF
          ! IF(OUTPUT%TOVLOCC) THEN
          !   IF(.NOT.ALLOCATED(OVL%OVOCC)) THEN
          !     ALLOCATE(OVL%OVOCC(S2%NOCC,S1%NOCC))
          !   END IF
          !   CALL MPE$SENDRECEIVE('~',KMAP(IKPT),RTASK,OVL%OVOCC)
          ! END IF
          ! IF(OUTPUT%TOVLEMP) THEN
          !   IF(.NOT.ALLOCATED(OVL%OVEMP)) THEN
          !     ALLOCATE(OVL%OVEMP(S2%NB-S2%NOCC,S1%NOCC))
          !   END IF
          !   CALL MPE$SENDRECEIVE('~',KMAP(IKPT),RTASK,OVL%OVEMP)
          ! END IF
          ! IF(OUTPUT%TKMAT) THEN
          !   IF(.NOT.ALLOCATED(OVL%KMAT)) THEN
          !     ALLOCATE(OVL%KMAT(S2%NB-S2%NOCC,S1%NOCC))
          !   END IF
          !   CALL MPE$SENDRECEIVE('~',KMAP(IKPT),RTASK,OVL%KMAT)
          ! END IF
          ! IF(OUTPUT%TDIPOLE) THEN
          !   IF(.NOT.ALLOCATED(OVL%DIPOLE)) THEN
          !     ALLOCATE(OVL%DIPOLE(3,S2%NB))
          !   END IF
          !   CALL MPE$SENDRECEIVE('~',KMAP(IKPT),RTASK,OVL%DIPOLE)
          ! END IF
          IF(OUTPUT%TADET) THEN
            CALL MPE$SENDRECEIVE('~',KSMAP(IKPT,ISPIN),RTASK,OVL%ADET)
          END IF
        ENDDO
      ENDDO
                          CALL TIMING$CLOCKOFF('RIXS$OUTPUTGATHER')
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE RIXS$OUTPUTGATHER
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS$GETCH(ID,VAL)  ! MARK: RIXS$GETCH
!     **************************************************************************
!     ** GET CHARACTER IN RIXS MODULE                                          **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: THIS, SELECTED
      IMPLICIT NONE
      CHARACTER(*) ,INTENT(IN) :: ID
      CHARACTER(*),INTENT(OUT):: VAL
!     **************************************************************************
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SIMULATION SELECTED')
        CALL ERROR$STOP('RIXS$GETCH')
      END IF
      IF(ID.EQ.'FILE') THEN
        VAL=THIS%FILE
      ELSE IF(ID.EQ.'FLAG') THEN
        VAL=THIS%FLAG
      ELSE IF(ID.EQ.'ID') THEN
        VAL=THIS%ID
      ELSE
        CALL ERROR$MSG('ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID',ID)
        CALL ERROR$STOP('RIXS$GETCH')
      END IF
      RETURN
      END SUBROUTINE RIXS$GETCH
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS$SETCH(ID,VAL)  ! MARK: RIXS$SETCH
!     **************************************************************************
!     ** SET CHARACTER IN RIXS MODULE                                          **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: THIS, SELECTED
      IMPLICIT NONE
      CHARACTER(*) ,INTENT(IN) :: ID
      CHARACTER(*) ,INTENT(IN):: VAL
!     **************************************************************************
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SIMULATION SELECTED')
        CALL ERROR$STOP('RIXS$SETCH')
      END IF
      IF(ID.EQ.'FILE') THEN
        THIS%FILE=VAL
      ELSE IF(ID.EQ.'FLAG') THEN
        THIS%FLAG=VAL
      ELSE IF(ID.EQ.'ID') THEN
        THIS%ID=VAL
      ELSE
        CALL ERROR$MSG('ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID',ID)
        CALL ERROR$STOP('RIXS$SETCH')
      END IF
      RETURN
      END SUBROUTINE RIXS$SETCH
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
!       SUBROUTINE RIXS$WRITEPHI(NFIL,ISP,ID)  ! MARK: RIXS$WRITEPHI
! !     **************************************************************************
! !     **                                                                      **
! !     **************************************************************************
!       USE RIXS_MODULE, ONLY: THIS  ! SELECTS SIMULATION
!       IMPLICIT NONE
!       INTEGER(4)  ,INTENT(IN) :: NFIL
!       INTEGER(4), INTENT(IN) :: ISP ! SELECT SETUP
!       CHARACTER(*) ,INTENT(IN) :: ID ! SELECT AEPHI OR PSPHI
!       INTEGER(4) :: NR
!       INTEGER(4) :: IR
!       REAL(8), ALLOCATABLE :: R(:) ! (NR)
!       REAL(8), ALLOCATABLE :: PSI(:,:) ! (NR,LNX)
!       INTEGER(4) :: NTASKS,THISTASK
! !     **************************************************************************
!       CALL MPE$QUERY('~',NTASKS,THISTASK)
!       IF(THISTASK.NE.1) RETURN
!       CALL RADIAL$GETI4(THIS%SETUP(ISP)%GID,'NR',NR)
!       ALLOCATE(R(NR))
!       ALLOCATE(PSI(NR,THIS%LNX(ISP)))
!       CALL RADIAL$R(THIS%SETUP(ISP)%GID,NR,R)
!       IF(ID.EQ.'AEPHI') THEN
!         PSI=THIS%SETUP(ISP)%AEPHI
!       ELSE IF(ID.EQ.'PSPHI') THEN
!         PSI=THIS%SETUP(ISP)%PSPHI
!       ELSE
!         CALL ERROR$MSG('ID NOT RECOGNIZED')
!         CALL ERROR$CHVAL('ID',ID)
!         CALL ERROR$STOP('RIXS$WRITEPHI')
!       END IF
!       DO IR=1,NR
!         WRITE(NFIL,*) R(IR),PSI(IR,:)
!       ENDDO
!       DEALLOCATE(PSI)
!       DEALLOCATE(R)
!       END SUBROUTINE RIXS$WRITEPHI
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE MAPGRID(X,Y,N,GRID,XMIN,DE)  ! MARK: MAPGRID
!     **************************************************************************
!     ** MAP VALUE Y AT POSITION X ONTO GRID                                  **
!     ** SPLIT BETWEEN THE TWO NEIGHBORING POINTS DEPENDING ON DISTANCE       **
!     **************************************************************************
      IMPLICIT NONE
      REAL(8), INTENT(IN) :: X
      REAL(8), INTENT(IN) :: Y
      INTEGER(4), INTENT(IN) :: N
      REAL(8), INTENT(INOUT) :: GRID(N)
      REAL(8), INTENT(IN) :: XMIN
      REAL(8), INTENT(IN) :: DE
      INTEGER(4) :: I1,I2
      REAL(8) :: X0
      REAL(8) :: W1,W2
!     **************************************************************************
      X0=(X-XMIN)/DE+1.D0
      I1=INT(X0)
      I2=I1+1
      W2=(X0-REAL(I1,KIND=8))
      W1=1.D0-W2
      IF(I1.GT.0.AND.I1.LE.N) GRID(I1)=GRID(I1)+Y*W1
      IF(I2.GT.0.AND.I2.LE.N) GRID(I2)=GRID(I2)+Y*W2
      RETURN
      END SUBROUTINE MAPGRID
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS$FILEHANDLER(ISPEC,FILE,FLAG)  !MARK: RIXS$FILEHANDLER
!     **************************************************************************
!     **  OPEN OR CLOSE FILE FOR SPECTRUM ISPEC                               **
!     **  FLAG='O' OPEN FILE, FLAG='C' CLOSE FILE                             **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: SPECARR,SETTINGS
      USE STRINGS_MODULE
      IMPLICIT NONE 
      INTEGER(4), INTENT(IN) :: ISPEC
      CHARACTER(*), INTENT(IN) :: FILE
      CHARACTER(1), INTENT(IN) :: FLAG

      IF(ISPEC.LT.1.OR.ISPEC.GT.SETTINGS%NSPEC)THEN
        CALL ERROR$MSG('SPECTRUM INDEX OUT OF RANGE')
        CALL ERROR$I4VAL('ISPEC',ISPEC)
        CALL ERROR$STOP('RIXS$FILE')
      END IF
      IF(FILE.NE.'RIXSOUT'.AND.FILE.NE.'RIXSOUT_KS') THEN
        CALL ERROR$MSG('FILE MUST BE RIXSOUT OR RIXSOUT_KS')
        CALL ERROR$CHVAL('FILE',FILE)
        CALL ERROR$STOP('RIXS$FILEHANDLER')
      END IF
      IF(FLAG.EQ.'O') THEN
        IF(FILE.EQ.'RIXSOUT') THEN
          CALL FILEHANDLER$SETFILE(FILE,.FALSE., &
     &                           TRIM(ADJUSTL(SPECARR(ISPEC)%FILE)))
        ELSE IF(FILE.EQ.'RIXSOUT_KS') THEN
          CALL FILEHANDLER$SETFILE(FILE,.FALSE., &
     &                           TRIM(ADJUSTL(SPECARR(ISPEC)%FILE))//-'_KS')
        END IF
      ELSE IF(FLAG.EQ.'C') THEN
        CALL FILEHANDLER$CLOSE(FILE)
      ELSE
        CALL ERROR$MSG('FLAG MUST BE O OR C')
        CALL ERROR$CHVAL('FLAG',FLAG)
        CALL ERROR$STOP('RIXS$FILEHANDLER')
      END IF
      END SUBROUTINE RIXS$FILEHANDLER
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS_COREENERGY  ! MARK: RIXS_COREENERGY
!     **************************************************************************
!     ** CALCULATE CORE ENERGY FOR BOTH SIMULATIONS                           **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: SIM,ATOMMAP,NSIM
      IMPLICIT NONE
      REAL(8) :: GSCORE
      REAL(8) :: EXCORE
      INTEGER(4) :: IAT1,IAT2
      INTEGER(4) :: ISP1,ISP2
!     **************************************************************************
      GSCORE=0.D0
      EXCORE=0.D0
      DO IAT1=1,SIM(1)%NAT
        ISP1=SIM(1)%ISPECIES(IAT1)
        IAT2=ATOMMAP(IAT1)
        ISP2=SIM(2)%ISPECIES(IAT2)
        GSCORE=GSCORE+SIM(1)%SETUP(ISP1)%ECORE
        EXCORE=EXCORE+SIM(2)%SETUP(ISP2)%ECORE
      ENDDO
      SIM(1)%ECORE=GSCORE
      SIM(2)%ECORE=EXCORE
      RETURN
      END SUBROUTINE RIXS_COREENERGY
        
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE LLOFLM(L,M,LL) ! MARK: LLOFLM
!     **************************************************************************
!     ** CALCULATE LL=L*L+L-M+1                                               **
!     **************************************************************************
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: L
      INTEGER(4), INTENT(IN) :: M
      INTEGER(4), INTENT(OUT) :: LL
!     **************************************************************************
      LL=L*L+L-M+1
      RETURN
      END SUBROUTINE LLOFLM
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE LORENTZCONV(N,X,Y,GAMMA)  ! MARK: LORENTZCONV
!     **************************************************************************
!     ** CALCULATE CONVOLUTION WITH LORENTZIAN FUNCTION                       **
!     ** L(X,X0,GAMMA)=(Y/2)/(PI*((X-X0)**2+(GAMMA/2)**2))                    **
!     **************************************************************************
      IMPLICIT NONE
      REAL(8), PARAMETER :: PI=4.D0*ATAN(1.D0)
      INTEGER(4), INTENT(IN) :: N
      REAL(8), INTENT(IN) :: X(N)
      REAL(8), INTENT(INOUT) :: Y(N)
      REAL(8), INTENT(IN) :: GAMMA
      REAL(8) :: WORK(N)
      INTEGER(4) :: I,J
      REAL(8) :: GAMMA2
      REAL(8) :: SVAR
!     **************************************************************************
      DO I=1,N
        WORK(I)=0.D0
        GAMMA2=0.25D0*GAMMA*GAMMA
        DO J=1,N
          SVAR=GAMMA/(2.D0*PI*((X(I)-X(J))**2+GAMMA2))
          WORK(I)=WORK(I)+Y(J)*SVAR
        ENDDO
      ENDDO
      Y=WORK
      RETURN
      END SUBROUTINE LORENTZCONV
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE GAUSSCONV(N,X,Y,SIGMA)
!     **************************************************************************
!     ** CALCULATE CONVOLUTION WITH GAUSSIAN FUNCTION                         **
!     ** G(X,X0,SIGMA)=(1/(SIGMA*SQRT(2*PI)))*EXP(-0.5*((X-X0)/SIGMA)**2)     **
!     **************************************************************************
      IMPLICIT NONE
      REAL(8), PARAMETER :: PI=4.D0*ATAN(1.D0)
      INTEGER(4), INTENT(IN) :: N
      REAL(8), INTENT(IN) :: X(N)
      REAL(8), INTENT(INOUT) :: Y(N)
      REAL(8), INTENT(IN) :: SIGMA
      REAL(8) :: WORK(N)
      INTEGER(4) :: I,J
      REAL(8) :: SVAR
!     **************************************************************************
      DO I=1,N
        WORK(I)=0.D0
        DO J=1,N
          SVAR=EXP(-0.5D0*((X(I)-X(J))/SIGMA)**2)/(SIGMA*SQRT(2.D0*PI))
          WORK(I)=WORK(I)+Y(J)*SVAR
        ENDDO
      ENDDO
      Y=WORK
      RETURN
      END SUBROUTINE GAUSSCONV
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE CROSS_PROD(A,B,C)  ! MARK: CROSS_PROD
!     **************************************************************************
!     ** CALCULATE CROSS PRODUCT OF TWO VECTORS                               **
!     **************************************************************************
      IMPLICIT NONE
      REAL(8), INTENT(IN) :: A(3)
      REAL(8), INTENT(IN) :: B(3)
      REAL(8), INTENT(OUT) :: C(3)
!     **************************************************************************
      C(1)=A(2)*B(3)-A(3)*B(2)
      C(2)=A(3)*B(1)-A(1)*B(3)
      C(3)=A(1)*B(2)-A(2)*B(1)
      RETURN
      END SUBROUTINE CROSS_PROD
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE VEC_ORTHO(A,B)  ! MARK: VEC_ORTHO
!     **************************************************************************
!     ** CALCULATE ORTHOGONAL VECTOR TO A                                      **
!     **************************************************************************
! TODO: UNDERSTAND
      IMPLICIT NONE
      REAL(8), INTENT(IN) :: A(3)
      REAL(8), INTENT(OUT) :: B(3)
      REAL(8) :: VECVAR(3)
!     **************************************************************************
      VECVAR = (/1.D0,0.D0,0.D0/)
      IF(DOT_PRODUCT(A,VECVAR).EQ.NORM2(A)) THEN
        VECVAR = (/0.D0,1.D0,0.D0/)
      END IF
      CALL CROSS_PROD(A,VECVAR,B)
      END SUBROUTINE VEC_ORTHO
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE POLARISATIONCONVERT(K,N,POL,POLXYZ)  ! MARK: POLARISATIONCONVERT
!     **************************************************************************
!     ** POLARISATION IS GIVEN BY:                                            **
!     **   K: VECTOR OF LIGHT                                                 **
!     **   N: SURFACE NORMAL OF MATERIAL                                      **
!     **   POL: POLARISATION VECTOR WITH POL(1)=SIGMA AND POL(2)=PI POLAR.    **
!     ** RETURN POLARISATION IN XYZ COORDINATES                               **
!     **************************************************************************
      IMPLICIT NONE
      REAL(8), INTENT(IN) :: K(3)
      REAL(8), INTENT(IN) :: N(3)
      COMPLEX(8), INTENT(IN) :: POL(2)
      COMPLEX(8), INTENT(OUT) :: POLXYZ(3)
      REAL(8), PARAMETER :: TOL=1.D-8
      REAL(8) :: WORK(3)
      REAL(8) :: WORK2(3)
      REAL(8) :: SVAR
!     **************************************************************************
      CALL CROSS_PROD(K,N,WORK)
      SVAR=NORM2(WORK)
      IF(SVAR.LT.TOL) THEN
        CALL ERROR$MSG('K VECTOR AND SURFACE NORMAL ARE PARALLEL')
        CALL ERROR$MSG('POLARISATION VECTOR IS SET TO ARBITRARY ORTHO. VECTOR')
        CALL VEC_ORTHO(K,WORK)
        SVAR=NORM2(WORK)
      END IF
      WORK=WORK/SVAR
      CALL CROSS_PROD(WORK,K,WORK2)
      WORK2=WORK2/NORM2(WORK2)
      POLXYZ=POL(1)*WORK+POL(2)*WORK2
      SVAR=SQRT(SUM(ABS(POLXYZ)**2))
      POLXYZ=POLXYZ/SVAR
      RETURN
      END SUBROUTINE POLARISATIONCONVERT
      
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE WRITEMATC8(N,M,A,FLAG,IKPT,ISPIN)  ! MARK: WRITEMATC8
!     **************************************************************************
!     ** WRITE COMPLEX MATRIX TO FILE                                         **
!     **************************************************************************
      IMPLICIT NONE
! WARNING: LIMIT DUE TO RECL IN PAW_FILEHANDLER.F90, LINE 721
      INTEGER(4), PARAMETER :: RECL=1000
      INTEGER(4), PARAMETER :: LIMIT=INT(RECL/30)
      INTEGER(4), INTENT(IN) :: N
      INTEGER(4), INTENT(IN) :: M
      COMPLEX(8), INTENT(IN) :: A(N,M)
      CHARACTER(*), INTENT(IN) :: FLAG
      INTEGER(4), INTENT(IN) :: IKPT
      INTEGER(4), INTENT(IN) :: ISPIN
      INTEGER(4) :: NFIL
      INTEGER(4) :: I
      INTEGER(4) :: MLIM,NLIM
      CHARACTER(256) :: FORMAT
      INTEGER(4) :: NTASKS,THISTASK
!     **************************************************************************
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      IF(THISTASK.NE.1) RETURN
      CALL FILEHANDLER$UNIT(TRIM(ADJUSTL(FLAG)),NFIL)
      MLIM=MIN(LIMIT,M)
      NLIM=MIN(LIMIT,N)
      WRITE(FORMAT,*)MLIM
      FORMAT="("//TRIM(ADJUSTL(FORMAT))//'("(",F13.8,",",F13.8,") "))'
      WRITE(NFIL,FMT='(A,I5,A,I3)')'# KPOINT:',IKPT,' SPIN:',ISPIN
      DO I=1,NLIM
        WRITE(NFIL,FMT=FORMAT)A(I,1:MLIM)
      ENDDO
      RETURN
      END SUBROUTINE WRITEMATC8
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE BINCOMPMAT(ID)
!     **************************************************************************
!     ** WRITE COMPLEX MATRIX TO BINARY FILE                                  **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: OVLARR,OVL,SIM,NKPTG,NSPING
      USE STRINGS_MODULE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4) :: NFIL
      INTEGER(4) :: IKPT,ISPIN
      INTEGER(4) :: NB1,NB2,NOCC
      INTEGER(4) :: THISTASK,NTASKS
      LOGICAL(4) :: TCHK
!     **************************************************************************
                          CALL TRACE$PUSH('BINCOMPMAT')
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      IF(THISTASK.NE.1) RETURN
      TCHK=.FALSE.
      IF(ID.EQ.'OVL')    TCHK=.TRUE.
      IF(ID.EQ.'OVLAUG') TCHK=.TRUE.
      IF(ID.EQ.'OVLPW')  TCHK=.TRUE.
      IF(ID.EQ.'OVLOCC') TCHK=.TRUE.
      IF(ID.EQ.'OVLEMP') TCHK=.TRUE.
      IF(ID.EQ.'KMAT')   TCHK=.TRUE.
      IF(ID.EQ.'DIPOLE') TCHK=.TRUE.
      IF(.NOT.TCHK) THEN
        CALL ERROR$MSG('ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID',ID)
        CALL ERROR$STOP('BINCOMPMAT')
      END IF

      CALL FILEHANDLER$SETFILE(ID//'BIN',.TRUE.,'.'//-ID//-'BIN')
      CALL FILEHANDLER$SETSPECIFICATION(ID//'BIN','STATUS','REPLACE')
      CALL FILEHANDLER$SETSPECIFICATION(ID//'BIN','POSITION','REWIND')
      CALL FILEHANDLER$SETSPECIFICATION(ID//'BIN','ACTION','WRITE')
      CALL FILEHANDLER$SETSPECIFICATION(ID//'BIN','FORM','UNFORMATTED')

      CALL FILEHANDLER$UNIT(ID//'BIN',NFIL)
      
      WRITE(NFIL)NKPTG
      WRITE(NFIL)NSPING
      DO IKPT=1,NKPTG
        DO ISPIN=1,NSPING
          OVL=>OVLARR(IKPT,ISPIN)
          NB1=SIM(1)%STATEARR(IKPT,ISPIN)%NB
          NB2=SIM(2)%STATEARR(IKPT,ISPIN)%NB
          NOCC=SIM(1)%STATEARR(IKPT,ISPIN)%NOCC
          WRITE(NFIL)NB2,NB1,NOCC
          IF(ID.EQ.'OVL') THEN
            WRITE(NFIL)OVL%OV
          ELSE IF(ID.EQ.'OVLAUG') THEN
            WRITE(NFIL)OVL%AUG
          ELSE IF(ID.EQ.'OVLPW') THEN
            WRITE(NFIL)OVL%PW
          ELSE IF(ID.EQ.'AMAT') THEN
            WRITE(NFIL)OVL%AMAT
          ELSE IF(ID.EQ.'BMAT') THEN
            WRITE(NFIL)OVL%BMAT
          ELSE IF(ID.EQ.'CMAT') THEN
            WRITE(NFIL)OVL%CMAT
          ELSE IF(ID.EQ.'DMAT') THEN
            WRITE(NFIL)OVL%DMAT
          ELSE IF(ID.EQ.'KMAT') THEN
            WRITE(NFIL)OVL%KMAT
          ELSE IF(ID.EQ.'HMAT') THEN
            WRITE(NFIL)OVL%HMAT          
          ELSE IF(ID.EQ.'DIPOLE') THEN
            WRITE(NFIL)OVL%DIPOLE
          END IF
        ENDDO
      ENDDO          
      CALL FILEHANDLER$CLOSE(ID//'BIN')
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE BINCOMPMAT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE WRITEMATC8ABS(N,M,A,FLAG,IKPT,ISPIN)  ! MARK: WRITEMATC8
!     **************************************************************************
!     ** WRITE ABSOLUTE VALUE OF COMPLEX MATRIX TO FILE                       **
!     **************************************************************************
      IMPLICIT NONE
      INTEGER(4), PARAMETER :: LIMIT=50
      INTEGER(4), INTENT(IN) :: N
      INTEGER(4), INTENT(IN) :: M
      COMPLEX(8), INTENT(IN) :: A(N,M)
      CHARACTER(*), INTENT(IN) :: FLAG
      INTEGER(4), INTENT(IN) :: IKPT
      INTEGER(4), INTENT(IN) :: ISPIN
      INTEGER(4) :: NFIL
      INTEGER(4) :: I,J
      INTEGER(4) :: MLIM,NLIM
      INTEGER(4) :: NTASKS,THISTASK
!     **************************************************************************
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      IF(THISTASK.NE.1) RETURN
      CALL FILEHANDLER$UNIT(TRIM(ADJUSTL(FLAG)),NFIL)
      WRITE(NFIL,FMT='(A,I5,A,I3)')'# KPOINT:',IKPT,' SPIN:',ISPIN
      MLIM=MIN(LIMIT,M)
      NLIM=MIN(LIMIT,N)
      DO I=1,NLIM
        DO J=1,MLIM
          WRITE(NFIL,FMT='(F12.8)',ADVANCE='NO')ABS(A(I,J))
          WRITE(NFIL,FMT='(A)',ADVANCE='NO')' '
        ENDDO
        WRITE(NFIL,*)
      ENDDO
      RETURN
      END SUBROUTINE WRITEMATC8ABS
! ! WARNING: THIS TESTS ONLY CHANGE OF SIGN AND NOT A POTENTIAL RANDOM PHASE CHANGE
! !          COULD THIS HAPPEN IN A SIMULATION?
! !     ...1.........2.........3.........4.........5.........6.........7.........8
!       SUBROUTINE TEST$INVERSE
! !     **************************************************************************
! !     ** TEST DETERMINANT PROCEDURE FOR INDEPENDENCE OF SIGN                  **
! !     **************************************************************************
!       IMPLICIT NONE
!       INTEGER(4) :: M1 ! TOTAL STATES OF GROUNDSTATE
!       INTEGER(4) :: M2 ! TOTAL STATES OF EXCITESTATE
!       INTEGER(4) :: NOCC ! NUMBER OF OCCUPIED STATES
!       INTEGER(4) :: I,J
!       REAL(8), ALLOCATABLE :: ARE(:,:) ! HELPER MATRIX
!       REAL(8), ALLOCATABLE :: AIM(:,:) ! HELPER MATRIX
!       COMPLEX(8), ALLOCATABLE :: OVLORIGINAL(:,:) ! (M2,M1) ORIGINAL OVERLAP MATRIX
!       COMPLEX(8), ALLOCATABLE :: OVL(:,:) ! (M2,M1) OVERLAP MATRIX
!       COMPLEX(8), ALLOCATABLE :: OVLOCC(:,:) ! (NOCC,NOCC) OCCUPIED OVERLAP MATRIX
!       COMPLEX(8), ALLOCATABLE :: OVLEMP(:,:) ! (M2-NOCC,NOCC) EMPTY OVERLAP MATRIX
!       COMPLEX(8), ALLOCATABLE :: INVOVLOCC(:,:) ! (NOCC,NOCC) INVERSE OCCUPIED OVERLAP MATRIX
!       COMPLEX(8), ALLOCATABLE :: KMAT(:,:) ! (M2-NOCC,NOCC) K MATRIX
!       COMPLEX(8) :: DET
!       INTEGER(4) :: COUNT
!       INTEGER(4) :: NTASKS,THISTASK
! !     **************************************************************************
!       CALL MPE$QUERY('~',NTASKS,THISTASK)
!       IF(THISTASK.NE.1) RETURN
!       NOCC=4
!       M1=4
!       M2=8
!       IF(M1.LT.NOCC) THEN
!         CALL ERROR$MSG('NUMBER OF OCCUPIED STATES MUST BE SMALLER OR EQUAL THAN TOTAL STATES')
!         CALL ERROR$STOP('TEST$INVERSE')
!       END IF
!       IF(M2.LE.NOCC) THEN
!         CALL ERROR$MSG('NUMBER OF TOTAL STATES MUST BE LARGER THAN OCCUPIED STATES')
!         CALL ERROR$STOP('TEST$INVERSE')
!       END IF
!       ALLOCATE(OVL(M2,M1))
!       ALLOCATE(OVLORIGINAL(M2,M1))
!       ALLOCATE(OVLOCC(NOCC,NOCC))
!       ALLOCATE(OVLEMP(M2-NOCC,NOCC))
!       ALLOCATE(ARE(M2,M1))
!       ALLOCATE(AIM(M2,M1))
!       ALLOCATE(INVOVLOCC(NOCC,NOCC))
!       ALLOCATE(KMAT(M2-NOCC,NOCC))
! !     RANDOMLY INITIALIZE OVERLAP
!       CALL RANDOM_NUMBER(ARE)
!       CALL RANDOM_NUMBER(AIM)
!       OVLORIGINAL=CMPLX(ARE,AIM,KIND=8)

! !     ## ORIGINAL MATRIX
!       WRITE(*,*) '####### ORIGINAL MATRIX #######'
!       OVL(:,:)=OVLORIGINAL(:,:)
! !     EXTRACTION OF OCCUPIED AND EMPTY OVERLAP
!       CALL TEST_SPLITOVL
!       CALL LIB$INVERTC8(NOCC,OVLOCC,INVOVLOCC)
!       CALL LIB$MATMULC8(M2-NOCC,NOCC,NOCC,OVLEMP,INVOVLOCC,KMAT)
!       CALL LIB$DETC8(NOCC,OVLOCC,DET)
!       CALL REPORT

! !     ## CHANGE SIGN OF EMPTY STATE (HERE 7) IN EXCITESTATE
! !     ##    - DETERMINANT: NO EFFECT
! !     ##    - INVERSE OF OCCUPIED OVERLAP: NO EFFECT
! !     ##    - K MATRIX: CHANGED SIGN IN ROW OF STATE 7
!       WRITE(*,*) '####### CHANGE SIGN OF ROW 7 IN EXCITESTATE #######'
!       OVL(:,:)=OVLORIGINAL(:,:)
!       OVL(7,:)=OVL(7,:)*(-1.D0)
!       CALL TEST_SPLITOVL
!       CALL LIB$INVERTC8(NOCC,OVLOCC,INVOVLOCC)
!       CALL LIB$MATMULC8(M2-NOCC,NOCC,NOCC,OVLEMP,INVOVLOCC,KMAT)
!       CALL LIB$DETC8(NOCC,OVLOCC,DET)
!       CALL REPORT

! !     ## CHANGE SIGN OF OCCUPIED STATE (HERE 3) IN EXCITESTATE
! !     ##    - DETERMINANT: CHANGED SIGN
! !     ##    - INVERSE OF OCCUPIED OVERLAP: CHANGED SIGN IN COLUMN 3  
! !     ##    - K MATRIX: CHANGED SIGN IN COLUMN 3
!       WRITE(*,*) '####### CHANGE SIGN OF ROW 3 IN EXCITESTATE #######'
!       OVL(:,:)=OVLORIGINAL(:,:)
!       OVL(3,:)=OVL(3,:)*(-1.D0)
!       CALL TEST_SPLITOVL
!       CALL LIB$INVERTC8(NOCC,OVLOCC,INVOVLOCC)
!       CALL LIB$MATMULC8(M2-NOCC,NOCC,NOCC,OVLEMP,INVOVLOCC,KMAT)
!       CALL LIB$DETC8(NOCC,OVLOCC,DET)
!       CALL REPORT

! !     ## CHANGE SIGN OF OCCUPIED STATE (HERE 3) IN GROUNDSTATE
! !     ##    - DETERMINANT: CHANGED SIGN
! !     ##    - INVERSE OF OCCUPIED OVERLAP: CHANGED SIGN IN ROW 3
! !     ##    - K MATRIX: NO EFFECT
!       WRITE(*,*) '####### CHANGE SIGN OF ROW 3 IN GROUNDSTATE #######'
!       OVL(:,:)=OVLORIGINAL(:,:)
!       OVL(:,3)=OVL(:,3)*(-1.D0)
!       CALL TEST_SPLITOVL
!       CALL LIB$INVERTC8(NOCC,OVLOCC,INVOVLOCC)
!       CALL LIB$MATMULC8(M2-NOCC,NOCC,NOCC,OVLEMP,INVOVLOCC,KMAT)
!       CALL LIB$DETC8(NOCC,OVLOCC,DET)
!       CALL REPORT


!       DEALLOCATE(OVL)
!       DEALLOCATE(OVLORIGINAL)
!       DEALLOCATE(OVLOCC)
!       DEALLOCATE(OVLEMP)
!       DEALLOCATE(ARE)
!       DEALLOCATE(AIM)
!       DEALLOCATE(INVOVLOCC)
!       DEALLOCATE(KMAT)
!       CONTAINS
!         SUBROUTINE TEST_SPLITOVL
!         OVLOCC(:,:)=OVL(1:NOCC,1:NOCC)
!         OVLEMP(:,:)=OVL(NOCC+1:M2,1:NOCC)
!         RETURN
!         END SUBROUTINE TEST_SPLITOVL

!         SUBROUTINE REPORT
!         WRITE(*,*) 'MATRIX OVL:'
!         DO I=1,M2
!           WRITE(*,*)OVL(I,:)
!         ENDDO
!         WRITE(*,*)'MATRIX OVLOCC:'
!         DO I=1,NOCC
!           WRITE(*,*)OVLOCC(I,:)
!         ENDDO
!         WRITE(*,*)'MATRIX OVLEMP:'
!         DO I=1,M2-NOCC
!           WRITE(*,*)OVLEMP(I,:)
!         ENDDO
!         WRITE(*,*) 'DETERMINANT:',DET
!         WRITE(*,*) 'INVERSE OVLOCC:'
!         DO I=1,NOCC
!           WRITE(*,*)INVOVLOCC(I,:)
!         ENDDO
!         WRITE(*,*) 'K MATRIX:'
!         DO I=1,M2-NOCC
!           WRITE(*,*)KMAT(I,:)
!         ENDDO
!         RETURN
!         END SUBROUTINE REPORT
!       END SUBROUTINE TEST$INVERSE
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS$WRITERESTART
!     **************************************************************************
!     ** WRITE RESTART DATA TO FILE                                           **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: THIS,OVL,OVLARR,STATE_TYPE,RTASK
      IMPLICIT NONE
      INTEGER(4) :: NFIL
      INTEGER(4) :: IKPT,ISPIN,IS
      TYPE(STATE_TYPE), POINTER :: S
      INTEGER(4) :: THISTASK,NTASKS
!     **************************************************************************
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      IF(THISTASK.NE.RTASK) RETURN
                          CALL TRACE$PUSH('RIXS$WRITERESTART')
                          CALL TIMING$CLOCKON('RIXS$WRITERESTART')
      CALL FILEHANDLER$UNIT('RSTRT_OUT',NFIL)
      REWIND NFIL
      DO IS=1,2
        CALL RIXS$ISELECT(IS)
!       WRITE NKPT,NSPIN,NDIM,ETOT (HAVE TO BE THE SAME FOR BOTH SIMULATIONS)
        WRITE(NFIL)THIS%NKPT,THIS%NSPIN,THIS%NDIM,THIS%ETOT
        CALL RIXS$UNSELECT
      ENDDO
      DO IS=1,2
        CALL RIXS$ISELECT(IS)
!       WRITE WKPT (HAS TO BE THE SAME FOR BOTH SIMULATIONS)
        WRITE(NFIL)THIS%WKPT
        CALL RIXS$UNSELECT
      ENDDO
      ! WRITE NB,EIG
      DO IS=1,2
        CALL RIXS$ISELECT(IS)
        DO IKPT=1,THIS%NKPT
          DO ISPIN=1,THIS%NSPIN
            S=>THIS%STATEARR(IKPT,ISPIN)
            WRITE(NFIL)S%NB
            WRITE(NFIL)S%NOCC
            WRITE(NFIL)S%EIG
          ENDDO
        ENDDO
        CALL RIXS$UNSELECT
      ENDDO

      ! WRITE OVERLAP
      CALL RIXS$SELECT('GROUNDSTATE')
      DO IKPT=1,THIS%NKPT
        DO ISPIN=1,THIS%NSPIN
          OVL=>OVLARR(IKPT,ISPIN)
          WRITE(NFIL)OVL%AUG
          WRITE(NFIL)OVL%PW
          WRITE(NFIL)OVL%DIPOLE
        ENDDO
      ENDDO
      CALL RIXS$UNSELECT
      CALL FILEHANDLER$CLOSE('RSTRT_OUT')
                          CALL TIMING$CLOCKOFF('RIXS$WRITERESTART')
                          CALL TRACE$POP
      END SUBROUTINE RIXS$WRITERESTART
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS$READRESTART
!     **************************************************************************
!     ** READ RESTART DATA TO FILE                                            **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: THIS,SIM,OVL,OVLARR,NKPTG,NSPING,KSMAP,RTASK, &
     &                       STATE_TYPE
      USE MPE_MODULE
      IMPLICIT NONE
      INTEGER(4) :: NFIL
      TYPE(STATE_TYPE), POINTER :: S
      INTEGER(4) :: IKPT,ISPIN,IS
      REAL(8) :: EV
      INTEGER(4) :: THISTASK,NTASKS
!     **************************************************************************
                          CALL TRACE$PUSH('RIXS$READRESTART')
                          CALL TIMING$CLOCKON('RIXS$READRESTART')
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      CALL CONSTANTS('EV',EV)
      IF(THISTASK.EQ.1) THEN
        CALL FILEHANDLER$UNIT('RSTRT_IN',NFIL)
        REWIND NFIL
        DO IS=1,2
          CALL RIXS$ISELECT(IS)
!         READ NKPT,NSPIN,NDIM,ETOT (HAVE TO BE THE SAME FOR BOTH SIMULATIONS)
          READ(NFIL)THIS%NKPT,THIS%NSPIN,THIS%NDIM,THIS%ETOT
          CALL RIXS$UNSELECT
        ENDDO
      END IF
      DO IS=1,2
        CALL RIXS$ISELECT(IS)
        CALL MPE$BROADCAST('~',1,THIS%NKPT)
        CALL MPE$BROADCAST('~',1,THIS%NSPIN)
        CALL MPE$BROADCAST('~',1,THIS%NDIM)
        CALL MPE$BROADCAST('~',1,THIS%ETOT)
        ALLOCATE(THIS%WKPT(THIS%NKPT))
        CALL RIXS$UNSELECT
      ENDDO
      CALL RIXS$SELECT('GROUNDSTATE')
      NKPTG=THIS%NKPT
      NSPING=THIS%NSPIN
      CALL RIXS$UNSELECT
      IF(ALLOCATED(KSMAP)) THEN
        CALL ERROR$MSG('KSMAP ALREADY ALLOCATED')
        CALL ERROR$STOP('RIXS$READRESTART')
      END IF
      ALLOCATE(KSMAP(NKPTG,NSPING))
      CALL KSMAPINIT(NKPTG,NSPING,RTASK,KSMAP)      
      IF(THISTASK.EQ.RTASK) THEN
        DO IS=1,2
          CALL RIXS$ISELECT(IS)
!         READ WKPT (HAS TO BE THE SAME FOR BOTH SIMULATIONS)
          READ(NFIL)THIS%WKPT
          CALL RIXS$UNSELECT
        ENDDO
      END IF
      DO IS=1,2
        CALL RIXS$ISELECT(IS)
        CALL MPE$BROADCAST('~',1,THIS%WKPT)
        IF(ALLOCATED(THIS%STATEARR)) THEN
          CALL ERROR$MSG('STATEARR ALREADY ALLOCATED')
          CALL ERROR$STOP('RIXS$READRESTART')
        END IF
        ALLOCATE(THIS%STATEARR(THIS%NKPT,THIS%NSPIN))
        CALL RIXS$UNSELECT
      ENDDO
      
      DO IS=1,2
        CALL RIXS$ISELECT(IS)
        DO IKPT=1,THIS%NKPT
          DO ISPIN=1,THIS%NSPIN
            IF(KSMAP(IKPT,ISPIN).NE.THISTASK.AND.THISTASK.NE.RTASK) CYCLE
            S=>THIS%STATEARR(IKPT,ISPIN)
            IF(THISTASK.EQ.RTASK) THEN
              READ(NFIL)S%NB
              READ(NFIL)S%NOCC
            END IF
            CALL MPE$SENDRECEIVE('~',RTASK,KSMAP(IKPT,ISPIN),S%NB)
            CALL MPE$SENDRECEIVE('~',RTASK,KSMAP(IKPT,ISPIN),S%NOCC)
            ALLOCATE(S%EIG(S%NB))
            IF(THISTASK.EQ.RTASK) THEN
              READ(NFIL)S%EIG
            END IF
            CALL MPE$SENDRECEIVE('~',RTASK,KSMAP(IKPT,ISPIN),S%EIG)
          ENDDO
        ENDDO
        CALL RIXS$UNSELECT
      ENDDO

      IF(ALLOCATED(OVLARR)) THEN
        CALL ERROR$MSG('OVLARR ALREADY ALLOCATED')
        CALL ERROR$STOP('RIXS$READRESTART')
      END IF
      ALLOCATE(OVLARR(NKPTG,NSPING))
      ! READ OVERLAP
      DO IKPT=1,NKPTG
        DO ISPIN=1,NSPING
          IF(KSMAP(IKPT,ISPIN).NE.THISTASK.AND.THISTASK.NE.RTASK) CYCLE
          OVL=>OVLARR(IKPT,ISPIN)
          SIM(1)%STATE=>SIM(1)%STATEARR(IKPT,ISPIN)
          SIM(2)%STATE=>SIM(2)%STATEARR(IKPT,ISPIN)
          ALLOCATE(OVL%PW(SIM(2)%STATE%NB,SIM(1)%STATE%NB))
          OVL%PW=0.D0
          ALLOCATE(OVL%AUG(SIM(2)%STATE%NB,SIM(1)%STATE%NB))
          OVL%AUG=0.D0
          ALLOCATE(OVL%DIPOLE(3,SIM(2)%STATE%NB))
          OVL%DIPOLE=0.D0
          IF(THISTASK.EQ.RTASK) THEN
            READ(NFIL)OVL%AUG
            READ(NFIL)OVL%PW
            READ(NFIL)OVL%DIPOLE
          END IF
          CALL MPE$SENDRECEIVE('~',RTASK,KSMAP(IKPT,ISPIN),OVL%PW)
          CALL MPE$SENDRECEIVE('~',RTASK,KSMAP(IKPT,ISPIN),OVL%AUG)
          CALL MPE$SENDRECEIVE('~',RTASK,KSMAP(IKPT,ISPIN),OVL%DIPOLE)
        ENDDO
      ENDDO
      IF(THISTASK.EQ.RTASK) THEN
        CALL FILEHANDLER$CLOSE('RSTRT_IN')
        CALL FILEHANDLER$UNIT('PROT',NFIL)
        WRITE(NFIL,'(80("#"))')
        WRITE(NFIL,FMT='(A)')'RESTART DATA READ'
        WRITE(NFIL,'(80("#"))')
        WRITE(NFIL,FMT='(A10,I10)')'NKPT:',NKPTG
        WRITE(NFIL,FMT='(A10,I10)')'NSPIN:',NSPING
        WRITE(NFIL,FMT='(A10,I10)')'NDIM:',SIM(1)%NDIM
        WRITE(NFIL,FMT='(A10,F20.10)')'ETOT 1:',SIM(1)%ETOT/EV
        WRITE(NFIL,FMT='(A10,F20.10)')'ETOT 2:',SIM(2)%ETOT/EV
      END IF
                          CALL TIMING$CLOCKOFF('RIXS$READRESTART')
                          CALL TRACE$POP
      END SUBROUTINE RIXS$READRESTART
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE ATOMMAPPING
!     **************************************************************************
!     ** MAP INDICES ATOMS FROM SIMULATION 1 TO SIMULATION 2                  **
!     ** MAPPING BASED ON ATOM NAMES                                          **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: ATOMMAP,SIM
      IMPLICIT NONE
      INTEGER(4) :: IAT1
      INTEGER(4) :: IAT2
      LOGICAL(4) :: FOUND
!     **************************************************************************
                          CALL TRACE$PUSH('ATOMMAPPING')
      ALLOCATE(ATOMMAP(SIM(1)%NAT))
      DO IAT1=1,SIM(1)%NAT
        FOUND=.FALSE.
        DO IAT2=1,SIM(2)%NAT
          IF(SIM(1)%ATOMID(IAT1).EQ.SIM(2)%ATOMID(IAT2)) THEN
            ATOMMAP(IAT1)=IAT2
            FOUND=.TRUE.
            EXIT
          END IF
        ENDDO
        IF(.NOT.FOUND) THEN
          CALL ERROR$MSG('ATOM NOT FOUND IN SIMULATION 2')
          CALL ERROR$I4VAL('IAT1',IAT1)
          CALL ERROR$CHVAL('ATOMID',SIM(1)%ATOMID(IAT1))
          CALL ERROR$STOP('ATOMMAPPING')
        END IF
      ENDDO
                          CALL TRACE$POP
      END SUBROUTINE ATOMMAPPING

      SUBROUTINE KSMAPINIT(NKPTG,NSPING,RTASK,KSMAP)
!     **************************************************************************
!     ** INITIALIZE KSMAP ARRAY                                               **
!     **************************************************************************
      IMPLICIT NONE
      INTEGER(4), PARAMETER :: PERLINE=14
      INTEGER(4), INTENT(IN) :: NKPTG
      INTEGER(4), INTENT(IN) :: NSPING
      INTEGER(4), INTENT(OUT) :: RTASK
      INTEGER(4), INTENT(OUT) :: KSMAP(NKPTG,NSPING)
      INTEGER(4) :: NFIL
      INTEGER(4) :: NTASKS,THISTASK
      INTEGER(4) :: IKPT
      INTEGER(4) :: ISPIN
      INTEGER(4) :: IND
      INTEGER(4) :: BEGINKPT
      INTEGER(4) :: ENDKPT
!     **************************************************************************
                          CALL TRACE$PUSH('KSMAPINIT')
      CALL MPE$QUERY('~',NTASKS,THISTASK)
!     ONLY ONE TASK: 
!       BOTH READ TASK AND RESPONSIBLE FOR EVERY KPOINT
      IF(NTASKS.EQ.1) THEN
        RTASK=1
        KSMAP=1
!     MORE THAN ONE TASK:
!       FIRST IS READ TASK, OTHERS ARE RESPONSIBLE FOR DIFFERENT KPOINTS
      ELSE
        RTASK=1
        DO IKPT=1,NKPTG
          DO ISPIN=1,NSPING
            IND=NSPING*(IKPT-1)+ISPIN
            IND=MOD(IND-1,NTASKS-1)+2
            KSMAP(IKPT,ISPIN)=IND
          ENDDO
        ENDDO
      END IF
      CALL FILEHANDLER$UNIT('PROT',NFIL)
      IF(THISTASK.EQ.RTASK) THEN
        WRITE(NFIL,FMT='(A8,I5)')'RW TASK:',RTASK
        BEGINKPT=1
        DO WHILE(.TRUE.)
!         KPT IN THIS LINE (HALF FOR NSPIN=2)
          ENDKPT=MIN(BEGINKPT+PERLINE/NSPING-1,NKPTG)
          IF(NSPING.EQ.1) THEN
            WRITE(NFIL,FMT='(A8,*(I4,"|"))')'KPOINT:',(IKPT, IKPT=BEGINKPT,ENDKPT)
          ELSE
            WRITE(NFIL,FMT='(A8,*(I9,"|"))')'KPOINT:',(IKPT, IKPT=BEGINKPT,ENDKPT)
          END IF
          WRITE(NFIL,FMT='(A8,*(I4,"|"))')'SPIN:',(MOD(IND-1,NSPING)+1, IND=BEGINKPT*NSPING-1,ENDKPT*NSPING)
          WRITE(NFIL,FMT='(A8,*(I4,"|"))')'KSMAP:',(KSMAP(IKPT,:), IKPT=BEGINKPT,ENDKPT)
          IF(ENDKPT.NE.NKPTG) THEN
            BEGINKPT=ENDKPT+1
          ELSE
            EXIT
          END IF
        ENDDO
      END IF
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE KSMAPINIT
! ERROR: CHECK DEFINITIONS OF NDIM, NDIMD AND EVERYTHING CONNECTED TO IT!
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS$DENMAT
!     **************************************************************************
!     ** CALCULATE DENSITY MATRIX                                             **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: RTASK,TRSTRT,NSIM,SIM,NKPTG
      IMPLICIT NONE
      INTEGER(4) :: NTASKS,THISTASK
      INTEGER(4) :: IS
      INTEGER(4) :: NAT
      INTEGER(4) :: IAT
      INTEGER(4) :: NDIM
      INTEGER(4) :: NDIMD
      INTEGER(4) :: NSPIN
      INTEGER(4) :: ISP
      INTEGER(4) :: LMNXX
      INTEGER(4) :: LMNX
      INTEGER(4) :: IKPT
      INTEGER(4) :: ISPIN
      INTEGER(4) :: IPRO
      INTEGER(4) :: NB
      INTEGER(4) :: LMN1,LMN2
      COMPLEX(8), ALLOCATABLE :: PROJ(:,:,:)
      COMPLEX(8), ALLOCATABLE :: DENMAT1(:,:,:)
      COMPLEX(8) :: CSVAR1,CSVAR2
!     **************************************************************************
      CALL MPE$QUERY('~',NTASKS,THISTASK)
!     READTASK CONTAINS ALL DATA (COULD CALCULATE IN PARALLEL BUT MORE COMPLEX)
      IF(THISTASK.NE.RTASK) RETURN
                          CALL TRACE$PUSH('DENMAT')
                          CALL TIMING$CLOCKON('DENMAT')
      IF(TRSTRT) THEN
        CALL ERROR$MSG('DENSITY MATRIX CAN NOT BE CALCULATED FROM RIXSRSTRT FILE')
        CALL ERROR$STOP('DENMAT')
      END IF
!     LOOP OVER BOTH SIMULATIONS
      DO IS=1,NSIM
        NAT=SIM(IS)%NAT
        NSPIN=SIM(IS)%NSPIN
        NDIM=SIM(IS)%NDIM
        NDIMD=NSPIN
        IF(NDIM.NE.1) THEN
          CALL ERROR$MSG('DENSITY MATRIX ONLY IMPLEMENTED FOR NDIM=1')
          CALL ERROR$STOP('RIXS$DENMAT')
        END IF
!       GET MAXIMUM NUMBER OF LMNX OF ALL SPECIES
        LMNXX=0
        DO ISP=1,SIM(IS)%NSP
          LMNXX=MAX(LMNXX,SIM(IS)%LMNX(ISP))
        ENDDO
        ALLOCATE(SIM(IS)%DENMAT(LMNXX,LMNXX,NDIMD,NAT))
        SIM(IS)%DENMAT=(0.D0,0.D0)
!       LOOP OVER KPOINTS AND SPINS
        DO IKPT=1,NKPTG
          DO ISPIN=1,NSPIN
!           SET POINTER TO STATE
            SIM(IS)%STATE=>SIM(IS)%STATEARR(IKPT,ISPIN)
            NB=SIM(IS)%STATE%NB
            IPRO=1
!           LOOP OVER ATOMS
            DO IAT=1,NAT
              ISP=SIM(IS)%ISPECIES(IAT)
              LMNX=SIM(IS)%LMNX(ISP)
              ALLOCATE(PROJ(NDIM,NB,LMNX))
              PROJ(:,:,:)=SIM(IS)%STATE%PROJ(:,:,IPRO:IPRO-1+LMNX)
              ALLOCATE(DENMAT1(LMNX,LMNX,NDIMD))

              CALL DENMATCALC(NDIM,NB,LMNX,SIM(IS)%STATE%OCC,PROJ,DENMAT1)

              IF(NDIM.EQ.1) THEN
                SIM(IS)%DENMAT(1:LMNX,1:LMNX,ISPIN,IAT) &
&                     =SIM(IS)%DENMAT(1:LMNX,1:LMNX,ISPIN,IAT)+DENMAT1(:,:,1)
              ELSE
                CALL ERROR$MSG('DENSITY MATRIX ONLY IMPLEMENTED FOR NDIM=1')
                CALL ERROR$STOP('RIXS$DENMAT')
!                 SIM(IS)%DENMAT(1:LMNX,1:LMNX,:,IAT) &
! &                     =SIM(IS)%DENMAT(1:LMNX,1:LMNX,:,IAT)+DENMAT1(:,:,:)
              END IF
              DEALLOCATE(PROJ)
              DEALLOCATE(DENMAT1)
              IPRO=IPRO+LMNX
            ENDDO ! IAT
          ENDDO ! ISPIN
        ENDDO ! IKPT
!       CONVERT SPIN-UP AND SPIN-DOWN DENSITY MATRIX INTO
!       TOTAL AND SPIN DENSITY MATRIX
        ! IF(NSPIN.EQ.2) THEN
        !   DO IAT=1,NAT
        !     ISP=SIM(IS)%ISPECIES(IAT)
        !     LMNX=SIM(IS)%LMNX(ISP)
        !     DO LMN1=1,LMNX
        !       DO LMN2=1,LMNX
        !         CSVAR1=SIM(IS)%DENMAT(LMN1,LMN2,1,IAT)
        !         CSVAR2=SIM(IS)%DENMAT(LMN1,LMN2,2,IAT)
        !         SIM(IS)%DENMAT(LMN1,LMN2,1,IAT)=CSVAR1+CSVAR2 ! TOTAL
        !         SIM(IS)%DENMAT(LMN1,LMN2,2,IAT)=CSVAR1-CSVAR2 ! SPIN
        !       ENDDO ! LMN2
        !     ENDDO ! LMN1
        !   ENDDO ! IAT
        ! END IF
      ENDDO ! IS
                          CALL TIMING$CLOCKOFF('DENMAT')
                          CALL TRACE$POP
      END SUBROUTINE RIXS$DENMAT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE DENMATCALC(NDIM,NB,LMNX,OCC,PROJ,DENMAT)
!     **************************************************************************
!     ** CALCULATE DENSITY MATRIX                                             **
!     **************************************************************************
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: NDIM
      INTEGER(4), INTENT(IN) :: NB
      INTEGER(4), INTENT(IN) :: LMNX
      REAL(8), INTENT(IN) :: OCC(NB)
      COMPLEX(8), INTENT(IN) :: PROJ(NDIM,NB,LMNX)
      COMPLEX(8), INTENT(OUT) :: DENMAT(LMNX,LMNX,NDIM)
      COMPLEX(8) :: DENMAT1(LMNX,LMNX,NDIM,NDIM)
      INTEGER(4) :: LMN1,LMN2
      INTEGER(4) :: IDIM1,IDIM2,IDIM
      INTEGER(4) :: IB
      COMPLEX(8) :: CSVAR
      LOGICAL(4), PARAMETER :: TPR=.FALSE.
!     **************************************************************************
      IF(NDIM.NE.1) THEN
        CALL ERROR$MSG('DENSITY MATRIX ONLY IMPLEMENTED FOR NDIM=1')
        CALL ERROR$STOP('DENMATCALC')
      END IF
      DENMAT=(0.D0,0.D0)
      DENMAT1=(0.D0,0.D0)
      DO IB=1,NB
        DO LMN1=1,LMNX
          DO LMN2=1,LMNX
            DO IDIM1=1,NDIM
              DO IDIM2=1,NDIM
                DENMAT1(LMN1,LMN2,IDIM1,IDIM2)=DENMAT1(LMN1,LMN2,IDIM1,IDIM2) &
&                 +PROJ(IDIM1,IB,LMN1)*OCC(IB)*CONJG(PROJ(IDIM2,IB,LMN2))
              ENDDO ! IDIM2
            ENDDO ! IDIM1
          ENDDO ! LMN2
        ENDDO ! LMN1
      ENDDO ! IB
!     MAP DENSITY MATRIX ONTO TOTAL AND SPIN DENSITY
      IF(NDIM.EQ.1) THEN
        DO LMN1=1,LMNX
          DO LMN2=1,LMNX
            DENMAT(LMN1,LMN2,1)=DENMAT1(LMN1,LMN2,1,1)
          ENDDO
        ENDDO
      ELSE
        CALL ERROR$MSG('DENSITY MATRIX ONLY IMPLEMENTED FOR NDIM=1')
        CALL ERROR$STOP('DENMATCALC')
      END IF
!     SYMMETRIZE DENSITY MATRIX
      DO IDIM=1,NDIM
        DO LMN1=1,LMNX
          DO LMN2=1,LMNX
            CSVAR=0.5D0*(DENMAT(LMN1,LMN2,IDIM)+CONJG(DENMAT(LMN2,LMN1,IDIM)))
            DENMAT(LMN1,LMN2,IDIM)=CSVAR
            DENMAT(LMN2,LMN1,IDIM)=CONJG(CSVAR)
          ENDDO ! LMN2
        ENDDO ! LMN1
      ENDDO ! IDIM
!     SYMMETRIZE DENSITY MATRIX WITH RESPECT TO TIME INVERSION            
!     FOR COLLINEAR CALCULATIONS PSI(K)=CONJG(PSI(-K)). THEREFORE THE                          
!     DENSITY MATRIX IS REAL AFTER SUMMING OVER K-POINTS. THIS IS NOT TRUE
!     FOR TRANSPORT CALCULATIONS. THIS SYMMETRY FAILS FRO SPIN-ORBIT      
!     AND NON-COLLINEAR CALCULATIONS WHERE AN EXPLICIT MAGNETIC FIELD     
!     IS PRESENT.
      IF(NDIM.EQ.1) THEN
        DENMAT(:,:,1)=REAL(DENMAT(:,:,1),KIND=8)
      END IF
      RETURN
      END SUBROUTINE DENMATCALC
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS$WRITEDENMAT
!     **************************************************************************
!     ** WRITE DENSITY MATRIX TO FILE                                         **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: RTASK,NSIM,SIM
      IMPLICIT NONE
      INTEGER(4) :: NFIL
      INTEGER(4) :: NTASKS,THISTASK
      INTEGER(4) :: IS
      INTEGER(4) :: IAT
      INTEGER(4) :: ISPIN
      INTEGER(4) :: LMNX
      INTEGER(4) :: LMN
      INTEGER(4) :: ISP
!     **************************************************************************
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      IF(THISTASK.NE.RTASK) RETURN
                          CALL TRACE$PUSH('RIXS$WRITEDENMAT')
      CALL FILEHANDLER$UNIT('PROT',NFIL)
      DO IS=1,NSIM
        WRITE(NFIL,'(80("#"))')
        WRITE(NFIL,FMT='("DENSITY MATRICES FOR SIM ",I2)') IS
        WRITE(NFIL,'(80("#"))')
        DO IAT=1,SIM(IS)%NAT
          ISP=SIM(IS)%ISPECIES(IAT)
          LMNX=SIM(IS)%LMNX(ISP)
          DO ISPIN=1,SIM(IS)%NSPIN
            WRITE(NFIL,FMT='("DENMAT FOR ATOM ",I3,"(",A6,") AND SPIN",I2)')IAT,SIM(IS)%ATOMID(IAT),ISPIN
            DO LMN=1,LMNX
              WRITE(NFIL,FMT='("R",I3,*(F10.5))')LMN,REAL(SIM(IS)%DENMAT(LMN,:LMNX,ISPIN,IAT))
              IF(ANY(AIMAG(SIM(IS)%DENMAT(LMN,:LMNX,ISPIN,IAT)).GT.1.D-8)) THEN
                WRITE(NFIL,FMT='("I",I3,*(F10.5))')LMN,AIMAG(SIM(IS)%DENMAT(LMN,:LMNX,ISPIN,IAT))
              END IF
            ENDDO
          ENDDO
        ENDDO
      ENDDO
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE RIXS$WRITEDENMAT
!
! WARNING: CHECK VALIDITY OF SPIN CONVOLUTION
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS$SPINCONV
!     **************************************************************************
!     ** SPIN CONVOLUTION FOR NSPIN=2                                         **
!     ** TOTAL = I(UP) * |ADET(DOWN)|^4 + I(DOWN) * |ADET(UP)|^4              **
!     ** SPIN CONVOLUTION FOR NSPIN=1 (I(UP)=I(DOWN), ADET(UP)=ADET(DOWN))    **
!     ** TOTAL = 2 * I * |ADET|^4                                             **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: SPEC,SPECARR,RTASK,SETTINGS,OVL,OVLARR,NKPTG,NSPING
      IMPLICIT NONE
      INTEGER(4) :: NTASKS,THISTASK
      INTEGER(4) :: ISPEC
      INTEGER(4) :: IKPT
      INTEGER(4) :: ISPIN
      INTEGER(4) :: ISPINOPPOSITE
!     **************************************************************************
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      IF(THISTASK.NE.RTASK) RETURN
                          CALL TRACE$PUSH('RIXS$SPINCONV')
      DO ISPEC=1,SETTINGS%NSPEC
        SPEC=>SPECARR(ISPEC)
        ALLOCATE(SPEC%RIXSCONV(NKPTG,SETTINGS%NE,3))
        SPEC%RIXSCONV=0.D0
        DO IKPT=1,NKPTG
          DO ISPIN=1,NSPING
!           NSPIN=1: BOTH SPIN CHANNELS ARE EQUAL AND TOTAL IS TWICE THE VALUE
            IF(NSPING.EQ.1) THEN
              OVL=>OVLARR(IKPT,ISPIN)
              SPEC%RIXSCONV(IKPT,:,1)=SPEC%RIXSCONV(IKPT,:,1)+ &
     &                        2.D0*SPEC%RIXS(:,IKPT,ISPIN)*ABS(OVL%ADET)**4
              SPEC%RIXSCONV(IKPT,:,2)=0.5D0*SPEC%RIXSCONV(IKPT,:,1)
              SPEC%RIXSCONV(IKPT,:,3)=0.5D0*SPEC%RIXSCONV(IKPT,:,1)
            ELSE
!             NSPIN=2: UP=I(UP)*|ADET(DOWN)|^2, DOWN=I(DOWN)*|ADET(UP)|^2
!                      TOTAL=UP+DOWN
              ISPINOPPOSITE=MOD(ISPIN,2)+1
              OVL=>OVLARR(IKPT,ISPINOPPOSITE)
!             ISPIN=1 -> ISPINOPPOSITE=2, ISPIN=2 -> ISPINOPPOSITE=1
              SPEC%RIXSCONV(IKPT,:,ISPIN+1)=SPEC%RIXSCONV(IKPT,:,ISPIN+1)+ &
     &                             SPEC%RIXS(:,IKPT,ISPIN)*ABS(OVL%ADET)**4
              SPEC%RIXSCONV(IKPT,:,1)=SPEC%RIXSCONV(IKPT,:,1)+ &
     &                             SPEC%RIXS(:,IKPT,ISPIN)*ABS(OVL%ADET)**4
            END IF
          ENDDO
        ENDDO
      ENDDO
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE RIXS$SPINCONV