! TODO: ==  OPEN QUESTIONS  ====================================================
! WHAT HAPPENS FOR DIFFERENT AMOUNT OF BANDS AT DIFFERENT K-POINTS?
! CAN STORAGE BE HANDLED MORE EFFICIENTLY?
! BETTER CONTROL OF IO/FILES
! POLARIZATION SHOULD ALTERNATIVELY BE SET IN XYZ COORDINATES
! 
!     ...1.........2.........3.........4.........5.........6.........7.........8
      MODULE XCNTL_MODULE  ! MARK: XCNTL_MODULE
!     **************************************************************************
!     ** XCNTL MODULE FOR PAW XRAY TOOL                                       **
!     **************************************************************************
        USE LINKEDLIST_MODULE, ONLY: LL_TYPE
        TYPE(LL_TYPE) :: LL_CNTL
        LOGICAL(4) :: TOVERLAP=.FALSE. ! OVERLAP INPUT FILE PRESENT
        CHARACTER(256) :: OVERLAPFILE ! FILENAME FOR OVERLAP INPUT FILE
        LOGICAL(4) :: ADET
        LOGICAL(4) :: BASISWGHT
        LOGICAL(4) :: NORMALIZE
        LOGICAL(4) :: MOMENTUMTRANSFER
        SAVE
      END MODULE XCNTL_MODULE
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      MODULE KSMAP_MODULE  ! MARK: KSMAP_MODULE
!     **************************************************************************
!     ** KSMAP MODULE FOR PAW XRAY TOOL                                       **
!     ** CONTROLS THE PARALLELIZATION OF K-POINTS AND SPINS                   **
!     **************************************************************************
      LOGICAL(4) :: INITIALIZED=.FALSE. ! INITIALIZED
      INTEGER(4) :: NKPTG  ! #(KPOINTS TOTAL)
      INTEGER(4) :: NSPING ! #(SPINS TOTAL)
      INTEGER(4) :: RTASK  ! TASK RESPONSIBLE FOR READ/WRITE
      INTEGER(4), ALLOCATABLE :: KSMAP(:,:) ! (NKPT,NSPIN) K-POINT AND SPIN RESPONSIBILITY OF TASKS
      END MODULE KSMAP_MODULE
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      MODULE SIMULATION_MODULE  ! MARK: SIMULATION_MODULE
!     **************************************************************************
!     ** SIMULATION MODULE FOR PAW XRAY TOOL                                  **
!     **************************************************************************
      TYPE SIMULATION_TYPE
      CHARACTER(6) :: ID ! SIMULATION ID
      LOGICAL(4) :: INITIALIZED=.FALSE. ! INITIALIZED
      CHARACTER(256) :: FILE ! FILENAME                                        X
      INTEGER(4) :: NAT ! #(ATOMS)
      INTEGER(4) :: NSP ! #(SETUPS)
      INTEGER(4) :: NKPT ! #(KPOINTS) NUMBER OF IRREDUCIBLE K-POINTS
      INTEGER(4) :: NKPTTOT ! #(KPOINTS TOTAL) NUMBER OF ALL K-POINTS
      INTEGER(4) :: NSPIN ! #(SPINS)
      INTEGER(4) :: NDIM ! #(DIMENSIONS)
      INTEGER(4) :: NPRO ! #(PROJECTIONS)
      INTEGER(4) :: LNXX
      CHARACTER(6) :: FLAG
      INTEGER(4), ALLOCATABLE :: LMNX(:) ! (NSP)                               X
      INTEGER(4), ALLOCATABLE :: LNX(:) ! (NSP)                                X
      INTEGER(4), ALLOCATABLE :: LOX(:,:) ! (LNXX,NSP)                         X
      INTEGER(4), ALLOCATABLE :: MAP(:,:) ! (NAT,LNXX) INDEX-1 OF ATOM AND LN  X
      LOGICAL(4) :: TINV ! INVERSION SYMMETRY
      LOGICAL(4), ALLOCATABLE :: TINVARR(:) ! (NKPT) INVERSION SYMMETRY FOR EACH IRR. K-POINT
      ! IF TRUE: NO K POINT -K NEEDS TO BE CALCULATED
      ! IF FALSE: -K POINT NEEDS TO BE CALCULATED
      
      INTEGER(4) :: NKDIV(3) ! K-POINT DIVISIONS
      INTEGER(4) :: ISHIFT(3) ! K-POINT SHIFTS
      REAL(8) :: RNTOT
      REAL(8) :: NEL
      REAL(8) :: ETOT=HUGE(1.D0)  ! TOTAL ENERGY
      REAL(8) :: EDFT=HUGE(1.D0)  ! TOTAL DFT ENERGY
      REAL(8) :: ECORE=HUGE(1.D0)  ! TOTAL CORE ENERGY
      INTEGER(4) :: SPACEGROUP !                                               X
      LOGICAL(4) :: TSHIFT
      REAL(8) :: RBAS(3,3) ! BASIS VECTORS
      REAL(8) :: VCELL=-HUGE(1.D0) ! CELL VOLUME
      REAL(8), ALLOCATABLE :: R(:,:) ! (3,NAT) ATOMIC POSITIONS
      CHARACTER(16), ALLOCATABLE :: ATOMID(:) ! (NAT) ATOM IDENTIFIERS
      INTEGER(4), ALLOCATABLE :: ISPECIES(:) ! (NAT) SPECIES INDEX
      REAL(8), ALLOCATABLE :: XK(:,:) ! (3,NKPT) K-POINTS IN REL. COORD.
      REAL(8), ALLOCATABLE :: WKPT(:) ! (NKPT) K-POINT WEIGHTS
      ! COMPLEX(8), ALLOCATABLE :: DENMAT(:,:,:,:) ! (LMNXX,LMNXX,NDIM,NAT) DENSITY MATRIX

      INTEGER(4), ALLOCATABLE :: TOIRRKPT(:) ! (NKPTTOT) MAPPING OF TOTAL KPTS TO IRR. KPT
      LOGICAL(4), ALLOCATABLE :: TIRRKPT(:) ! (NKPTTOT) KPT IS IRREDUCIBLE
      INTEGER(4), ALLOCATABLE :: TOTOTKPT(:) ! (NKPT) MAPPING OF IRR. KPTS TO TOTAL KPT
      END TYPE SIMULATION_TYPE
      
      INTEGER(4), ALLOCATABLE :: ATOMMAP(:) 
      ! (NAT) ATOM INDEX MAP GROUND->EXCITE
      REAL(8), ALLOCATABLE :: S(:,:,:) 
      ! (NAT,LNXX1,LNXX2) ATOMIC OVERLAP MATRIX                                X
      TYPE(SIMULATION_TYPE), TARGET :: GROUND ! GROUND STATE SIMULATION (1)
      TYPE(SIMULATION_TYPE), TARGET :: EXCITE ! EXCITED STATE SIMULATION (2)
      TYPE(SIMULATION_TYPE), POINTER :: THIS ! POINTER TO CURRENT SIMULATION
      LOGICAL(4), SAVE :: SELECTED=.FALSE. ! SIMULATION SELECTED
      END MODULE SIMULATION_MODULE
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      MODULE STATE_MODULE  ! MARK: STATE_MODULE
!     **************************************************************************
!     ** STATE MODULE FOR PAW XRAY TOOL                                       **
!     **************************************************************************
      ! WARNING: WHY ARE POINTERS USED HERE?
      TYPE STATE_TYPE
      INTEGER(4)          :: NB=-HUGE(1) ! #(STATES)
      REAL(8), ALLOCATABLE :: EIG(:) ! (NB) EIGENVALUES
      REAL(8), ALLOCATABLE :: OCC(:) ! (NB) OCCUPATIONS
      INTEGER(4)          :: NOCC=-HUGE(1) ! #(OCCUPIED STATES)
      COMPLEX(8), ALLOCATABLE :: PROJ(:,:,:) ! (NDIM,NB,NPRO) PROJECTIONS      X
      END TYPE STATE_TYPE
      
      INTEGER(4) :: NKPTG
      INTEGER(4) :: NSPING
      INTEGER(4) :: NDIM
      INTEGER(4) :: NPRO
      ! IF OCCUPATION > OCCPERCENT*MAXOCC THEN OCCUPIED 
      ! DEACTIVATED IF EFERMI GIVEN, MAXOCC=2.0/1.0 FOR NSPIN=1/2 
      REAL(8), PARAMETER :: OCCPERCENT=0.5D0
      LOGICAL(4) :: INITIALIZED=.FALSE. ! INITIALIZED
      TYPE(STATE_TYPE), POINTER :: GROUND(:,:) ! (NKPT,NSPIN) GROUND STATE
      TYPE(STATE_TYPE), POINTER :: EXCITE(:,:) ! (NKPT,NSPIN) EXCITED STATE
      TYPE(STATE_TYPE), POINTER :: THIS(:,:) ! POINTER TO CURRENT STATE 
      LOGICAL(4), SAVE :: SELECTED=.FALSE. ! STATE SELECTED
      END MODULE STATE_MODULE
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      MODULE XSETUP_MODULE  ! MARK: XSETUP_MODULE
!     **************************************************************************
!     ** XSETUP MODULE FOR PAW XRAY TOOL                                      **
!     ** NOT AVAILABLE IF START FROM OVERLAP FILE                             **
!     **************************************************************************
      TYPE XSETUP_TYPE
      INTEGER(4) :: GID ! GRID ID FOR RADIAL MESH
      REAL(8) :: ECORE ! CORE ENERGY
      INTEGER(4) :: LNXX
      INTEGER(4) :: LNX
      INTEGER(4), ALLOCATABLE :: L(:) ! (LNXX)
      REAL(8), ALLOCATABLE :: PSPHI(:,:) ! PSEUDO PARTIAL WAVE
      REAL(8), ALLOCATABLE :: AEPHI(:,:) ! AE PARTIAL WAVE
      INTEGER(4) :: NBATOM ! #(ATOMIC WAVE FUNCTIONS)
      INTEGER(4), ALLOCATABLE :: LATOM(:) ! (NBATOM) L QUANTUM NUMBER
      REAL(8), ALLOCATABLE :: AEPSI(:,:) ! (NR,NBATOM) AE ATOMIC WAVE FUNCTION
      END TYPE XSETUP_TYPE

      INTEGER(4) :: NSPGROUND
      TYPE(XSETUP_TYPE), POINTER :: GROUND(:) ! GROUND STATE SETUPS
      INTEGER(4) :: NSPEXCITE
      TYPE(XSETUP_TYPE), POINTER :: EXCITE(:) ! EXCITED STATE SETUPS
      TYPE(XSETUP_TYPE), POINTER :: THIS(:) ! POINTER TO CURRENT SETUP ARRAY
      INTEGER(4) :: THISNSP
      LOGICAL(4), SAVE :: SELECTED=.FALSE. ! SETUP SELECTED
      END MODULE XSETUP_MODULE
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      MODULE OVERLAP_MODULE  ! MARK: OVERLAP_MODULE
!     **************************************************************************
!     ** OVERLAP MODULE FOR PAW XRAY TOOL                                     **
!     **************************************************************************
      TYPE OVERLAP_TYPE
      INTEGER(4) :: NB1=-1 ! #(BANDS IN SIMULATION 1)
      INTEGER(4) :: NB2=-1 ! #(BANDS IN SIMULATION 2)
      INTEGER(4) :: NOCC=-1 ! #(OCCUPIED BANDS)
      COMPLEX(8), ALLOCATABLE :: PW(:,:) ! (NB2,NB1) PLANE WAVE OVERLAP MATRIX
      COMPLEX(8), ALLOCATABLE :: AUG(:,:) ! (NB2,NB1) AUGMENTATION OVERLAP MATRIX
      LOGICAL(4) :: TOVERLAP=.FALSE. ! OVERLAP CALCULATED
      ! IT IS CHECKED THAT NOCC1=NOCC2
      ! OVERLAP MATRIX
      ! | A | B |
      ! |---+---|
      ! | C | D |
      COMPLEX(8), ALLOCATABLE :: A(:,:) ! (NOCC,NOCC)
      COMPLEX(8), ALLOCATABLE :: B(:,:) ! (NOCC,NB1-NOCC)
      COMPLEX(8), ALLOCATABLE :: C(:,:) ! (NB2-NOCC,NOCC)
      COMPLEX(8), ALLOCATABLE :: D(:,:) ! (NB2-NOCC,NB1-NOCC)
      ! AINV=A^(-1)
      COMPLEX(8), ALLOCATABLE :: AINV(:,:) ! (NOCC,NOCC)
      COMPLEX(8) :: ADET ! DETERMINANT OF A
      COMPLEX(8), ALLOCATABLE :: DIPOLE(:,:) ! (3,NB2) DIPOLE MATRIX ELEMENTS
      END TYPE OVERLAP_TYPE
      
      TYPE(OVERLAP_TYPE), ALLOCATABLE, TARGET :: OVLARR(:,:) ! (NKPT,NSPIN) OVERLAP ARRAYS
      TYPE(OVERLAP_TYPE), POINTER :: THIS ! POINTER TO CURRENT OVERLAP
      INTEGER(4) :: NKPTG  ! #(KPOINTS TOTAL)
      INTEGER(4) :: NSPING ! #(SPINS TOTAL)
      REAL(8) :: ADETSUM ! SUM_K  |ADETUP|^2|ADETDOWN|^2
      LOGICAL(4), SAVE :: SELECTED=.FALSE. ! OVERLAP SELECTED
      LOGICAL(4) :: INITIALIZED=.FALSE. ! INITIALIZED
      END MODULE OVERLAP_MODULE
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      MODULE SETTINGS_MODULE  ! MARK: SETTINGS_MODULE
!     **************************************************************************
!     ** SETTINGS MODULE FOR PAW XRAY TOOL                                    **
!     **************************************************************************
      CHARACTER(32) :: COREHOLE ! ATOM ID OF CORE HOLE
      INTEGER(4) :: IATOM=-HUGE(1) ! ATOM INDEX WITH CORE HOLE IN SIM1 (FOR SIM2 USE ATOMMAP)
      INTEGER(4) :: NCORE ! N QUANTUM NUMBER OF CORE HOLE
      INTEGER(4) :: LCORE ! L QUANTUM NUMBER OF CORE HOLE
      END MODULE SETTINGS_MODULE
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      MODULE XAS_MODULE  ! MARK: XAS_MODULE
!     **************************************************************************
!     ** XAS MODULE FOR PAW XRAY TOOL                                         **
!     **************************************************************************
      TYPE XAS_SPEC_TYPE
      CHARACTER(256) :: FILE ! FILENAME FOR SPECTRUM
      REAL(8) :: NORMAL(3) ! NORMAL VECTOR OF SURFACE
      REAL(8) :: KDIR(3) ! DIRECTION OF INCIDENT RAY
      COMPLEX(8) :: POL(2) ! POLARIZATION VECTOR
      COMPLEX(8) :: POLXYZ(3) ! POLARIZATION VECTOR IN CARTESIAN COORDINATES
      LOGICAL(4) :: TPOLXYZ ! CHECK IF POLXYZ IS SET
      REAL(8) :: EBROAD ! GAUSSIAN BROADENING FOR XAS SPECTRUM (REPLACES DELTA FUNCTION)
      CHARACTER(1) :: BROADMODE ! BROADENING MODE: 'G' GAUSSIAN, 'L' LORENTZIAN,
                                ! 'N' NONE
      
      REAL(8), ALLOCATABLE :: E(:) ! (NE) ENERGY GRID FOR SPECTRUM
      REAL(8), ALLOCATABLE :: SPECTRUM(:,:,:) ! (NKPT,NSPIN,NE) SPECTRUM
      ! ERROR: FORMAT FOR RAW SPECTRUM FAILES IF NB2-NOCC IS NOT THE SAME FOR ALL KPOINTS
      REAL(8), ALLOCATABLE :: ERAW(:,:,:) ! (NKPT,NSPIN,NB2-NOCC) RAW ENERGY
      REAL(8), ALLOCATABLE :: SPECTRUMRAW(:,:,:) ! (NKPT,NSPIN,NB2-NOCC) RAW SPECTRUM
      END TYPE XAS_SPEC_TYPE

      LOGICAL(4) :: TACTIVE=.FALSE. ! XAS ACTIVE
      LOGICAL(4) :: TINITIALIZE=.FALSE.
      LOGICAL(4) :: SINGLEPARTICLE ! SINGLE PARTICLE XAS
      INTEGER(4) :: NSPEC ! NUMBER OF SPECTRA FOR XAS
      REAL(8) :: EMIN=-HUGE(1.D0) ! MINIMUM ENERGY FOR XAS
      REAL(8) :: EMAX=HUGE(1.D0) ! MAXIMUM ENERGY FOR XAS
      REAL(8) :: DE ! ENERGY STEP FOR XAS SPECTRUM
      INTEGER(4) :: NE ! NUMBER OF ENERGY POINTS FOR XAS SPECTRUM

      TYPE(XAS_SPEC_TYPE), ALLOCATABLE, TARGET :: SPECTRA(:) ! (NSPEC) SPECTRA
      TYPE(XAS_SPEC_TYPE), POINTER :: THIS ! POINTER TO CURRENT SPECTRUM
      LOGICAL(4), SAVE :: SELECTED=.FALSE. ! SPECTRUM SELECTED
      END MODULE XAS_MODULE
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      MODULE RIXS_MODULE  ! MARK: RIXS_MODULE
!     **************************************************************************
!     ** RIXS MODULE FOR PAW XRAY TOOL                                        **
!     **************************************************************************
      TYPE ONEAMPL_CONTAINER
      COMPLEX(8), ALLOCATABLE :: XY(:,:) ! (NB1-NOCC,NOCC) AMPLITUDE CONTAINER
      END TYPE ONEAMPL_CONTAINER
      TYPE TWOAMPL_CONTAINER
      COMPLEX(8), ALLOCATABLE :: X(:) ! (NB1-NOCC) AMPLITUDE CONTAINER
      COMPLEX(8), ALLOCATABLE :: Y(:) ! (NOCC) AMPLITUDE CONTAINER
      END TYPE TWOAMPL_CONTAINER
      TYPE RIXS_SPEC_TYPE
      CHARACTER(256) :: FILE ! FILENAME
      REAL(8) :: NORMAL(3) ! NORMAL VECTOR OF SURFACE
      ! INCOMING LIGHT
      REAL(8) :: KDIRI(3) ! DIRECTION OF K VECTOR
      COMPLEX(8) :: POLI(2) ! POLARIZATION VECTOR
      COMPLEX(8) :: POLXYZI(3) ! POLARIZATION VECTOR IN CARTESIAN COORDINATES
      LOGICAL(4) :: TPOLXYZI=.FALSE. ! CHECK IF POLIXYZ IS SET
      ! OUTGOING LIGHT
      REAL(8) :: KDIRO(3) ! DIRECTION OF K VECTOR
      COMPLEX(8) :: POLO(2) ! POLARIZATION VECTOR
      COMPLEX(8) :: POLXYZO(3) ! POLARIZATION VECTOR IN CARTESIAN COORDINATES
      LOGICAL(4) :: TPOLXYZO ! CHECK IF POLXYZO IS SET

      REAL(8) :: ELIGHT=-HUGE(1.D0) ! ENERGY OF INCIDENT LIGHT
      REAL(8) :: GAMMA ! LIFETIME BROADENING FOR RIXS SPECTRUM

      ! MIGHT NOT BE NECESSARY IF ONLY AMPLITUDE IS CALCULATED AND WRITTEN TO FILE
      REAL(8) :: EBROAD ! GAUSSIAN BROADENING FOR XAS SPECTRUM (REPLACES DELTA FUNCTION)
      CHARACTER(1) :: BROADMODE ! BROADENING MODE: 'G' GAUSSIAN, 'L' LORENTZIAN,
                                ! 'N' NONE

      REAL(8) :: KI(3) ! K VECTOR OF INCIDENT LIGHT
      REAL(8) :: KO(3) ! K VECTOR OF OUTGOING LIGHT
      REAL(8) :: Q(3) ! MOMENTUM TRANSFER
      ! RELATIVE COORDINATES
      REAL(8) :: XKI(3) ! K VECTOR OF INCIDENT LIGHT IN RELATIVE COORDINATES
      REAL(8) :: XKO(3) ! K VECTOR OF OUTGOING LIGHT IN RELATIVE COORDINATES
      REAL(8) :: XQ(3) ! MOMENTUM TRANSFER IN RELATIVE COORDINATES
      ! APPROXIMATE MOMENTUM TRANSFER FROM AVAILABLE K-POINTS
      REAL(8) :: QAPPROX(3) ! APPROXIMATE MOMENTUM TRANSFER
      REAL(8) :: XQAPPROX(3) ! APPROXIMATE MOMENTUM TRANSFER IN RELATIVE COORDINATES
      REAL(8) :: QERROR ! DISTANCE BETWEEN APPROXIMATE AND EXACT MOMENTUM TRANSFER
      
      LOGICAL(4) :: TKPTSHIFT ! CHECK IF KPT SHIFT IS USED
      INTEGER(4), ALLOCATABLE :: JOFIKPT(:) ! (NKPTTOT) MAPPING OF TOTAL KPTS TO SHIFTED TOTAL KPT
      TYPE(ONEAMPL_CONTAINER), ALLOCATABLE :: ONEAMPL(:,:) ! (NKPT,NSPIN) AMPLITUDE CONTAINER
      TYPE(TWOAMPL_CONTAINER), ALLOCATABLE :: TWOAMPL(:,:) ! (NKPT,NSPIN) AMPLITUDE CONTAINER
      END TYPE RIXS_SPEC_TYPE

      LOGICAL(4) :: TACTIVE=.FALSE. ! RIXS ACTIVE
      LOGICAL(4) :: TINITIALIZE=.FALSE.
      LOGICAL(4) :: TONEK=.FALSE.
      LOGICAL(4) :: TTWOK=.FALSE.
      INTEGER(4) :: NSPEC ! NUMBER OF SPECTRA FOR RIXS


      ! ENERGY LOSS FOR WHICH FINAL STATES ARE CONSIDERED
      REAL(8) :: EMIN=-HUGE(1.D0) ! MINIMUM ENERGY LOSS FOR RIXS
      REAL(8) :: EMAX=HUGE(1.D0) ! MAXIMUM ENERGY LOSS FOR RIXS

      ! MIGHT NOT BE NECESSARY IF ONLY AMPLITUDE IS CALCULATED AND WRITTEN TO FILE
      REAL(8) :: DE ! ENERGY STEP FOR RIXS SPECTRUM
      INTEGER(4) :: NE ! NUMBER OF ENERGY POINTS FOR RIXS SPECTRUM

      TYPE(RIXS_SPEC_TYPE), ALLOCATABLE, TARGET :: SPECTRA(:) ! (NSPEC) SPECTRA
      TYPE(RIXS_SPEC_TYPE), POINTER :: THIS ! POINTER TO CURRENT SPECTRUM
      LOGICAL(4), SAVE :: SELECTED=.FALSE. ! SPECTRUM SELECTED
      END MODULE RIXS_MODULE
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      MODULE SHARED_DATA_MODULE  ! MARK: SHARED_DATA_MODULE
!     **************************************************************************
!     ** SHARED DATA MODULE FOR PAW XRAY TOOL                                 **
!     ** CONTAINS DATA SHARED BETWEEN XAS AND RIXS CALCULATIONS               **
!     **************************************************************************
      TYPE AMPL_CONTAINER
      COMPLEX(8), ALLOCATABLE :: AMPL(:,:) ! (3,NB2-NOCC)
      END TYPE AMPL_CONTAINER

      ! ABSORPTION AMPLITUDE REQUIRED BY XAS AND RIXS
      TYPE(AMPL_CONTAINER), ALLOCATABLE :: ABSORB(:,:) ! (NKPT,NSPIN)

      REAL(8), ALLOCATABLE :: ADETPROD(:,:) ! (NKPT,NSPIN)

      END MODULE SHARED_DATA_MODULE
!
!     ==========================================================================
!     ==                    PROGRAM PAW_XRAY                                  ==
!     ==========================================================================
      PROGRAM PAW_XRAY  ! MARK: PAW_XRAY
      USE XCNTL_MODULE, ONLY: LL_CNTL
      USE LINKEDLIST_MODULE
      USE CLOCK_MODULE
      IMPLICIT NONE
      INTEGER(4) :: NFIL
      CHARACTER(32) :: DATIME
      INTEGER(4) :: NTASKS
      INTEGER(4) :: THISTASK
      LOGICAL(4) :: TOVERLAP
!     **************************************************************************
      CALL MPE$INIT
                          CALL TRACE$PUSH('PAW_XRAY')
                          CALL TIMING$START
      CALL MPE$QUERY('~',NTASKS,THISTASK)
!     INITIALIZE FILES
      CALL INITIALIZEFILEHANDLER
      CALL FILEHANDLER$UNIT('PROT',NFIL)
      IF(THISTASK.EQ.1) THEN
        WRITE(NFIL,FMT='()')
        CALL CPPAW_WRITEVERSION(NFIL)
        CALL CLOCK$NOW(DATIME)        
        WRITE(NFIL,FMT='(80("="))')
        WRITE(NFIL,FMT='(80("="),T15,"  PROGRAM STARTED ",A32,"  ")')DATIME
        WRITE(NFIL,FMT='(80("="))')
      END IF
!     ==========================================================================
!     == READ XRAY CONTROL FILE                                               ==
!     ==========================================================================
                          CALL TIMING$CLOCKON('XCNTL')
      CALL FILEHANDLER$UNIT('XCNTL',NFIL)
      CALL XCNTL$READ(NFIL)
      CALL XCNTL$FILES
      CALL XCNTL$COREHOLE
      CALL XCNTL$XAS
      CALL XCNTL$RIXS
      CALL TIMING$CLOCKOFF('XCNTL')


      CALL FILEHANDLER$UNIT('PROT',NFIL)
      CALL LINKEDLIST$SELECT(LL_CNTL,'~')
      ! IF(THISTASK.EQ.1) CALL LINKEDLIST$REPORT(LL_CNTL,NFIL)
      IF(THISTASK.EQ.1) CALL LINKEDLIST$REPORT_UNUSED(LL_CNTL,NFIL)

      ! READ SIMULATION DATA
      CALL XRAY$READSIMULATIONS
      ! READ OVERLAP FILE
      CALL XRAY$READOVERLAP

      ! DETERMINE K VECTORS AND MOMENTUM TRANSFER IN RIXS_MODULE
      CALL RIXS$KVECTORS

      CALL TIMING$CLOCKON('REPORTS')
      CALL KSMAP$REPORT(NFIL)
      CALL SIMULATION$SELECT('GROUND')
      CALL SIMULATION$REPORT(NFIL)
      CALL SIMULATION$UNSELECT
      CALL XSETUP$SELECT('GROUND')
      CALL XSETUP$REPORT(NFIL)
      CALL XSETUP$UNSELECT
      CALL STATE$SELECT('GROUND')
      CALL STATE$REPORT(NFIL)
      ! CALL STATE$ENERGYWRITE(NFIL)
      CALL STATE$UNSELECT

      CALL SIMULATION$SELECT('EXCITE')
      CALL SIMULATION$REPORT(NFIL)
      CALL SIMULATION$UNSELECT
      CALL XSETUP$SELECT('EXCITE')
      CALL XSETUP$REPORT(NFIL)
      CALL XSETUP$UNSELECT
      CALL STATE$SELECT('EXCITE')
      CALL STATE$REPORT(NFIL)
      ! CALL STATE$ENERGYWRITE(NFIL)
      CALL STATE$UNSELECT

      CALL SETTINGS$REPORT(NFIL)

      CALL XAS$REPORT(NFIL)

      CALL RIXS$REPORT(NFIL)

      CALL TIMING$CLOCKOFF('REPORTS')

      CALL XRAY$OVERLAP

      CALL OVERLAP$REPORT(NFIL)

      CALL XRAY$WRITEOVERLAP
 
      ! FREE UP MEMORY CONTAINING PROJECTIONS
      CALL STATE$DEALLOCATEPROJ

      ! ========================================================================
      ! == XAS                                                                ==
      ! ========================================================================
      CALL XAS$CALCULATE

      CALL XAS$OUTPUT
      ! FREE UP MEMORY CONTAINING XAS SPECTRA
      CALL XAS$DEALLOCATESPECTRA

      ! ========================================================================
      ! == RIXS                                                               ==
      ! ========================================================================
      CALL RIXS$CALCULATE

      CALL RIXS$OUTPUT

      CALL SHARED_DATA$REPORT(NFIL)



                          CALL TIMING$PRINT('~',NFIL)
      CALL MPE$CLOCKREPORT(NFIL)
      IF(THISTASK.EQ.1) THEN
        CALL CLOCK$NOW(DATIME)
        WRITE(NFIL,FMT='(80("="))')
        WRITE(NFIL,FMT='(80("="),T15,"  PROGRAM FINISHED ",A32,"  ")')DATIME
        WRITE(NFIL,FMT='(80("="))')
      END IF
                          CALL TRACE$POP
      CALL ERROR$NORMALSTOP
      STOP

                          CALL TRACE$POP
      END PROGRAM PAW_XRAY

!      
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE INITIALIZEFILEHANDLER
!     **************************************************************************
      USE STRINGS_MODULE
      IMPLICIT NONE
      CHARACTER(256) :: ROOTNAME
      CHARACTER(256) :: CNTLNAME
      INTEGER(4)     :: ISVAR
      INTEGER(4)     :: NARGS
      ! **************************************************************************
                          CALL TRACE$PUSH('INITIALIZEFILEHANDLER')
      NARGS=COMMAND_ARGUMENT_COUNT()
      IF(NARGS.LT.1) THEN
        CALL ERROR$MSG('ARGUMENT LIST OF EXECUTABLE IS EMPTY')
        CALL ERROR$MSG('THE CONTROL FILE OF THE XRAY TOOL IS MANDATORY')
        CALL ERROR$STOP('INITIALIZEFILEANDLER')
      END IF
      CALL GET_COMMAND_ARGUMENT(1,CNTLNAME)
      ISVAR=INDEX(CNTLNAME,-'.XCNTL',BACK=.TRUE.)
      IF(ISVAR.NE.0) THEN
        ROOTNAME=CNTLNAME(1:ISVAR-1)
      ELSE
        ROOTNAME=' '
      END IF
      CALL FILEHANDLER$SETROOT(ROOTNAME)
      CALL STANDARDFILES
      CALL FILEHANDLER$SETFILE('XCNTL',.FALSE.,CNTLNAME)
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE INITIALIZEFILEHANDLER
!
!      ..1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE STANDARDFILES
!     **************************************************************************
      USE STRINGS_MODULE
      IMPLICIT NONE
      CHARACTER(32)        :: ID
      INTEGER(4)          :: THISTASK
      INTEGER(4)          :: NTASKS
      ! **************************************************************************
                                   CALL TRACE$PUSH('STANDARDFILES')
      ! ========================================================================
      ! == SET STANDARD FILENAMES                                             ==
      ! ========================================================================
      ! ==  ERROR FILE =========================================================
      ID=+'ERR'
      CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.XERR')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','REPLACE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','APPEND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','WRITE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')
      ! ==  PROTOCOL FILE ======================================================
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      ID=+'PROT'
      IF(THISTASK.GT.1) THEN
        CALL FILEHANDLER$SETFILE(ID,.FALSE.,-'/DEV/NULL')
      ELSE
        CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.XPROT')
      END IF
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','REPLACE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','APPEND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','WRITE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')
      ! ==  CONTROL FILE  == ===================================================
      ID=+'XCNTL'
      CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.XCNTL')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','OLD')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','REWIND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','READ')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')
                                   CALL TRACE$POP
      RETURN
      END SUBROUTINE STANDARDFILES
!

!     ==========================================================================
!     ==========================================================================
!     ==                    XCNTL MODULE FUNCTIONS                            ==
!     ==========================================================================
!     ==========================================================================
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XCNTL$READ(NFIL)  ! MARK: XCNTL$READ
!     **************************************************************************
!     **                                                                      **
!     **************************************************************************
      USE XCNTL_MODULE, ONLY: LL_CNTL,ADET,BASISWGHT,NORMALIZE,MOMENTUMTRANSFER
      USE LINKEDLIST_MODULE
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: NFIL
      LOGICAL(4) :: TCHK
                          CALL TRACE$PUSH('XCNTL$READ')
      CALL LINKEDLIST$NEW(LL_CNTL)
      CALL LINKEDLIST$READ(LL_CNTL,NFIL,'~')
      CALL LINKEDLIST$SELECT(LL_CNTL,'~')
      CALL LINKEDLIST$MARK(LL_CNTL,1)
      CALL LINKEDLIST$EXISTL(LL_CNTL,'XCNTL',1,TCHK)
      IF(.NOT.TCHK) THEN
        CALL ERROR$MSG('CONTROL FILE DOES NOT CONTAIN !XCNTL BLOCK')
        CALL ERROR$STOP('XCNTL$READ')
      END IF
      ! CHECK WETHER TO CALCULATE XAS OR RIXS
      CALL LINKEDLIST$SELECT(LL_CNTL,'XCNTL')
      CALL LINKEDLIST$EXISTL(LL_CNTL,'XAS',1,TCHK)
      CALL XAS$SETL4('ACTIVE',TCHK)
      CALL LINKEDLIST$EXISTL(LL_CNTL,'RIXS',1,TCHK)
      CALL RIXS$SETL4('ACTIVE',TCHK)
      ! CHECK WETHER TO PERFORM CALCULATION WITH ADET
      CALL LINKEDLIST$EXISTD(LL_CNTL,'ADET',1,TCHK)
      IF(TCHK) THEN
        CALL LINKEDLIST$GET(LL_CNTL,'ADET',1,ADET)
      ELSE
        ADET=.TRUE. ! DEFAULT IS TO CALCULATE USING ADET
      END IF
      ! CHECK WETHER TO USE BASIS WEIGHTING
      CALL LINKEDLIST$EXISTD(LL_CNTL,'BASISWEIGHT',1,TCHK)
      IF(TCHK) THEN
        CALL LINKEDLIST$GET(LL_CNTL,'BASISWEIGHT',1,BASISWGHT)
      ELSE
        BASISWGHT=.FALSE. ! DEFAULT IS TO NOT USE BASIS WEIGHTING
      END IF
      ! CHECK WETHER TO NORMALIZE OVERLAP
      CALL LINKEDLIST$EXISTD(LL_CNTL,'NORMALIZE',1,TCHK)
      IF(TCHK) THEN
        CALL LINKEDLIST$GET(LL_CNTL,'NORMALIZE',1,NORMALIZE)
      ELSE
        NORMALIZE=.FALSE. ! DEFAULT IS TO NOT NORMALIZE OVERLAP
      END IF
      ! CHECK WETHER TO CALCULATE MOMENTUM TRANSFER
      CALL LINKEDLIST$EXISTD(LL_CNTL,'MOMENTUMTRANSFER',1,TCHK)
      IF(TCHK) THEN
        CALL LINKEDLIST$GET(LL_CNTL,'MOMENTUMTRANSFER',1,MOMENTUMTRANSFER)
      ELSE
        MOMENTUMTRANSFER=.TRUE. ! DEFAULT IS TO CALCULATE MOMENTUM TRANSFER
      END IF
                          CALL TRACE$POP
      END SUBROUTINE XCNTL$READ
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XCNTL$FILES  ! MARK: XCNTL$FILES
!     **************************************************************************
!     ** READ FILES GROUND AND EXCITE OR RESTART FROM CNTL FILE               **
!     **************************************************************************
! TODO: REWORK INTO !FILES!FILE STRUCTURE 
!       WITH ID='GROUND', 'EXCITE', 'OVERLAP', 'PROT', 'OVERLAP_OUT'
      USE XCNTL_MODULE, ONLY: LL_CNTL,TOVERLAP,OVERLAPFILE
      USE LINKEDLIST_MODULE
      IMPLICIT NONE
      LOGICAL(4) :: TCHK
      LOGICAL(4) :: TCHK1
      LOGICAL(4) :: TCHK2
      LOGICAL(4) :: TCHK3
      CHARACTER(256) :: FILENAME
                          CALL TRACE$PUSH('XCNTL$FILES')
      CALL LINKEDLIST$SELECT(LL_CNTL,'~')
      CALL LINKEDLIST$SELECT(LL_CNTL,'XCNTL')
      CALL LINKEDLIST$EXISTL(LL_CNTL,'GROUND',1,TCHK1)
      CALL LINKEDLIST$EXISTL(LL_CNTL,'EXCITE',1,TCHK2)
      CALL LINKEDLIST$EXISTL(LL_CNTL,'OVERLAP',1,TCHK3)
      ! EITHER BOTH GROUND AND EXCITE OR RESTART NEED TO BE PRESENT AND ARE
      ! MUTUALLY EXCLUSIVE
      IF(TCHK1.AND.TCHK2.AND..NOT.TCHK3) THEN
        TOVERLAP=.FALSE.
      ELSE IF(.NOT.TCHK1.AND..NOT.TCHK2.AND.TCHK3) THEN
        TOVERLAP=.TRUE.
      ELSE
        CALL ERROR$MSG('CONTROL FILE MUST CONTAIN EITHER')
        CALL ERROR$MSG('BOTH !GROUND AND !EXCITE BLOCKS OR !OVERLAP BLOCK')
        CALL ERROR$MSG('BUT NOT BOTH AT THE SAME TIME')
        CALL ERROR$MSG('PROVIDED WERE:')
        CALL ERROR$L4VAL(' !GROUND: ',TCHK1)
        CALL ERROR$L4VAL(' !EXCITE: ',TCHK2)
        CALL ERROR$L4VAL(' !OVERLAP: ',TCHK3)
        CALL ERROR$STOP('XCNTL$FILES')
      END IF
      IF(.NOT.TOVERLAP) THEN
        ! READ GROUND STATE
        CALL LINKEDLIST$SELECT(LL_CNTL,'GROUND')
        CALL LINKEDLIST$EXISTD(LL_CNTL,'FILE',1,TCHK)
        IF(.NOT.TCHK) THEN
          CALL ERROR$MSG('!GROUND:FILE NOT FOUND')
          CALL ERROR$STOP('XCNTL$FILES')
        END IF
        CALL LINKEDLIST$GET(LL_CNTL,'FILE',1,FILENAME)
        CALL SIMULATION$SELECT('GROUND')
        CALL SIMULATION$SETCH('ID','GROUND')
        CALL SIMULATION$SETCH('FILE',TRIM(ADJUSTL(FILENAME)))

        CALL FILEHANDLER$SETFILE('GROUND',.FALSE.,TRIM(ADJUSTL(FILENAME)))
        CALL FILEHANDLER$SETSPECIFICATION('GROUND','STATUS','OLD')
        CALL FILEHANDLER$SETSPECIFICATION('GROUND','POSITION','REWIND')
        CALL FILEHANDLER$SETSPECIFICATION('GROUND','ACTION','READ')
        CALL FILEHANDLER$SETSPECIFICATION('GROUND','FORM','UNFORMATTED')

        CALL SIMULATION$UNSELECT
        CALL LINKEDLIST$SELECT(LL_CNTL,'..')

        ! READ EXCITED STATE
        CALL LINKEDLIST$SELECT(LL_CNTL,'EXCITE')
        CALL LINKEDLIST$EXISTD(LL_CNTL,'FILE',1,TCHK)
        IF(.NOT.TCHK) THEN
          CALL ERROR$MSG('!EXCITE:FILE NOT FOUND')
          CALL ERROR$STOP('XCNTL$FILES')
        END IF
        CALL LINKEDLIST$GET(LL_CNTL,'FILE',1,FILENAME)
        CALL SIMULATION$SELECT('EXCITE')
        CALL SIMULATION$SETCH('ID','EXCITE')
        CALL SIMULATION$SETCH('FILE',TRIM(ADJUSTL(FILENAME)))

        CALL FILEHANDLER$SETFILE('EXCITE',.FALSE.,TRIM(ADJUSTL(FILENAME)))
        CALL FILEHANDLER$SETSPECIFICATION('EXCITE','STATUS','OLD')
        CALL FILEHANDLER$SETSPECIFICATION('EXCITE','POSITION','REWIND')
        CALL FILEHANDLER$SETSPECIFICATION('EXCITE','ACTION','READ')
        CALL FILEHANDLER$SETSPECIFICATION('EXCITE','FORM','UNFORMATTED')

        CALL SIMULATION$UNSELECT
        CALL LINKEDLIST$SELECT(LL_CNTL,'..')
      END IF
      IF(TOVERLAP) THEN
        CALL LINKEDLIST$SELECT(LL_CNTL,'OVERLAP')
        CALL LINKEDLIST$EXISTD(LL_CNTL,'FILE',1,TCHK)
        IF(.NOT.TCHK) THEN
          CALL ERROR$MSG('!OVERLAP:FILE NOT FOUND')
          CALL ERROR$STOP('XCNTL$FILES')
        END IF
        CALL LINKEDLIST$GET(LL_CNTL,'FILE',1,FILENAME)
        OVERLAPFILE=TRIM(ADJUSTL(FILENAME))
      END IF
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE XCNTL$FILES
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XCNTL$COREHOLE  ! MARK: XCNTL$COREHOLE
!     **************************************************************************
!     ** READ !COREHOLE FROM CONTROL FILE                                     **
!     **************************************************************************
      USE XCNTL_MODULE, ONLY: LL_CNTL,TOVERLAP
      USE LINKEDLIST_MODULE
      IMPLICIT NONE
      LOGICAL(4) :: TCHK
      CHARACTER(32) :: ATOM
      INTEGER(4) :: NCORE
      INTEGER(4) :: LCORE
      IF(TOVERLAP) RETURN
                          CALL TRACE$PUSH('XCNTL$COREHOLE')
      CALL LINKEDLIST$SELECT(LL_CNTL,'~')
      CALL LINKEDLIST$SELECT(LL_CNTL,'XCNTL')
      CALL LINKEDLIST$EXISTL(LL_CNTL,'COREHOLE',1,TCHK)
      IF(.NOT.TCHK) THEN
        CALL ERROR$MSG('CONTROL FILE DOES NOT CONTAIN !COREHOLE BLOCK')
        CALL ERROR$STOP('XCNTL$COREHOLE')
      END IF
      CALL LINKEDLIST$SELECT(LL_CNTL,'COREHOLE')
      ! READ ATOM NAME
      CALL LINKEDLIST$EXISTD(LL_CNTL,'ATOM',1,TCHK)
      IF(.NOT.TCHK) THEN
        CALL ERROR$MSG('!COREHOLE:ATOM NOT FOUND')
        CALL ERROR$STOP('XCNTL$COREHOLE')
      END IF
      CALL LINKEDLIST$GET(LL_CNTL,'ATOM',1,ATOM)
      CALL SETTINGS$SETCH('COREHOLE',TRIM(ADJUSTL(ATOM)))
      ! READ N QUANTUM NUMBER
      CALL LINKEDLIST$EXISTD(LL_CNTL,'NCORE',1,TCHK)
      IF(.NOT.TCHK) THEN
        CALL ERROR$MSG('!COREHOLE:NCORE NOT FOUND')
        CALL ERROR$STOP('XCNTL$COREHOLE')
      END IF
      CALL LINKEDLIST$GET(LL_CNTL,'NCORE',1,NCORE)
      CALL SETTINGS$SETI4('NCORE',NCORE)
      ! READ L QUANTUM NUMBER
      CALL LINKEDLIST$EXISTD(LL_CNTL,'LCORE',1,TCHK)
      IF(.NOT.TCHK) THEN
        CALL ERROR$MSG('!COREHOLE:LCORE NOT FOUND')
        CALL ERROR$STOP('XCNTL$COREHOLE')
      END IF
      CALL LINKEDLIST$GET(LL_CNTL,'LCORE',1,LCORE)
      IF(LCORE.NE.0) THEN
        CALL ERROR$MSG('IMPLEMENTATION ONLY FOR S COREHOLES (LCORE=0)')
        CALL ERROR$I4VAL('LCORE',LCORE)
        CALL ERROR$STOP('XCNTL$COREHOLE')
      END IF
      CALL SETTINGS$SETI4('LCORE',LCORE)
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE XCNTL$COREHOLE
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XCNTL$XAS  ! MARK: XCNTL$XAS
!     **************************************************************************
!     ** READ !XCNTL!XAS FROM CONTROL FILE                                    **
!     **************************************************************************
      USE LINKEDLIST_MODULE
      USE XCNTL_MODULE, ONLY: LL_CNTL
      USE STRINGS_MODULE
      IMPLICIT NONE
      LOGICAL(4) :: TCHK
      LOGICAL(4) :: TCHK1
      LOGICAL(4) :: TCHK2
      LOGICAL(4) :: TCHK3
      CHARACTER(256) :: FILENAME
      INTEGER(4) :: NSPEC
      INTEGER(4) :: ISPEC
      ! DEFAULT SETTINGS
      REAL(8) :: EBROAD
      CHARACTER(1) :: BROADMODE
      REAL(8) :: EMIN
      REAL(8) :: EMAX
      REAL(8) :: DE
      
      REAL(8) :: NORMAL(3)
      LOGICAL(4) :: TNORMALDEF
      LOGICAL(4) :: TNORMAL

      REAL(8) :: KDIR(3)
      LOGICAL(4) :: TKDIRDEF
      LOGICAL(4) :: TKDIR

      COMPLEX(8) :: POL(2)
      REAL(8) :: REALPOL(4)
      LOGICAL(4) :: TPOLDEF
      LOGICAL(4) :: TPOL
      
      REAL(8) :: RVAR
      REAL(8) :: RVAR3(3)
      CHARACTER(1) :: CHVAR
      COMPLEX(8) :: CVAR2(2)
      REAL(8) :: EV
      ! ONLY READ IF XAS IS ACTIVE
      CALL XAS$GETL4('ACTIVE',TCHK)
      IF(.NOT.TCHK) RETURN
                          CALL TRACE$PUSH('XCNTL$XAS')
      CALL CONSTANTS('EV',EV)
      CALL LINKEDLIST$SELECT(LL_CNTL,'~')
      CALL LINKEDLIST$SELECT(LL_CNTL,'XCNTL')
      CALL LINKEDLIST$SELECT(LL_CNTL,'XAS')

      ! SINGLEPARTICLE
      CALL LINKEDLIST$EXISTD(LL_CNTL,'SINGLEPARTICLE',1,TCHK)
      IF(TCHK) THEN
        CALL LINKEDLIST$GET(LL_CNTL,'SINGLEPARTICLE',1,TCHK1)
        CALL XAS$SETL4('SINGLEPARTICLE',TCHK1)
      ELSE
        CALL XAS$SETL4('SINGLEPARTICLE',.FALSE.) ! DEFAULT
      END IF
      
      ! EMIN[EV]
      CALL LINKEDLIST$EXISTD(LL_CNTL,'EMIN[EV]',1,TCHK)
      IF(TCHK) THEN
        CALL LINKEDLIST$GET(LL_CNTL,'EMIN[EV]',1,EMIN)
        EMIN=EMIN*EV
      ELSE
        EMIN=-HUGE(1.D0) ! MINIMUM ENERGY NOT SET
      END IF
      CALL XAS$SETR8('EMIN',EMIN)

      ! EMAX[EV]
      CALL LINKEDLIST$EXISTD(LL_CNTL,'EMAX[EV]',1,TCHK)
      IF(TCHK) THEN
        CALL LINKEDLIST$GET(LL_CNTL,'EMAX[EV]',1,EMAX)
        EMAX=EMAX*EV
      ELSE
        EMAX=HUGE(1.D0) ! MAXIMUM ENERGY NOT SET
      END IF
      CALL XAS$SETR8('EMAX',EMAX)

      ! DE[EV]
      CALL LINKEDLIST$EXISTD(LL_CNTL,'DE[EV]',1,TCHK)
      IF(TCHK) THEN
        CALL LINKEDLIST$GET(LL_CNTL,'DE[EV]',1,DE)
        DE=DE*EV
      ELSE
        DE=1.D-2*EV
      END IF
      CALL XAS$SETR8('DE',DE)

      ! EBROAD[EV]
      CALL LINKEDLIST$EXISTD(LL_CNTL,'EBROAD[EV]',1,TCHK)
      IF(TCHK) THEN
        CALL LINKEDLIST$GET(LL_CNTL,'EBROAD[EV]',1,EBROAD)
        EBROAD=EBROAD*EV
      ELSE
        EBROAD=0.3D0*EV ! DEFAULT BROADENING
      END IF

      ! BROADMODE
      CALL LINKEDLIST$EXISTD(LL_CNTL,'BROADMODE',1,TCHK)
      IF(TCHK) THEN
        CALL LINKEDLIST$GET(LL_CNTL,'BROADMODE',1,BROADMODE)
        IF(BROADMODE.NE.+'G'.AND.BROADMODE.NE.+'L'.AND.BROADMODE.NE.+'N') THEN
          CALL ERROR$MSG('BROADMODE MUST BE G, L OR N')
          CALL ERROR$CHVAL('BROADMODE',BROADMODE)
          CALL ERROR$STOP('XCNTL$XAS')
        END IF
      ELSE
        BROADMODE=+'G' ! DEFAULT BROADENING MODE
      END IF

      ! NORMAL VECTOR
      CALL LINKEDLIST$EXISTD(LL_CNTL,'NORMAL',1,TNORMALDEF)
      IF(TNORMALDEF) THEN
        CALL LINKEDLIST$GET(LL_CNTL,'NORMAL',1,NORMAL)
        IF(NORM2(NORMAL).LT.1.D-6) THEN
          CALL ERROR$MSG('NORMAL VECTOR CANNOT BE ZERO')
          CALL ERROR$STOP('XCNTL$XAS')
        END IF
      END IF

      ! KDIR VECTOR
      CALL LINKEDLIST$EXISTD(LL_CNTL,'KDIR',1,TKDIRDEF)
      IF(TKDIRDEF) THEN
        CALL LINKEDLIST$GET(LL_CNTL,'KDIR',1,KDIR)
        IF(NORM2(KDIR).LT.1.D-6) THEN
          CALL ERROR$MSG('KDIR VECTOR CANNOT BE ZERO')
          CALL ERROR$STOP('XCNTL$XAS')
        END IF
      END IF

      ! POLARIZATION VECTOR
      CALL LINKEDLIST$EXISTD(LL_CNTL,'POL',1,TPOLDEF)
      IF(TPOLDEF) THEN
        CALL LINKEDLIST$GET(LL_CNTL,'POL',1,REALPOL)
        POL(1)=CMPLX(REALPOL(1),REALPOL(2),KIND=8)
        POL(2)=CMPLX(REALPOL(3),REALPOL(4),KIND=8)
        ! IF(NORM2(POL).LT.1.D-6) THEN
        !   CALL ERROR$MSG('POLARIZATION VECTOR CANNOT BE ZERO')
        !   CALL ERROR$STOP('XCNTL$XAS')
        ! END IF
      END IF

      ! READ NUMBER OF SPECTRA
      CALL LINKEDLIST$EXISTL(LL_CNTL,'SPECTRUM',1,TCHK)
      IF(.NOT.TCHK) THEN
        CALL ERROR$MSG('CONTROL FILE DOES NOT CONTAIN !XAS!SPECTRUM BLOCK')
        CALL ERROR$MSG('AT LEAST ONE SPECTRUM IS REQUIRED')
        CALL ERROR$STOP('XCNTL$XAS')
      END IF

      CALL LINKEDLIST$NLISTS(LL_CNTL,'SPECTRUM',NSPEC)
      CALL XAS$SETI4('NSPEC',NSPEC)
      CALL XAS$SETL4('INITIALIZE',.TRUE.) ! INITIALIZE XAS MODULE

      ! READ ALL SPECTRA
      DO ISPEC=1,NSPEC
        CALL XAS$ISELECT(ISPEC)
        CALL LINKEDLIST$SELECT(LL_CNTL,'~')
        CALL LINKEDLIST$SELECT(LL_CNTL,'XCNTL')
        CALL LINKEDLIST$SELECT(LL_CNTL,'XAS')
        CALL LINKEDLIST$SELECT(LL_CNTL,'SPECTRUM',ISPEC)

        ! READ FILENAME
        CALL LINKEDLIST$EXISTD(LL_CNTL,'FILE',1,TCHK)
        IF(.NOT.TCHK) THEN
          CALL ERROR$MSG('!XAS:SPECTRUM:FILE NOT FOUND')
          CALL ERROR$I4VAL('ISPEC',ISPEC)
          CALL ERROR$STOP('XCNTL$XAS')
        END IF
        CALL LINKEDLIST$GET(LL_CNTL,'FILE',1,FILENAME)
        CALL XAS$SETCH('FILE',TRIM(ADJUSTL(FILENAME)))

        ! EBROAD
        CALL LINKEDLIST$EXISTD(LL_CNTL,'EBROAD[EV]',1,TCHK)
        IF(TCHK) THEN
          CALL LINKEDLIST$GET(LL_CNTL,'EBROAD[EV]',1,RVAR)
          RVAR=RVAR*EV
        ELSE
          RVAR=EBROAD ! USE DEFAULT EBROAD
        END IF
        CALL XAS$SETR8('EBROAD',RVAR)

        ! BROADMODE
        CALL LINKEDLIST$EXISTD(LL_CNTL,'BROADMODE',1,TCHK)
        IF(TCHK) THEN
          CALL LINKEDLIST$GET(LL_CNTL,'BROADMODE',1,CHVAR)
          IF(CHVAR.NE.+'G'.AND.CHVAR.NE.+'L'.AND.CHVAR.NE.+'N') THEN
            CALL ERROR$MSG('BROADMODE MUST BE G, L OR N')
            CALL ERROR$CHVAL('BROADMODE',CHVAR)
            CALL ERROR$STOP('XCNTL$XAS')
          END IF
        ELSE
          CHVAR=BROADMODE ! USE DEFAULT BROADMODE
        END IF
        CALL XAS$SETCH('BROADMODE',+CHVAR)
        
        ! NORMAL VECTOR
        CALL LINKEDLIST$EXISTD(LL_CNTL,'NORMAL',1,TNORMAL)
        IF(TNORMAL) THEN
          CALL LINKEDLIST$GET(LL_CNTL,'NORMAL',1,RVAR3)
          IF(NORM2(RVAR3).LT.1.D-6) THEN
            CALL ERROR$MSG('NORMAL VECTOR CANNOT BE ZERO')
            CALL ERROR$I4VAL('ISPEC',ISPEC)
            CALL ERROR$STOP('XCNTL$XAS')
          END IF
          CALL XAS$SETR8A('NORMAL',3,RVAR3)
        ELSE IF(TNORMALDEF) THEN
          CALL XAS$SETR8A('NORMAL',3,NORMAL)
        ELSE
          CALL ERROR$MSG('NORMAL VECTOR MUST BE SET')
          CALL ERROR$I4VAL('ISPEC',ISPEC)
          CALL ERROR$STOP('XCNTL$XAS')
        END IF

        ! KDIR VECTOR
        CALL LINKEDLIST$EXISTD(LL_CNTL,'KDIR',1,TKDIR)
        IF(TKDIR) THEN
          CALL LINKEDLIST$GET(LL_CNTL,'KDIR',1,RVAR3)
          IF(NORM2(RVAR3).LT.1.D-6) THEN
            CALL ERROR$MSG('KDIR VECTOR CANNOT BE ZERO')
            CALL ERROR$I4VAL('ISPEC',ISPEC)
            CALL ERROR$STOP('XCNTL$XAS')
          END IF
          CALL XAS$SETR8A('KDIR',3,RVAR3)
        ELSE IF(TKDIRDEF) THEN
          CALL XAS$SETR8A('KDIR',3,KDIR)
        ELSE
          CALL ERROR$MSG('KDIR VECTOR MUST BE SET')
          CALL ERROR$I4VAL('ISPEC',ISPEC)
          CALL ERROR$STOP('XCNTL$XAS')
        END IF

        ! POLARIZATION VECTOR
        CALL LINKEDLIST$EXISTD(LL_CNTL,'POL',1,TPOL)
        IF(TPOL) THEN
          CALL LINKEDLIST$GET(LL_CNTL,'POL',1,REALPOL)
          CVAR2(1)=CMPLX(REALPOL(1),REALPOL(2),KIND=8)
          CVAR2(2)=CMPLX(REALPOL(3),REALPOL(4),KIND=8)
          ! IF(NORM2(CVAR2).LT.1.D-6) THEN
          !   CALL ERROR$MSG('POLARIZATION VECTOR CANNOT BE ZERO')
          !   CALL ERROR$I4VAL('ISPEC',ISPEC)
          !   CALL ERROR$STOP('XCNTL$XAS')
          ! END IF
          CALL XAS$SETC8A('POL',2,CVAR2)
        ELSE IF(TPOLDEF) THEN
          CALL XAS$SETC8A('POL',2,POL)
        ELSE
          CALL ERROR$MSG('POLARIZATION VECTOR MUST BE SET')
          CALL ERROR$I4VAL('ISPEC',ISPEC)
          CALL ERROR$STOP('XCNTL$XAS')
        END IF
        CALL XAS$UNSELECT
      ENDDO ! END ISPEC
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE XCNTL$XAS
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XCNTL$RIXS  ! MARK: XCNTL$RIXS
!     **************************************************************************
!     ** READ !XCNTL!RIXS FROM CONTROL FILE                                   **
!     **************************************************************************
      USE LINKEDLIST_MODULE
      USE XCNTL_MODULE, ONLY: LL_CNTL
      IMPLICIT NONE
      LOGICAL(4) :: TCHK
      LOGICAL(4) :: TCHK1
      LOGICAL(4) :: TCHK2
      LOGICAL(4) :: TCHK3
      CHARACTER(256) :: FILENAME
      INTEGER(4) :: NSPEC
      INTEGER(4) :: ISPEC
      REAL(8) :: EMIN
      REAL(8) :: EMAX

      REAL(8) :: ELIGHT
      LOGICAL(4) :: TELIGHTDEF
      LOGICAL(4) :: TELIGHT

      REAL(8) :: GAMMA
      LOGICAL(4) :: TGAMMADEF
      LOGICAL(4) :: TGAMMA
      
      REAL(8) :: NORMAL(3)
      LOGICAL(4) :: TNORMALDEF
      LOGICAL(4) :: TNORMAL
      
      REAL(8) :: KDIRI(3)
      LOGICAL(4) :: TKDIRIDEF
      LOGICAL(4) :: TKDIRI
      
      REAL(8) :: KDIRO(3)
      LOGICAL(4) :: TKDIRODEF
      LOGICAL(4) :: TKDIRO
      
      REAL(8) :: REALPOL(4)

      COMPLEX(8) :: POLI(2)
      LOGICAL(4) :: TPOLIDEF
      LOGICAL(4) :: TPOLI

      COMPLEX(8) :: POLO(2)
      LOGICAL(4) :: TPOLODEF
      LOGICAL(4) :: TPOLO

      REAL(8) :: RVAR
      REAL(8) :: RVAR3(3)
      COMPLEX(8) :: CVAR2(2)


      REAL(8) :: EV
      ! ONLY READ IF RIXS IS ACTIVE
      CALL RIXS$GETL4('ACTIVE',TCHK)
      IF(.NOT.TCHK) RETURN
                          CALL TRACE$PUSH('XCNTL$RIXS')
      CALL CONSTANTS('EV',EV)
      CALL LINKEDLIST$SELECT(LL_CNTL,'~')
      CALL LINKEDLIST$SELECT(LL_CNTL,'XCNTL')
      CALL LINKEDLIST$SELECT(LL_CNTL,'RIXS')

      ! EMIN[EV]
      CALL LINKEDLIST$EXISTD(LL_CNTL,'EMIN[EV]',1,TCHK)
      IF(TCHK) THEN
        CALL LINKEDLIST$GET(LL_CNTL,'EMIN[EV]',1,EMIN)
        EMIN=EMIN*EV
      ELSE
        EMIN=-HUGE(1.D0) ! MINIMUM ENERGY NOT SET
      END IF
      CALL RIXS$SETR8('EMIN',EMIN)

      ! EMAX[EV]
      CALL LINKEDLIST$EXISTD(LL_CNTL,'EMAX[EV]',1,TCHK)
      IF(TCHK) THEN
        CALL LINKEDLIST$GET(LL_CNTL,'EMAX[EV]',1,EMAX)
        EMAX=EMAX*EV
      ELSE
        EMAX=HUGE(1.D0) ! MAXIMUM ENERGY NOT SET
      END IF
      CALL RIXS$SETR8('EMAX',EMAX)

      ! GAMMA[EV] (DEFAULT)
      CALL LINKEDLIST$EXISTD(LL_CNTL,'GAMMA[EV]',1,TGAMMADEF)
      IF(TGAMMADEF) THEN
        CALL LINKEDLIST$GET(LL_CNTL,'GAMMA[EV]',1,GAMMA)
        GAMMA=GAMMA*EV
        IF(GAMMA.LT.0.D0) THEN
          CALL ERROR$MSG('GAMMA[EV] CANNOT BE NEGATIVE')
          CALL ERROR$STOP('XCNTL$RIXS')
        END IF
      END IF

      ! ELIGHT[EV] (DEFAULT)
      CALL LINKEDLIST$EXISTD(LL_CNTL,'ELIGHT[EV]',1,TELIGHTDEF)
      IF(TELIGHTDEF) THEN
        CALL LINKEDLIST$GET(LL_CNTL,'ELIGHT[EV]',1,ELIGHT)
        ELIGHT=ELIGHT*EV
        IF(ELIGHT.LT.0.D0) THEN
          CALL ERROR$MSG('ELIGHT[EV] CANNOT BE NEGATIVE')
          CALL ERROR$STOP('XCNTL$RIXS')
        END IF
      END IF

      ! NORMAL VECTOR (DEFAULT)
      CALL LINKEDLIST$EXISTD(LL_CNTL,'NORMAL',1,TNORMALDEF)
      IF(TNORMALDEF) THEN
        CALL LINKEDLIST$GET(LL_CNTL,'NORMAL',1,NORMAL)
        IF(NORM2(NORMAL).LT.1.D-6) THEN
          CALL ERROR$MSG('NORMAL VECTOR CANNOT BE ZERO')
          CALL ERROR$STOP('XCNTL$RIXS')
        END IF
      END IF

      ! KDIRI VECTOR (DEFAULT)
      CALL LINKEDLIST$EXISTD(LL_CNTL,'KDIRI',1,TKDIRIDEF)
      IF(TKDIRIDEF) THEN
        CALL LINKEDLIST$GET(LL_CNTL,'KDIRI',1,KDIRI)
        IF(NORM2(KDIRI).LT.1.D-6) THEN
          CALL ERROR$MSG('KDIRI VECTOR CANNOT BE ZERO')
          CALL ERROR$STOP('XCNTL$RIXS')
        END IF
      END IF

      ! KDIRO VECTOR (DEFAULT)
      CALL LINKEDLIST$EXISTD(LL_CNTL,'KDIRO',1,TKDIRODEF)
      IF(TKDIRODEF) THEN
        CALL LINKEDLIST$GET(LL_CNTL,'KDIRO',1,KDIRO)
        IF(NORM2(KDIRO).LT.1.D-6) THEN
          CALL ERROR$MSG('KDIRO VECTOR CANNOT BE ZERO')
          CALL ERROR$STOP('XCNTL$RIXS')
        END IF
      END IF

      ! POLI VECTOR (DEFAULT)
      CALL LINKEDLIST$EXISTD(LL_CNTL,'POLI',1,TPOLIDEF)
      IF(TPOLIDEF) THEN
        CALL LINKEDLIST$GET(LL_CNTL,'POLI',1,REALPOL)
        POLI(1)=CMPLX(REALPOL(1),REALPOL(2),KIND=8)
        POLI(2)=CMPLX(REALPOL(3),REALPOL(4),KIND=8)
      END IF

      ! POLO VECTOR (DEFAULT)
      CALL LINKEDLIST$EXISTD(LL_CNTL,'POLO',1,TPOLODEF)
      IF(TPOLODEF) THEN
        CALL LINKEDLIST$GET(LL_CNTL,'POLO',1,REALPOL)
        POLO(1)=CMPLX(REALPOL(1),REALPOL(2),KIND=8)
        POLO(2)=CMPLX(REALPOL(3),REALPOL(4),KIND=8)
      END IF

      ! READ NUMBER OF SPECTRA
      CALL LINKEDLIST$EXISTL(LL_CNTL,'SPECTRUM',1,TCHK)
      IF(.NOT.TCHK) THEN
        CALL ERROR$MSG('CONTROL FILE DOES NOT CONTAIN !RIXS!SPECTRUM BLOCK')
        CALL ERROR$MSG('AT LEAST ONE SPECTRUM IS REQUIRED')
        CALL ERROR$STOP('XCNTL$RIXS')
      END IF

      CALL LINKEDLIST$NLISTS(LL_CNTL,'SPECTRUM',NSPEC)
      CALL RIXS$SETI4('NSPEC',NSPEC)
      CALL RIXS$SETL4('INITIALIZE',.TRUE.) ! INITIALIZE RIXS MODULE

      ! READ ALL SPECTRA
      DO ISPEC=1,NSPEC
        CALL RIXS$ISELECT(ISPEC)
        CALL LINKEDLIST$SELECT(LL_CNTL,'~')
        CALL LINKEDLIST$SELECT(LL_CNTL,'XCNTL')
        CALL LINKEDLIST$SELECT(LL_CNTL,'RIXS')
        CALL LINKEDLIST$SELECT(LL_CNTL,'SPECTRUM',ISPEC)

        ! READ FILENAME
        CALL LINKEDLIST$EXISTD(LL_CNTL,'FILE',1,TCHK)
        IF(.NOT.TCHK) THEN
          CALL ERROR$MSG('!RIXS:SPECTRUM:FILE NOT FOUND')
          CALL ERROR$I4VAL('ISPEC',ISPEC)
          CALL ERROR$STOP('XCNTL$RIXS')
        END IF
        CALL LINKEDLIST$GET(LL_CNTL,'FILE',1,FILENAME)
        CALL RIXS$SETCH('FILE',TRIM(ADJUSTL(FILENAME)))

        ! GAMMA[EV]
        CALL LINKEDLIST$EXISTD(LL_CNTL,'GAMMA[EV]',1,TGAMMA)
        IF(TGAMMA) THEN
          CALL LINKEDLIST$GET(LL_CNTL,'GAMMA[EV]',1,RVAR)
          RVAR=RVAR*EV
          CALL RIXS$SETR8('GAMMA',RVAR)
        ELSE
          IF(TGAMMADEF) THEN
            CALL RIXS$SETR8('GAMMA',GAMMA)
          ELSE
            CALL ERROR$MSG('GAMMA[EV] MUST BE SET')
            CALL ERROR$I4VAL('ISPEC',ISPEC)
            CALL ERROR$STOP('XCNTL$RIXS')
          END IF
        END IF

        ! ELIGHT[EV]
        CALL LINKEDLIST$EXISTD(LL_CNTL,'ELIGHT[EV]',1,TELIGHT)
        IF(TELIGHT) THEN
          CALL LINKEDLIST$GET(LL_CNTL,'ELIGHT[EV]',1,RVAR)
          RVAR=RVAR*EV
          CALL RIXS$SETR8('ELIGHT',RVAR)
        ELSE
          IF(TELIGHTDEF) THEN
            CALL RIXS$SETR8('ELIGHT',ELIGHT)
          ELSE
            CALL ERROR$MSG('ELIGHT[EV] MUST BE SET')
            CALL ERROR$I4VAL('ISPEC',ISPEC)
            CALL ERROR$STOP('XCNTL$RIXS')
          END IF
        END IF

        ! NORMAL VECTOR
        CALL LINKEDLIST$EXISTD(LL_CNTL,'NORMAL',1,TNORMAL)
        IF(TNORMAL) THEN
          CALL LINKEDLIST$GET(LL_CNTL,'NORMAL',1,RVAR3)
          IF(NORM2(RVAR3).LT.1.D-6) THEN
            CALL ERROR$MSG('NORMAL VECTOR CANNOT BE ZERO')
            CALL ERROR$I4VAL('ISPEC',ISPEC)
            CALL ERROR$STOP('XCNTL$RIXS')
          END IF
          CALL RIXS$SETR8A('NORMAL',3,RVAR3)
        ELSE IF(TNORMALDEF) THEN
          CALL RIXS$SETR8A('NORMAL',3,NORMAL)
        ELSE
          CALL ERROR$MSG('NORMAL VECTOR MUST BE SET')
          CALL ERROR$I4VAL('ISPEC',ISPEC)
          CALL ERROR$STOP('XCNTL$RIXS')
        END IF

        ! KDIRI VECTOR
        CALL LINKEDLIST$EXISTD(LL_CNTL,'KDIRI',1,TKDIRI)
        IF(TKDIRI) THEN
          CALL LINKEDLIST$GET(LL_CNTL,'KDIRI',1,RVAR3)
          IF(NORM2(RVAR3).LT.1.D-6) THEN
            CALL ERROR$MSG('KDIRI VECTOR CANNOT BE ZERO')
            CALL ERROR$I4VAL('ISPEC',ISPEC)
            CALL ERROR$STOP('XCNTL$RIXS')
          END IF
          CALL RIXS$SETR8A('KDIRI',3,RVAR3)
        ELSE IF(TKDIRIDEF) THEN
          CALL RIXS$SETR8A('KDIRI',3,KDIRI)
        ELSE
          CALL ERROR$MSG('KDIRI VECTOR MUST BE SET')
          CALL ERROR$I4VAL('ISPEC',ISPEC)
          CALL ERROR$STOP('XCNTL$RIXS')
        END IF

        ! KDIRO VECTOR
        CALL LINKEDLIST$EXISTD(LL_CNTL,'KDIRO',1,TKDIRO)
        IF(TKDIRO) THEN
          CALL LINKEDLIST$GET(LL_CNTL,'KDIRO',1,RVAR3)
          IF(NORM2(RVAR3).LT.1.D-6) THEN
            CALL ERROR$MSG('KDIRO VECTOR CANNOT BE ZERO')
            CALL ERROR$I4VAL('ISPEC',ISPEC)
            CALL ERROR$STOP('XCNTL$RIXS')
          END IF
          CALL RIXS$SETR8A('KDIRO',3,RVAR3)
        ELSE IF(TKDIRODEF) THEN
          CALL RIXS$SETR8A('KDIRO',3,KDIRO)
        ELSE
          CALL ERROR$MSG('KDIRO VECTOR MUST BE SET')
          CALL ERROR$I4VAL('ISPEC',ISPEC)
          CALL ERROR$STOP('XCNTL$RIXS')
        END IF

        ! POLI VECTOR
        CALL LINKEDLIST$EXISTD(LL_CNTL,'POLI',1,TPOLI)
        IF(TPOLI) THEN
          CALL LINKEDLIST$GET(LL_CNTL,'POLI',1,REALPOL)
          CVAR2(1)=CMPLX(REALPOL(1),REALPOL(2),KIND=8)
          CVAR2(2)=CMPLX(REALPOL(3),REALPOL(4),KIND=8)
          CALL RIXS$SETC8A('POLI',2,CVAR2)
        ELSE IF(TPOLIDEF) THEN
          CALL RIXS$SETC8A('POLI',2,POLI)
        ELSE
          CALL ERROR$MSG('POLI VECTOR MUST BE SET')
          CALL ERROR$I4VAL('ISPEC',ISPEC)
          CALL ERROR$STOP('XCNTL$RIXS')
        END IF

        ! POLO VECTOR
        CALL LINKEDLIST$EXISTD(LL_CNTL,'POLO',1,TPOLO)
        IF(TPOLO) THEN
          CALL LINKEDLIST$GET(LL_CNTL,'POLO',1,REALPOL)
          CVAR2(1)=CMPLX(REALPOL(1),REALPOL(2),KIND=8)
          CVAR2(2)=CMPLX(REALPOL(3),REALPOL(4),KIND=8)
          CALL RIXS$SETC8A('POLO',2,CVAR2)
        ELSE IF(TPOLODEF) THEN
          CALL RIXS$SETC8A('POLO',2,POLO)
        ELSE
          CALL ERROR$MSG('POLO VECTOR MUST BE SET')
          CALL ERROR$I4VAL('ISPEC',ISPEC)
          CALL ERROR$STOP('XCNTL$RIXS')
        END IF

        CALL RIXS$UNSELECT
      ENDDO ! END ISPEC
                          CALL TRACE$POP  
      RETURN
      END SUBROUTINE XCNTL$RIXS
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XCNTL$GETL4(ID,VAL)  ! MARK: XCNTL$GETL4
!     **************************************************************************
!     ** GET LOGICAL VALUE FROM XCNTL MODULE                                  **
!     **************************************************************************
      USE XCNTL_MODULE, ONLY: TOVERLAP,ADET,BASISWGHT,NORMALIZE,MOMENTUMTRANSFER
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      LOGICAL(4), INTENT(OUT) :: VAL
      IF(ID.EQ.'TOVERLAP') THEN
        VAL=TOVERLAP
      ELSE IF(ID.EQ.'ADET') THEN
        VAL=ADET
      ELSE IF(ID.EQ.'BASISWGHT') THEN
        VAL=BASISWGHT
      ELSE IF(ID.EQ.'NORMALIZE') THEN
        VAL=NORMALIZE
      ELSE IF(ID.EQ.'MOMENTUMTRANSFER') THEN
        VAL=MOMENTUMTRANSFER
      ELSE
        CALL ERROR$MSG('XCNTL$GETL4: ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('XCNTL$GETL4')
      END IF
      RETURN
      END SUBROUTINE XCNTL$GETL4
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XCNTL$GETCH(ID,VAL)  ! MARK: XCNTL$GETCH
!     **************************************************************************
!     ** GET CHARACTER VALUE FROM XCNTL MODULE                               **
!     **************************************************************************
      USE XCNTL_MODULE, ONLY: OVERLAPFILE,TOVERLAP
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      CHARACTER(*), INTENT(OUT) :: VAL
      IF(.NOT.TOVERLAP) THEN
        CALL ERROR$MSG('XCNTL$GETCH: OVERLAP NOT ACTIVE')
        CALL ERROR$STOP('XCNTL$GETCH')
      END IF
      IF(ID.EQ.'OVERLAPFILE') THEN
        VAL=TRIM(ADJUSTL(OVERLAPFILE))
      ELSE
        CALL ERROR$MSG('XCNTL$GETCH: ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('XCNTL$GETCH')
      END IF
      RETURN
      END SUBROUTINE XCNTL$GETCH
!
!     ==========================================================================
!     ==========================================================================
!     ==                 SIMULATION MODULE FUNCTIONS                          ==
!     ==========================================================================
!     ==========================================================================
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION$CONSISTENCY  ! MARK: SIMULATION$CONSISTENCY
!     **************************************************************************
!     ** CHECK CONSISTENCY OF THE TWO SIMULATIONS                             **
!     **************************************************************************
! TODO: IMPLEMENT CHECK IF BOTH SIMULATIONS HAVE THE SAME PARAMETERS FOR CERTAIN
!       PROPERTIES, SUCH AS THE NUMBER OF ATOMS, SPINS, K-POINTS, ETC.
      END SUBROUTINE SIMULATION$CONSISTENCY
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION$CHECKINVERSION  ! MARK: SIMULATION$CHECKINVERSION
!     **************************************************************************
!     ** DETERMINE IF RECIPROCAL SPACE GRID IS INVERSION SYMMETRIC            **
!     ** REQUIRES SELECTED SIMULATION                                         **
!     ** METHOD TAKEN FROM: PLANEWAVE$CHECKINVERSION                          **
!     **************************************************************************
      USE SIMULATION_MODULE, ONLY: SELECTED,THIS
      IMPLICIT NONE
      REAL(8), PARAMETER :: DSMALL=1.D-12
      LOGICAL(4) :: INVERSION
      LOGICAL(4) :: TCHK
      INTEGER(4) :: IKPT
      INTEGER(4) :: I
      REAL(8) :: SVAR
                          CALL TRACE$PUSH('SIMULATION$CHECKINVERSION')
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('CANNOT CHECK INVERSION SYMMETRY WHEN NO SIMULATION IS SELECTED')
        CALL ERROR$STOP('SIMULATION$CHECKINVERSION')
      END IF
      IF(ALLOCATED(THIS%TINVARR)) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('INVERSION SYMMETRY ALREADY CHECKED')
        CALL ERROR$STOP('SIMULATION$CHECKINVERSION')
      END IF
      IF(.NOT.ALLOCATED(THIS%XK)) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('RECIPROCAL SPACE GRID NOT ALLOCATED')
        CALL ERROR$STOP('SIMULATION$CHECKINVERSION')
      END IF
      ALLOCATE(THIS%TINVARR(THIS%NKPT))
      DO IKPT=1,THIS%NKPT
        TCHK=.TRUE.
        DO I=1,3
          SVAR=MODULO(THIS%XK(I,IKPT),0.5D0)
          TCHK=TCHK.AND.(ABS(SVAR).LT.DSMALL)
        ENDDO
        THIS%TINVARR(IKPT)=TCHK
      ENDDO
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE SIMULATION$CHECKINVERSION
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION$KPTMAP  ! MARK: SIMULATION$KPTMAP
!     **************************************************************************
!     ** CREATE K-POINT MAPPING BETWEEN IRREDUCIBLE AND FULL K-POINT SETS     **
!     ** REQUIRES SELECTED SIMULATION                                         **
!     ** METHOD IS NOT UNIQUE, BUT CONSISTENT WITHIN THE CODE                 **
!     **************************************************************************
      USE SIMULATION_MODULE, ONLY: SELECTED,THIS
      IMPLICIT NONE
      INTEGER(4) :: IKPT
      INTEGER(4) :: IKPTTOT
                          CALL TRACE$PUSH('SIMULATION$KPTMAP')
      IF(.NOT.THIS%INITIALIZED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('SIMULATION NOT INITIALIZED')
        CALL ERROR$CHVAL('SELECTED SIMULATION ID: ',THIS%ID)
        CALL ERROR$STOP('SIMULATION$KPTMAP')
      END IF
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('CANNOT CREATE K-POINT MAPPING WHEN NO SIMULATION IS SELECTED')
        CALL ERROR$STOP('SIMULATION$KPTMAP')
      END IF
      IF(ALLOCATED(THIS%TOIRRKPT)) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('K-POINT MAPPING ALREADY ALLOCATED')
        CALL ERROR$STOP('SIMULATION$KPTMAP')
      END IF
      IF(ALLOCATED(THIS%TIRRKPT)) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('INVERSION SYMMETRY ALREADY ALLOCATED')
        CALL ERROR$STOP('SIMULATION$KPTMAP')
      END IF
      IF(ALLOCATED(THIS%TOTOTKPT)) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('TOTAL K-POINT SET ALREADY ALLOCATED')
        CALL ERROR$STOP('SIMULATION$KPTMAP')
      END IF
      ! ALLOCATE K-POINT MAPPING
      ALLOCATE(THIS%TOIRRKPT(THIS%NKPTTOT))
      ALLOCATE(THIS%TIRRKPT(THIS%NKPTTOT))
      ALLOCATE(THIS%TOTOTKPT(THIS%NKPT))

      IKPTTOT=0
      DO IKPT=1,THIS%NKPT
        IKPTTOT=IKPTTOT+1
        THIS%TOTOTKPT(IKPT)=IKPTTOT
        ! CHECK IF NEGATIVE K-POINT NEEDS TO BE MAPPED
        ! IF TRUE: NO K POINT -K NEEDS TO BE CALCULATED
        ! IF FALSE: -K POINT NEEDS TO BE CALCULATED
        IF(THIS%TINVARR(IKPT)) THEN
          ! NEGATIVE K-POINT IS NOT NEEDED
          THIS%TOIRRKPT(IKPTTOT)=IKPT
          ! IKPTTOT IS IRR. KPT
          THIS%TIRRKPT(IKPTTOT)=.TRUE.
        ELSE
          ! NEGATIVE K-POINT IS NEEDED
          THIS%TOIRRKPT(IKPTTOT)=IKPT
          ! IKPTTOT IS IRR. KPT
          THIS%TIRRKPT(IKPTTOT)=.TRUE.

          IKPTTOT=IKPTTOT+1
          THIS%TOIRRKPT(IKPTTOT)=IKPT
          ! IKPTTOT IS NEGATIVE KPT
          THIS%TIRRKPT(IKPTTOT)=.FALSE.
        END IF
      ENDDO
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE SIMULATION$KPTMAP
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION_ATOMMAP  ! MARK: SIMULATION_ATOMMAP
!     **************************************************************************
!     ** CREATE ATOM MAPPING BETWEEN GROUND AND EXCITED STATE SIMULATION      **
!     **************************************************************************
      USE SIMULATION_MODULE, ONLY: SELECTED,GROUND,EXCITE,THIS,ATOMMAP
      IMPLICIT NONE
      INTEGER(4) :: NAT
      INTEGER(4) :: IAT1
      INTEGER(4) :: IAT2
      LOGICAL(4) :: FOUND
                          CALL TRACE$PUSH('SIMULATION_ATOMMAP')
      IF(SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('CANNOT CREATE ATOM MAPPING WHEN SIMULATION IS SELECTED')
        CALL ERROR$CHVAL('SELECTED SIMULATION ID: ',THIS%ID)
        CALL ERROR$STOP('SIMULATION_ATOMMAP')
      END IF
      ! DOES NOT PROTECT FROM ATOMID NOT SET IN GROUND AND EXCITE
      IF(.NOT.GROUND%INITIALIZED.OR..NOT.EXCITE%INITIALIZED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('BOTH SIMULATIONS MUST BE INITIALIZED')
        CALL ERROR$L4VAL('GROUND: ',GROUND%INITIALIZED)
        CALL ERROR$L4VAL('EXCITE: ',EXCITE%INITIALIZED)
        CALL ERROR$STOP('SIMULATION_ATOMMAP')
      END IF
      IF(ALLOCATED(ATOMMAP)) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('ATOMMAP ALREADY ALLOCATED')
      END IF
      ! CHECKED BEFORE THAT BOTH SIMULATIONS HAVE THE SAME NUMBER OF ATOMS
      NAT=GROUND%NAT
      ALLOCATE(ATOMMAP(NAT))
      DO IAT1=1,NAT
        FOUND=.FALSE.
        DO IAT2=1,NAT
          IF(GROUND%ATOMID(IAT1).EQ.EXCITE%ATOMID(IAT2)) THEN
            ATOMMAP(IAT1)=IAT2
            FOUND=.TRUE.
            EXIT
          END IF
        ENDDO ! IAT2
        IF(.NOT.FOUND) THEN
          CALL ERROR$MSG('ATOM NOT FOUND IN EXCITE SIMULATION')
          CALL ERROR$I4VAL('GROUND ATOM INDEX: ',IAT1)
          CALL ERROR$CHVAL('GROUND ATOM ID: ',GROUND%ATOMID(IAT1))
          CALL ERROR$STOP('SIMULATION_ATOMMAP')
        END IF
      ENDDO ! IAT1
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE SIMULATION_ATOMMAP
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION$SELECT(ID)  ! MARK: SIMULATION$SELECT
!     **************************************************************************
!     ** SELECT SIMULATION IN SIMULATION MODULE                               **
!     **************************************************************************
      USE SIMULATION_MODULE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      IF(SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('CANNOT SELECT SIMULATION WHEN ALREADY SELECTED')
        CALL ERROR$CHVAL('SELECTED SIMULATION ID: ',THIS%ID)
        CALL ERROR$CHVAL('ID TO SELECT: ',ID)
        CALL ERROR$STOP('SIMULATION$SELECT')
      END IF
      IF(ID.EQ.'GROUND') THEN
        THIS=>GROUND
      ELSE IF(ID.EQ.'EXCITE') THEN
        THIS=>EXCITE
      ELSE
        CALL ERROR$MSG('SIMULATION ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID TO SELECT: ',ID)
        CALL ERROR$STOP('SIMULATION$SELECT')
      END IF
      SELECTED=.TRUE.
      RETURN
      END SUBROUTINE SIMULATION$SELECT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION$UNSELECT()  ! MARK: SIMULATION$UNSELECT
!     **************************************************************************
!     ** UNSELECT SIMULATION IN SIMULATION MODULE                             **
!     **************************************************************************
      USE SIMULATION_MODULE
      IMPLICIT NONE
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('CANNOT UNSELECT SIMULATION WHEN NOT SELECTED')
        CALL ERROR$STOP('SIMULATION$UNSELECT')
      END IF
      SELECTED=.FALSE.
      NULLIFY(THIS)
      RETURN
      END SUBROUTINE SIMULATION$UNSELECT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION$ISELECT(I)  ! MARK: SIMULATION$ISELECT
!     **************************************************************************
!     ** SELECT SIMULATION IN SIMULATION MODULE BY INDEX                      **
!     **************************************************************************
      USE SIMULATION_MODULE
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: I
      IF(SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('CANNOT SELECT SIMULATION WHEN ALREADY SELECTED')
        CALL ERROR$CHVAL('SELECTED SIMULATION ID: ',THIS%ID)
        CALL ERROR$I4VAL('INDEX TO SELECT: ',I)
        CALL ERROR$STOP('SIMULATION$ISELECT')
      END IF
      IF(I.EQ.1) THEN
        THIS=>GROUND
      ELSE IF(I.EQ.2) THEN
        THIS=>EXCITE
      ELSE
        CALL ERROR$MSG('SIMULATION INDEX NOT RECOGNIZED')
        CALL ERROR$I4VAL('INDEX TO SELECT: ',I)
        CALL ERROR$STOP('SIMULATION$ISELECT')
      END IF
      SELECTED=.TRUE.
      RETURN
      END SUBROUTINE SIMULATION$ISELECT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION$INIT(NAT,NSP,NKPT,NSPIN,NDIM,NPRO,LNXX,FLAG)  ! MARK: SIMULATION$INIT
!     **************************************************************************
!     ** INITIALIZE SIMULATION MODULE                                         **
!     ** NAT,NSP,NKPT,NSPIN,NDIM,NPRO,LNXX,FLAG ARE SIMULATION PARAMETERS     **
!     ** REQUIRES SELECTED SIMULATION                                         **
!     **************************************************************************
      USE SIMULATION_MODULE
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: NAT
      INTEGER(4), INTENT(IN) :: NSP
      INTEGER(4), INTENT(IN) :: NKPT
      INTEGER(4), INTENT(IN) :: NSPIN
      INTEGER(4), INTENT(IN) :: NDIM
      INTEGER(4), INTENT(IN) :: NPRO
      INTEGER(4), INTENT(IN) :: LNXX
      CHARACTER(6), INTENT(IN) :: FLAG
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SIMULATION SELECTED')
        CALL ERROR$STOP('SIMULATION$INIT')
      END IF
      IF(THIS%INITIALIZED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('SIMULATION ALREADY INITIALIZED')
        CALL ERROR$CHVAL('SELECTED SIMULATION ID: ',THIS%ID)
        CALL ERROR$STOP('SIMULATION$INIT')
      END IF
      THIS%NAT=NAT
      THIS%NSP=NSP
      THIS%NKPT=NKPT
      THIS%NSPIN=NSPIN
      THIS%NDIM=NDIM
      THIS%NPRO=NPRO
      THIS%LNXX=LNXX
      THIS%FLAG=FLAG
      ! ALLOCATE(THIS%LMNX(NSP))
      ALLOCATE(THIS%LNX(NSP))
      ALLOCATE(THIS%LOX(LNXX,NSP))
      ! ALLOCATE(THIS%MAP(NAT,LNXX))
      ALLOCATE(THIS%R(3,NAT))
      ALLOCATE(THIS%ATOMID(NAT))
      ALLOCATE(THIS%ISPECIES(NAT))
      ALLOCATE(THIS%XK(3,NKPT))
      ALLOCATE(THIS%WKPT(NKPT))
      ! ALLOCATE(THIS%DENMAT(LMNXX,LMNXX,NDIM,NAT))
      THIS%INITIALIZED=.TRUE.
      RETURN
      END SUBROUTINE SIMULATION$INIT

!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION$REPORT(NFIL)  ! MARK: SIMULATION$REPORT
!     **************************************************************************
!     ** REPORT SIMULATION PARAMETERS                                         **
!     ** REQUIRES SELECTED SIMULATION                                         **
!     **************************************************************************
      USE SIMULATION_MODULE, ONLY: THIS,SELECTED
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: NFIL
      INTEGER(4) :: NTASKS,THISTASK,RTASK
      REAL(8) :: EV
      INTEGER(4) :: IAT,IKPT
      INTEGER(4), ALLOCATABLE :: DUMMY(:,:)
      CHARACTER(256) :: FORMAT
      REAL(8) :: SVAR
      LOGICAL(4) :: TOVERLAP
      LOGICAL(4) :: TPR
      REAL(8) :: GBAS(3,3)
      REAL(8) :: K(3)
      REAL(8) :: VOLUME
      REAL(8) :: ANGSTROM

      CALL MPE$QUERY('~',NTASKS,THISTASK)
      CALL KSMAP$READTASK(RTASK)
      IF(THISTASK.NE.RTASK) RETURN
                          CALL TRACE$PUSH('SIMULATION$REPORT')
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SIMULATION SELECTED')
        CALL ERROR$STOP('SIMULATION$REPORT')
      END IF
      IF(.NOT.THIS%INITIALIZED) THEN
        CALL ERROR$MSG('SIMULATION NOT INITIALIZED')
        CALL ERROR$CHVAL('SELECTED SIMULATION ID: ',THIS%ID)
        CALL ERROR$STOP('SIMULATION$REPORT')
      END IF
      CALL XCNTL$GETL4('TOVERLAP',TOVERLAP)
      TPR=.NOT.TOVERLAP
      CALL CONSTANTS('EV',EV)
      CALL CONSTANTS('ANGSTROM',ANGSTROM)
      WRITE(NFIL,'(80("#"))')
      WRITE(NFIL,FMT='(A20,A14)')'SIMULATION REPORT',THIS%ID
      WRITE(NFIL,'(80("#"))')
      IF(TPR) WRITE(NFIL,FMT='(A12,X,A)')'FILE:',TRIM(THIS%FILE)
      WRITE(NFIL,FMT='(A12,I10)')'NAT:',THIS%NAT
      WRITE(NFIL,FMT='(A12,I10)')'NSP:',THIS%NSP
      WRITE(NFIL,FMT='(A12,I10)')'NKPT:',THIS%NKPT
      WRITE(NFIL,FMT='(A12,I10)')'NKPTTOT:',THIS%NKPTTOT
      WRITE(NFIL,FMT='(A12,I10)')'NSPIN:',THIS%NSPIN
      WRITE(NFIL,FMT='(A12,I10)')'NDIM:',THIS%NDIM
      WRITE(NFIL,FMT='(A12,I10)')'NPRO:',THIS%NPRO
      WRITE(NFIL,FMT='(A12,I10)')'LNXX:',THIS%LNXX
      WRITE(NFIL,FMT='(A12,L10)')'TINV:',THIS%TINV
      WRITE(NFIL,FMT='(A12,3I10)')'NKDIV:',THIS%NKDIV(:)
      WRITE(NFIL,FMT='(A12,3I10)')'ISHIFT:',THIS%ISHIFT(:)
      WRITE(NFIL,FMT='(A12,F10.4)')'RNTOT:',THIS%RNTOT
      WRITE(NFIL,FMT='(A12,F10.4)')'NEL:',THIS%NEL
      ! NEEDS TO BE CALLED TO TRIGGER CALCULATION OF ETOT AND ECORE
      CALL SIMULATION$GETR8('ETOT',SVAR)
      WRITE(NFIL,FMT='(A12,F20.8)')'ETOT [EV]:',THIS%ETOT/EV
      WRITE(NFIL,FMT='(A12,F20.8)')'EDFT [EV]:',THIS%EDFT/EV
      WRITE(NFIL,FMT='(A12,F20.8)')'ECORE [EV]:',THIS%ECORE/EV
      IF(TPR) WRITE(NFIL,FMT='(A12,I10)')'SPACEGR.:',THIS%SPACEGROUP
      WRITE(NFIL,FMT='(A12,L10)')'TSHIFT:',THIS%TSHIFT
      WRITE(NFIL,FMT='(A12,3F10.4)')'RBAS[AA]:',THIS%RBAS(:,1)/ANGSTROM
      DO IAT=2,3
        WRITE(NFIL,FMT='(A12,3F10.4)')' ',THIS%RBAS(:,IAT)/ANGSTROM
      ENDDO
      CALL GBASS(THIS%RBAS,GBAS,VOLUME)
      WRITE(NFIL,FMT='(A12,F12.4)')'VOL.[AA^3]:',VOLUME/ANGSTROM**3
      WRITE(NFIL,FMT='(A12,3F10.4)')'GBAS[1/AA]:',GBAS(:,1)*ANGSTROM
      DO IAT=2,3
        WRITE(NFIL,FMT='(A12,3F10.4)')' ',GBAS(:,IAT)*ANGSTROM
      ENDDO
      WRITE(NFIL,'(A)')'ATOM REPORT'
      WRITE(NFIL,FMT='(5A12)')'ATOM','X[AA]','Y[AA]','Z[AA]','SPECIES'
      DO IAT=1,THIS%NAT
        WRITE(NFIL,FMT='(A12,3F12.6,I10)')THIS%ATOMID(IAT), &
     &                                 THIS%R(:,IAT)/ANGSTROM,THIS%ISPECIES(IAT)
      ENDDO
      IF(TPR) THEN
        ! MAP IS ONLY CALCULATED ON FIRST CALL TO SIMULATION$GETI4A
        ! HERE IT IS CALLED IN CASE IT WAS NOT CALLED BEFORE
        ALLOCATE(DUMMY(THIS%NAT,THIS%LNXX))
        CALL SIMULATION$GETI4A('MAP',THIS%NAT*THIS%LNXX,DUMMY)
        DEALLOCATE(DUMMY)
        WRITE(NFIL,FMT='(A)')'MAPPING OF PROJECTIONS (INDEX-1)'
        WRITE(NFIL,FMT='(A10,A10)')'ATOM','MAP'
        WRITE(FORMAT,'("(I10,",I0,"I10)")')THIS%LNXX
        DO IAT=1,THIS%NAT
          WRITE(NFIL,FMT=FORMAT)IAT,THIS%MAP(IAT,:)
        ENDDO
      END IF
      WRITE(NFIL,'(A)')'K-POINT REPORT'
      WRITE(NFIL,FMT='(A6,A8,5A10)')'IKPT','','','','','WKPT','TINV'
      DO IKPT=1,THIS%NKPT
        WRITE(NFIL,FMT='(32("- "))')
        WRITE(NFIL,FMT='(I6,A8,4F10.6,L10)')IKPT,'XK',THIS%XK(:,IKPT), &
     &                                 THIS%WKPT(IKPT),THIS%TINVARR(IKPT)
        CALL XKTOK(THIS%XK(:,IKPT),THIS%RBAS,K)
        WRITE(NFIL,'(A6,A8,3F10.6)')' ','K[1/AA]', K(:)*ANGSTROM
      ENDDO
      WRITE(NFIL,'(A)')'K-POINT MAPPING REPORT'
      WRITE(NFIL,FMT='(6A10)')'IKPTTOT','IKPT','IRR. KPT','','IKPT','IKPTTOT'
      DO IKPT=1,THIS%NKPTTOT
        IF(IKPT.LE.THIS%NKPT) THEN
          WRITE(NFIL,FMT='(I10,"->",I8,L10,10X,I10,"->",I8)')IKPT, &
     &           THIS%TOIRRKPT(IKPT),THIS%TIRRKPT(IKPT),IKPT,THIS%TOTOTKPT(IKPT)
        ELSE
          WRITE(NFIL,FMT='(I10,"->",I8,L10)')IKPT,THIS%TOIRRKPT(IKPT), &
     &                                       THIS%TIRRKPT(IKPT)
        END IF
      ENDDO
      FLUSH(NFIL)
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE SIMULATION$REPORT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION$SETI4A(ID,LEN,VAL)  ! MARK: SIMULATION$SETI4A
!     **************************************************************************
!     ** SET INTEGER VALUE IN SIMULATION MODULE                               **
!     ** REQUIRES SELECTED SIMULATION                                         **
!     **************************************************************************
      USE SIMULATION_MODULE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: LEN
      INTEGER(4), INTENT(IN) :: VAL(LEN)
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SIMULATION SELECTED')
        CALL ERROR$STOP('SIMULATION$SETI4')
      END IF
      IF(.NOT.THIS%INITIALIZED) THEN
        CALL ERROR$MSG('SIMULATION NOT INITIALIZED')
        CALL ERROR$CHVAL('SELECTED SIMULATION ID: ',THIS%ID)
        CALL ERROR$STOP('SIMULATION$SETI4')
      END IF
      IF(ID.EQ.'LMNX') THEN
        IF(LEN.NE.THIS%NSP) THEN
          CALL ERROR$MSG('LENGTH OF LMNX ARRAY MUST BE EQUAL TO NSP')
          CALL ERROR$I4VAL('LENGTH OF LMNX: ',LEN)
          CALL ERROR$I4VAL('NSP: ',THIS%NSP)
          CALL ERROR$STOP('SIMULATION$SETI4')
        END IF
        THIS%LMNX=VAL
      ELSE IF(ID.EQ.'LNX') THEN
        IF(LEN.NE.THIS%NSP) THEN
          CALL ERROR$MSG('LENGTH OF LNX ARRAY MUST BE EQUAL TO NSP')
          CALL ERROR$I4VAL('LENGTH OF LNX: ',LEN)
          CALL ERROR$I4VAL('NSP: ',THIS%NSP)
          CALL ERROR$STOP('SIMULATION$SETI4')
        END IF
        THIS%LNX=VAL
      ELSE IF(ID.EQ.'LOX') THEN
        IF(LEN.NE.THIS%LNXX*THIS%NSP) THEN
          CALL ERROR$MSG('LENGTH OF LOX ARRAY MUST BE EQUAL TO LNXX*NSP')
          CALL ERROR$I4VAL('LENGTH OF LOX: ',LEN)
          CALL ERROR$I4VAL('LNXX: ',THIS%LNXX)
          CALL ERROR$I4VAL('NSP: ',THIS%NSP)
          CALL ERROR$STOP('SIMULATION$SETI4')
        END IF
        THIS%LOX(:,:)=RESHAPE(VAL,(/THIS%LNXX,THIS%NSP/))
      ELSE IF(ID.EQ.'MAP') THEN
        IF(LEN.NE.THIS%NAT*THIS%LNXX) THEN
          CALL ERROR$MSG('LENGTH OF MAP ARRAY MUST BE EQUAL TO NAT*LNXX')
          CALL ERROR$I4VAL('LENGTH OF MAP: ',LEN)
          CALL ERROR$I4VAL('NAT: ',THIS%NAT)
          CALL ERROR$I4VAL('LNXX: ',THIS%LNXX)
          CALL ERROR$STOP('SIMULATION$SETI4')
        END IF
        THIS%MAP(:,:)=RESHAPE(VAL,(/THIS%NAT,THIS%LNXX/))
      ELSE IF(ID.EQ.'NKDIV') THEN
        IF(LEN.NE.3) THEN
          CALL ERROR$MSG('LENGTH OF NKDIV ARRAY MUST BE 3')
          CALL ERROR$I4VAL('LENGTH OF NKDIV: ',LEN)
          CALL ERROR$STOP('SIMULATION$SETI4')
        END IF
        THIS%NKDIV=VAL
        THIS%NKPTTOT=PRODUCT(THIS%NKDIV)
      ELSE IF(ID.EQ.'ISHIFT') THEN
        IF(LEN.NE.3) THEN
          CALL ERROR$MSG('LENGTH OF ISHIFT ARRAY MUST BE 3')
          CALL ERROR$I4VAL('LENGTH OF ISHIFT: ',LEN)
          CALL ERROR$STOP('SIMULATION$SETI4')
        END IF
        THIS%ISHIFT=VAL
      ELSE IF(ID.EQ.'ISPECIES') THEN
        IF(LEN.NE.THIS%NAT) THEN
          CALL ERROR$MSG('LENGTH OF ISPECIES ARRAY MUST BE EQUAL TO NAT')
          CALL ERROR$I4VAL('LENGTH OF ISPECIES: ',LEN)
          CALL ERROR$I4VAL('NAT: ',THIS%NAT)
          CALL ERROR$STOP('SIMULATION$SETI4')
        END IF
        THIS%ISPECIES=VAL
      ELSE
        CALL ERROR$MSG('SIMULATION SETI4A ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('SIMULATION$SETI4')
      END IF 
      RETURN
      END SUBROUTINE SIMULATION$SETI4A
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION$GETI4A(ID,LEN,VAL)  ! MARK: SIMULATION$GETI4A
!     **************************************************************************
!     ** GET INTEGER VALUE ARRAY FROM SIMULATION MODULE                       **
!     ** REQUIRES SELECTED SIMULATION                                         **
!     **************************************************************************
      USE SIMULATION_MODULE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: LEN
      INTEGER(4), INTENT(OUT) :: VAL(LEN)
      INTEGER(4) :: ISP
      INTEGER(4) :: LN
      INTEGER(4) :: IPRO
      INTEGER(4) :: IAT
      INTEGER(4) :: L
      INTEGER(4) :: M
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SIMULATION SELECTED')
        CALL ERROR$STOP('SIMULATION$GETI4A')
      END IF
      IF(.NOT.THIS%INITIALIZED) THEN
        CALL ERROR$MSG('SIMULATION NOT INITIALIZED')
        CALL ERROR$CHVAL('SELECTED SIMULATION ID: ',THIS%ID)
        CALL ERROR$STOP('SIMULATION$GETI4A')
      END IF
      IF(ID.EQ.'LMNX') THEN
        CALL OVERLAPCHECK
        IF(LEN.NE.THIS%NSP) THEN
          CALL ERROR$MSG('LENGTH OF LMNX ARRAY MUST BE EQUAL TO NSP')
          CALL ERROR$I4VAL('LENGTH OF LMNX: ',LEN)
          CALL ERROR$I4VAL('NSP: ',THIS%NSP)
          CALL ERROR$STOP('SIMULATION$GETI4A')
        END IF
        IF(.NOT.ALLOCATED(THIS%LMNX)) THEN
          ALLOCATE(THIS%LMNX(THIS%NSP))
          THIS%LMNX=0
          DO ISP=1,THIS%NSP
            DO LN=1,THIS%LNX(ISP)
              THIS%LMNX(ISP)=THIS%LMNX(ISP)+2*THIS%LOX(LN,ISP)+1
            ENDDO
          ENDDO
        END IF
        VAL=THIS%LMNX
      ELSE IF(ID.EQ.'LNX') THEN
        CALL OVERLAPCHECK
        IF(LEN.NE.THIS%NSP) THEN
          CALL ERROR$MSG('LENGTH OF LNX ARRAY MUST BE EQUAL TO NSP')
          CALL ERROR$I4VAL('LENGTH OF LNX: ',LEN)
          CALL ERROR$I4VAL('NSP: ',THIS%NSP)
          CALL ERROR$STOP('SIMULATION$GETI4A')
        END IF
        VAL=THIS%LNX
      ELSE IF(ID.EQ.'LOX') THEN
        CALL OVERLAPCHECK
        IF(LEN.NE.THIS%LNXX*THIS%NSP) THEN
          CALL ERROR$MSG('LENGTH OF LOX ARRAY MUST BE EQUAL TO LNXX*NSP')
          CALL ERROR$I4VAL('LENGTH OF LOX: ',LEN)
          CALL ERROR$I4VAL('LNXX: ',THIS%LNXX)
          CALL ERROR$I4VAL('NSP: ',THIS%NSP)
          CALL ERROR$STOP('SIMULATION$GETI4A')
        END IF
        VAL(:)=RESHAPE(THIS%LOX,(/THIS%LNXX*THIS%NSP/))
      ELSE IF(ID.EQ.'MAP') THEN
        CALL OVERLAPCHECK
        IF(LEN.NE.THIS%NAT*THIS%LNXX) THEN
          CALL ERROR$MSG('LENGTH OF MAP ARRAY MUST BE EQUAL TO NAT*LNXX')
          CALL ERROR$I4VAL('LENGTH OF MAP: ',LEN)
          CALL ERROR$I4VAL('NAT: ',THIS%NAT)
          CALL ERROR$I4VAL('LNXX: ',THIS%LNXX)
          CALL ERROR$STOP('SIMULATION$GETI4A')
        END IF
        IF(.NOT.ALLOCATED(THIS%MAP)) THEN
          ALLOCATE(THIS%MAP(THIS%NAT,THIS%LNXX))
          THIS%MAP(:,:)=0
          IPRO=0
          DO IAT=1,THIS%NAT
            ISP=THIS%ISPECIES(IAT)
            DO LN=1,THIS%LNX(ISP)
              THIS%MAP(IAT,LN)=IPRO
              L=THIS%LOX(LN,ISP)
              DO M=1,2*L+1
                IPRO=IPRO+1
              ENDDO ! END M
            ENDDO ! END LN
          ENDDO ! END IAT
        END IF
        VAL(:)=RESHAPE(THIS%MAP,(/THIS%NAT*THIS%LNXX/))
      ELSE IF(ID.EQ.'NKDIV') THEN
        IF(LEN.NE.3) THEN
          CALL ERROR$MSG('LENGTH OF NKDIV ARRAY MUST BE 3')
          CALL ERROR$I4VAL('LENGTH OF NKDIV: ',LEN)
          CALL ERROR$STOP('SIMULATION$GETI4A')
        END IF
        VAL=THIS%NKDIV
      ELSE IF(ID.EQ.'ISHIFT') THEN
        IF(LEN.NE.3) THEN
          CALL ERROR$MSG('LENGTH OF ISHIFT ARRAY MUST BE 3')
          CALL ERROR$I4VAL('LENGTH OF ISHIFT: ',LEN)
          CALL ERROR$STOP('SIMULATION$GETI4A')
        END IF
        VAL=THIS%ISHIFT
      ELSE IF(ID.EQ.'ISPECIES') THEN
        IF(LEN.NE.THIS%NAT) THEN
          CALL ERROR$MSG('LENGTH OF ISPECIES ARRAY MUST BE EQUAL TO NAT')
          CALL ERROR$I4VAL('LENGTH OF ISPECIES: ',LEN)
          CALL ERROR$I4VAL('NAT: ',THIS%NAT)
          CALL ERROR$STOP('SIMULATION$GETI4A')
        END IF
        VAL=THIS%ISPECIES
      ELSE IF(ID.EQ.'ATOMMAP') THEN
        IF(.NOT.ALLOCATED(ATOMMAP)) THEN
          CALL ERROR$MSG('ATOMMAP NOT ALLOCATED')
          CALL ERROR$STOP('SIMULATION$GETI4A')
        END IF
        IF(LEN.NE.THIS%NAT) THEN
          CALL ERROR$MSG('LENGTH OF ATOMMAP ARRAY MUST BE EQUAL TO NAT')
          CALL ERROR$I4VAL('LEN OF ATOMMAP: ',LEN)
          CALL ERROR$I4VAL('NAT: ',THIS%NAT)
          CALL ERROR$STOP('SIMULATION$GETI4A')
        END IF
        VAL=ATOMMAP
      ELSE IF(ID.EQ.'TOIRRKPT') THEN
        IF(LEN.NE.THIS%NKPTTOT) THEN
          CALL ERROR$MSG('LEN OF TOIRRKPT ARRAY MUST BE EQUAL TO NKPTTOT')
          CALL ERROR$I4VAL('LEN OF TOIRRKPT: ',LEN)
          CALL ERROR$I4VAL('NKPTTOT: ',THIS%NKPTTOT)
          CALL ERROR$STOP('SIMULATION$GETI4A')
        END IF
        VAL=THIS%TOIRRKPT
      ELSE IF(ID.EQ.'TOTOTKPT') THEN
        IF(LEN.NE.THIS%NKPT) THEN
          CALL ERROR$MSG('LEN OF TOTOTKPT ARRAY MUST BE EQUAL TO NKPT')
          CALL ERROR$I4VAL('LEN OF TOTOTKPT: ',LEN)
          CALL ERROR$I4VAL('NKPT: ',THIS%NKPT)
          CALL ERROR$STOP('SIMULATION$GETI4A')
        END IF
        VAL=THIS%TOTOTKPT
      ELSE
        CALL ERROR$MSG('SIMULATION GETI4A ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('SIMULATION$GETI4A')
      END IF
      RETURN
      CONTAINS 
        SUBROUTINE OVERLAPCHECK
        LOGICAL(4) :: TOVERLAP
        CALL XCNTL$GETL4('TOVERLAP',TOVERLAP)
        IF(TOVERLAP) THEN
          CALL ERROR$MSG('SAFEGUARD FUNCTION:')
          CALL ERROR$MSG('ID NOT AVAILABLE WHEN OVERLAP IS ACTIVE')
          CALL ERROR$CHVAL('ID: ',ID)
          CALL ERROR$STOP('SIMULATION$GETI4A')
        END IF
        RETURN
        END SUBROUTINE OVERLAPCHECK
      END SUBROUTINE SIMULATION$GETI4A
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION$SETI4(ID,VAL)  ! MARK: SIMULATION$SETI4
!     **************************************************************************
!     ** SET INTEGER VALUE IN SIMULATION MODULE                               **
!     ** REQUIRES SELECTED SIMULATION                                         **
!     **************************************************************************
      USE SIMULATION_MODULE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: VAL
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SIMULATION SELECTED')
        CALL ERROR$STOP('SIMULATION$SETI4')
      END IF
      IF(.NOT.THIS%INITIALIZED) THEN
        CALL ERROR$MSG('SIMULATION NOT INITIALIZED')
        CALL ERROR$CHVAL('SELECTED SIMULATION ID: ',THIS%ID)
        CALL ERROR$STOP('SIMULATION$SETI4')
      END IF
      IF(ID.EQ.'SPACEGROUP') THEN
        THIS%SPACEGROUP=VAL
      ELSE
        CALL ERROR$MSG('SIMULATION SETI4 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('SIMULATION$SETI4')
      END IF
      RETURN
      END SUBROUTINE SIMULATION$SETI4
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION$GETI4(ID,VAL)  ! MARK: SIMULATION$GETI4
!     **************************************************************************
!     ** GET INTEGER VALUE FROM SIMULATION MODULE                             **
!     ** REQUIRES SELECTED SIMULATION                                         **
!     **************************************************************************
      USE SIMULATION_MODULE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(OUT) :: VAL
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SIMULATION SELECTED')
        CALL ERROR$STOP('SIMULATION$GETI4')
      END IF
      IF(.NOT.THIS%INITIALIZED) THEN
        CALL ERROR$MSG('SIMULATION NOT INITIALIZED')
        CALL ERROR$CHVAL('SELECTED SIMULATION ID: ',THIS%ID)
        CALL ERROR$STOP('SIMULATION$GETI4')
      END IF
      IF(ID.EQ.'NAT') THEN
        VAL=THIS%NAT
      ELSE IF(ID.EQ.'NSP') THEN
        VAL=THIS%NSP
      ELSE IF(ID.EQ.'NKPT') THEN
        VAL=THIS%NKPT
      ELSE IF(ID.EQ.'NKPTTOT') THEN
        VAL=THIS%NKPTTOT
      ELSE IF(ID.EQ.'NSPIN') THEN
        VAL=THIS%NSPIN
      ELSE IF(ID.EQ.'NDIM') THEN
        VAL=THIS%NDIM
      ELSE IF(ID.EQ.'NPRO') THEN
        VAL=THIS%NPRO
      ELSE IF(ID.EQ.'LNXX') THEN
        VAL=THIS%LNXX
      ELSE IF(ID.EQ.'SPACEGROUP') THEN
        CALL OVERLAPCHECK
        VAL=THIS%SPACEGROUP
      ELSE
        CALL ERROR$MSG('SIMULATION GETI4 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('SIMULATION$GETI4')
      END IF
      RETURN
      CONTAINS 
        SUBROUTINE OVERLAPCHECK
        LOGICAL(4) :: TOVERLAP
        CALL XCNTL$GETL4('TOVERLAP',TOVERLAP)
        IF(TOVERLAP) THEN
          CALL ERROR$MSG('SAFEGUARD FUNCTION:')
          CALL ERROR$MSG('ID NOT AVAILABLE WHEN OVERLAP IS ACTIVE')
          CALL ERROR$CHVAL('ID: ',ID)
          CALL ERROR$STOP('SIMULATION$GETI4A')
        END IF
        RETURN
        END SUBROUTINE OVERLAPCHECK
      END SUBROUTINE SIMULATION$GETI4
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION$SETR8A(ID,LEN,VAL)  ! MARK: SIMULATION$SETR8A
!     **************************************************************************
!     ** SET REAL VALUE ARRAY IN SIMULATION MODULE                            **
!     ** REQUIRES SELECTED SIMULATION                                         **
!     **************************************************************************
      USE SIMULATION_MODULE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: LEN
      REAL(8), INTENT(IN) :: VAL(LEN)
      ! SETTING S REQUIRES NO SELECTED SIMULATION
      IF(ID.EQ.'S') THEN
        IF(SELECTED) THEN
          CALL ERROR$MSG('SAFEGUARD FUNCTION:')
          CALL ERROR$MSG('CANNOT SET S WHEN SIMULATION IS SELECTED')
          CALL ERROR$CHVAL('SELECTED SIMULATION ID: ',THIS%ID)
          CALL ERROR$STOP('SIMULATION$SETR8A')
        END IF
        IF(.NOT.GROUND%INITIALIZED.OR..NOT.EXCITE%INITIALIZED) THEN
          CALL ERROR$MSG('SAFEGUARD FUNCTION:')
          CALL ERROR$MSG('BOTH SIMULATIONS MUST BE INITIALIZED')
          CALL ERROR$L4VAL('GROUND: ',GROUND%INITIALIZED)
          CALL ERROR$L4VAL('EXCITE: ',EXCITE%INITIALIZED)
          CALL ERROR$CHVAL('ID: ',ID)
          CALL ERROR$STOP('SIMULATION$SETR8A')
        END IF
        IF(LEN.NE.GROUND%NAT*GROUND%LNXX*EXCITE%LNXX) THEN
          CALL ERROR$MSG('LENGTH OF S ARRAY MUST BE EQUAL TO NAT*LNXX1*LNXX2')
          CALL ERROR$I4VAL('LEN OF S: ',LEN)
          CALL ERROR$I4VAL('NAT: ',GROUND%NAT)
          CALL ERROR$I4VAL('LNXX1: ',GROUND%LNXX)
          CALL ERROR$I4VAL('LNXX2: ',EXCITE%LNXX)
          CALL ERROR$STOP('SIMULATION$SETR8A')
        END IF
        IF(ALLOCATED(S)) THEN
          CALL ERROR$MSG('SAFEGUARD FUNCTION:')
          CALL ERROR$MSG('CANNOT SET S WHEN ALREADY ALLOCATED')
        ELSE
          ALLOCATE(S(GROUND%NAT,GROUND%LNXX,EXCITE%LNXX))
        END IF
        S(:,:,:)=RESHAPE(VAL,(/GROUND%NAT,GROUND%LNXX,EXCITE%LNXX/))
      ELSE
        ! FOR ALL OTHER IDS, SELECTED SIMULATION IS REQUIRED
        IF(.NOT.SELECTED) THEN
          CALL ERROR$MSG('NO SIMULATION SELECTED')
          CALL ERROR$STOP('SIMULATION$SETR8A')
        END IF
        IF(.NOT.THIS%INITIALIZED) THEN
          CALL ERROR$MSG('SIMULATION NOT INITIALIZED')
          CALL ERROR$CHVAL('SELECTED SIMULATION ID: ',THIS%ID)
          CALL ERROR$STOP('SIMULATION$SETR8A')
        END IF
        IF(ID.EQ.'RBAS') THEN
          IF(LEN.NE.9) THEN
            CALL ERROR$MSG('LENGTH OF RBAS ARRAY MUST BE 9')
            CALL ERROR$I4VAL('LENGTH OF RBAS: ',LEN)
            CALL ERROR$STOP('SIMULATION$SETR8A')
          END IF
          THIS%RBAS=RESHAPE(VAL,(/3,3/))
          THIS%VCELL=THIS%RBAS(1,1)*(THIS%RBAS(2,2)*THIS%RBAS(3,3)-THIS%RBAS(2,3)*THIS%RBAS(3,2)) &
     &           +THIS%RBAS(2,1)*(THIS%RBAS(3,2)*THIS%RBAS(1,3)-THIS%RBAS(3,3)*THIS%RBAS(1,2)) &
     &           +THIS%RBAS(3,1)*(THIS%RBAS(1,2)*THIS%RBAS(2,3)-THIS%RBAS(1,3)*THIS%RBAS(2,2)) 
        ELSE IF(ID.EQ.'R') THEN
          IF(LEN.NE.THIS%NAT*3) THEN
            CALL ERROR$MSG('LENGTH OF R ARRAY MUST BE EQUAL TO NAT*3')
            CALL ERROR$I4VAL('LENGTH OF R: ',LEN)
            CALL ERROR$I4VAL('NAT: ',THIS%NAT)
            CALL ERROR$STOP('SIMULATION$SETR8A')
          END IF
          THIS%R(:,:)=RESHAPE(VAL,(/3,THIS%NAT/))
        ELSE IF(ID.EQ.'XK') THEN
          IF(LEN.NE.THIS%NKPT*3) THEN
            CALL ERROR$MSG('LENGTH OF XK ARRAY MUST BE EQUAL TO NKPT*3')
            CALL ERROR$I4VAL('LENGTH OF XK: ',LEN)
            CALL ERROR$I4VAL('NKPT: ',THIS%NKPT)
            CALL ERROR$STOP('SIMULATION$SETR8A')
          END IF
          THIS%XK(:,:)=RESHAPE(VAL,(/3,THIS%NKPT/))
        ELSE IF(ID.EQ.'WKPT') THEN
          IF(LEN.NE.THIS%NKPT) THEN
            CALL ERROR$MSG('LENGTH OF WKPT ARRAY MUST BE EQUAL TO NKPT')
            CALL ERROR$I4VAL('LENGTH OF WKPT: ',LEN)
            CALL ERROR$I4VAL('NKPT: ',THIS%NKPT)
            CALL ERROR$STOP('SIMULATION$SETR8A')
          END IF
          THIS%WKPT(:)=VAL
        ELSE
          CALL ERROR$MSG('SIMULATION SETR8A ID NOT RECOGNIZED')
          CALL ERROR$CHVAL('ID: ',ID)
          CALL ERROR$STOP('SIMULATION$SETR8A')
        END IF
      END IF
      RETURN
      END SUBROUTINE SIMULATION$SETR8A
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION$GETR8A(ID,LEN,VAL)  ! MARK: SIMULATION$GETR8A
!     **************************************************************************
!     ** GET REAL VALUE ARRAY FROM SIMULATION MODULE                          **
!     ** REQUIRES SELECTED SIMULATION                                         **
!     **************************************************************************
      USE SIMULATION_MODULE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: LEN
      REAL(8), INTENT(OUT) :: VAL(LEN)
      ! GETTING S REQUIRES NO SELECTED SIMULATION
      IF(ID.EQ.'S') THEN
        CALL OVERLAPCHECK
        IF(SELECTED) THEN
          CALL ERROR$MSG('SAFEGUARD FUNCTION:')
          CALL ERROR$MSG('CANNOT GET S WHEN SIMULATION IS SELECTED')
          CALL ERROR$CHVAL('SELECTED SIMULATION ID: ',THIS%ID)
          CALL ERROR$STOP('SIMULATION$GETR8A')
        END IF
        IF(.NOT.ALLOCATED(S)) THEN
          CALL ERROR$MSG('S NOT ALLOCATED')
          CALL ERROR$STOP('SIMULATION$GETR8A')
        END IF
        IF(LEN.NE.GROUND%NAT*GROUND%LNXX*EXCITE%LNXX) THEN
          CALL ERROR$MSG('LENGTH OF S ARRAY MUST BE EQUAL TO NAT*LNXX1*LNXX2')
          CALL ERROR$I4VAL('LEN OF S: ',LEN)
          CALL ERROR$I4VAL('NAT: ',GROUND%NAT)
          CALL ERROR$I4VAL('LNXX1: ',GROUND%LNXX)
          CALL ERROR$I4VAL('LNXX2: ',EXCITE%LNXX)
          CALL ERROR$STOP('SIMULATION$GETR8A')
        END IF
        VAL(:)=RESHAPE(S,(/GROUND%NAT*GROUND%LNXX*EXCITE%LNXX/))
      ELSE
        ! FOR ALL OTHER IDS, SELECTED SIMULATION IS REQUIRED
        IF(.NOT.SELECTED) THEN
          CALL ERROR$MSG('NO SIMULATION SELECTED')
          CALL ERROR$STOP('SIMULATION$GETR8A')
        END IF
        IF(.NOT.THIS%INITIALIZED) THEN
          CALL ERROR$MSG('SIMULATION NOT INITIALIZED')
          CALL ERROR$CHVAL('SELECTED SIMULATION ID: ',THIS%ID)
          CALL ERROR$STOP('SIMULATION$GETR8A')
        END IF
        IF(ID.EQ.'RBAS') THEN
          IF(LEN.NE.9) THEN
            CALL ERROR$MSG('LENGTH OF RBAS ARRAY MUST BE 9')
            CALL ERROR$I4VAL('LENGTH OF RBAS: ',LEN)
            CALL ERROR$STOP('SIMULATION$GETR8A')
          END IF
          VAL(:)=RESHAPE(THIS%RBAS,(/9/))
        ELSE IF(ID.EQ.'R') THEN
          IF(LEN.NE.THIS%NAT*3) THEN
            CALL ERROR$MSG('LENGTH OF R ARRAY MUST BE EQUAL TO NAT*3')
            CALL ERROR$I4VAL('LENGTH OF R: ',LEN)
            CALL ERROR$I4VAL('NAT: ',THIS%NAT)
            CALL ERROR$STOP('SIMULATION$GETR8A')
          END IF
          VAL(:)=RESHAPE(THIS%R,(/3*THIS%NAT/))
        ELSE IF(ID.EQ.'XK') THEN
          IF(LEN.NE.THIS%NKPT*3) THEN
            CALL ERROR$MSG('LENGTH OF XK ARRAY MUST BE EQUAL TO NKPT*3')
            CALL ERROR$I4VAL('LENGTH OF XK: ',LEN)
            CALL ERROR$I4VAL('NKPT: ',THIS%NKPT)
            CALL ERROR$STOP('SIMULATION$GETR8A')
          END IF
          VAL(:)=RESHAPE(THIS%XK,(/3*THIS%NKPT/))
        ELSE IF(ID.EQ.'WKPT') THEN
          IF(LEN.NE.THIS%NKPT) THEN
            CALL ERROR$MSG('LENGTH OF WKPT ARRAY MUST BE EQUAL TO NKPT')
            CALL ERROR$I4VAL('LENGTH OF WKPT: ',LEN)
            CALL ERROR$I4VAL('NKPT: ',THIS%NKPT)
            CALL ERROR$STOP('SIMULATION$GETR8A')
          END IF
          VAL(:)=THIS%WKPT
        ELSE
          CALL ERROR$MSG('SIMULATION GETR8A ID NOT RECOGNIZED')
          CALL ERROR$CHVAL('ID: ',ID)
          CALL ERROR$STOP('SIMULATION$GETR8A')
        END IF
      END IF
      RETURN
      CONTAINS 
        SUBROUTINE OVERLAPCHECK
        LOGICAL(4) :: TOVERLAP
        CALL XCNTL$GETL4('TOVERLAP',TOVERLAP)
        IF(TOVERLAP) THEN
          CALL ERROR$MSG('SAFEGUARD FUNCTION:')
          CALL ERROR$MSG('ID NOT AVAILABLE WHEN OVERLAP IS ACTIVE')
          CALL ERROR$CHVAL('ID: ',ID)
          CALL ERROR$STOP('SIMULATION$GETI4A')
        END IF
        RETURN
        END SUBROUTINE OVERLAPCHECK
      END SUBROUTINE SIMULATION$GETR8A
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION$SETR8(ID,VAL)  ! MARK: SIMULATION$SETR8
!     **************************************************************************
!     ** SET REAL VALUE IN SIMULATION MODULE                                  **
!     ** REQUIRES SELECTED SIMULATION                                         **
!     **************************************************************************
      USE SIMULATION_MODULE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      REAL(8), INTENT(IN) :: VAL
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SIMULATION SELECTED')
        CALL ERROR$STOP('SIMULATION$SETR8')
      END IF
      IF(.NOT.THIS%INITIALIZED) THEN
        CALL ERROR$MSG('SIMULATION NOT INITIALIZED')
        CALL ERROR$CHVAL('SELECTED SIMULATION ID: ',THIS%ID)
        CALL ERROR$STOP('SIMULATION$SETR8')
      END IF
      IF(ID.EQ.'RNTOT') THEN
        THIS%RNTOT=VAL
      ELSE IF(ID.EQ.'NEL') THEN
        THIS%NEL=VAL
      ELSE IF(ID.EQ.'ETOT') THEN
        THIS%ETOT=VAL
      ELSE IF(ID.EQ.'EDFT') THEN
        THIS%EDFT=VAL
      ELSE IF(ID.EQ.'ECORE') THEN
        THIS%ECORE=VAL
      ELSE
        CALL ERROR$MSG('SIMULATION SETR8 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('SIMULATION$SETR8')
      END IF
      RETURN
      END SUBROUTINE SIMULATION$SETR8
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION$GETR8(ID,VAL)  ! MARK: SIMULATION$GETR8
!     **************************************************************************
!     ** GET REAL VALUE FROM SIMULATION MODULE                                **
!     ** REQUIRES SELECTED SIMULATION                                         **
!     **************************************************************************
      USE SIMULATION_MODULE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      REAL(8), INTENT(OUT) :: VAL
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SIMULATION SELECTED')
        CALL ERROR$STOP('SIMULATION$GETR8')
      END IF
      IF(.NOT.THIS%INITIALIZED) THEN
        CALL ERROR$MSG('SIMULATION NOT INITIALIZED')
        CALL ERROR$CHVAL('SELECTED SIMULATION ID: ',THIS%ID)
        CALL ERROR$STOP('SIMULATION$GETR8')
      END IF
      IF(ID.EQ.'RNTOT') THEN
        VAL=THIS%RNTOT
      ELSE IF(ID.EQ.'NEL') THEN
        VAL=THIS%NEL
      ELSE IF(ID.EQ.'ETOT') THEN
        ! IF ETOT IS HUGE, IT MEANS IT HAS NOT BEEN CALCULATED YET
        IF(THIS%ETOT.EQ.HUGE(1.D0)) THEN
          ! IF ECORE IS HUGE, IT MEANS IT HAS NOT BEEN CALCULATED YET
          IF(THIS%ECORE.EQ.HUGE(1.D0)) CALL SIMULATION_ECORE
          THIS%ETOT=THIS%EDFT+THIS%ECORE
        END IF
        VAL=THIS%ETOT
      ELSE IF(ID.EQ.'EDFT') THEN
        VAL=THIS%EDFT
      ELSE IF(ID.EQ.'ECORE') THEN
        ! IF ECORE IS HUGE, IT MEANS IT HAS NOT BEEN CALCULATED YET
        IF(THIS%ECORE.EQ.HUGE(1.D0)) CALL SIMULATION_ECORE
        VAL=THIS%ECORE
      ELSE IF(ID.EQ.'VCELL') THEN
        ! IF VCELL IS NEGATIVE HUGE, IT MEANS IT HAS NOT BEEN CALCULATED YET
        IF(THIS%VCELL.EQ.-HUGE(1.D0)) THEN
          CALL ERROR$MSG('VCELL NOT CALCULATED YET, NEEDS RBAS')
          CALL ERROR$CHVAL('SELECTED SIMULATION ID: ',THIS%ID)
          CALL ERROR$STOP('SIMULATION$GETR8')
        END IF
        VAL=THIS%VCELL  
      ELSE
        CALL ERROR$MSG('SIMULATION GETR8 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('SIMULATION$GETR8')
      END IF
      RETURN
      END SUBROUTINE SIMULATION$GETR8
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION$SETL4(ID,VAL)  ! MARK: SIMULATION$SETL4
!     **************************************************************************
!     ** SET LOGICAL VALUE IN SIMULATION MODULE                               **
!     ** REQUIRES SELECTED SIMULATION                                         **
!     **************************************************************************
      USE SIMULATION_MODULE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      LOGICAL(4), INTENT(IN) :: VAL
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SIMULATION SELECTED')
        CALL ERROR$STOP('SIMULATION$SETL4')
      END IF
      IF(.NOT.THIS%INITIALIZED) THEN
        CALL ERROR$MSG('SIMULATION NOT INITIALIZED')
        CALL ERROR$CHVAL('SELECTED SIMULATION ID: ',THIS%ID)
        CALL ERROR$STOP('SIMULATION$SETL4')
      END IF
      IF(ID.EQ.'TINV') THEN
        THIS%TINV=VAL
      ELSE IF(ID.EQ.'TSHIFT') THEN
        THIS%TSHIFT=VAL
      ELSE
        CALL ERROR$MSG('SIMULATION SETL4 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('SIMULATION$SETL4')
      END IF
      RETURN
      END SUBROUTINE SIMULATION$SETL4
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION$GETL4(ID,VAL)  ! MARK: SIMULATION$GETL4
!     **************************************************************************
!     ** GET LOGICAL VALUE FROM SIMULATION MODULE                             **
!     ** REQUIRES SELECTED SIMULATION                                         **
!     **************************************************************************
      USE SIMULATION_MODULE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      LOGICAL(4), INTENT(OUT) :: VAL
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SIMULATION SELECTED')
        CALL ERROR$STOP('SIMULATION$GETL4')
      END IF
      IF(.NOT.THIS%INITIALIZED) THEN
        CALL ERROR$MSG('SIMULATION NOT INITIALIZED')
        CALL ERROR$CHVAL('SELECTED SIMULATION ID: ',THIS%ID)
        CALL ERROR$STOP('SIMULATION$GETL4')
      END IF
      IF(ID.EQ.'TINV') THEN
        VAL=THIS%TINV
      ELSE IF(ID.EQ.'TSHIFT') THEN
        VAL=THIS%TSHIFT
      ELSE
        CALL ERROR$MSG('SIMULATION GETL4 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('SIMULATION$GETL4')
      END IF
      RETURN
      END SUBROUTINE SIMULATION$GETL4
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION$GETL4A(ID,LEN,VAL)  ! MARK: SIMULATION$GETL4A
!     **************************************************************************
!     ** GET LOGICAL VALUE ARRAY FROM SIMULATION MODULE                        **
!     ** REQUIRES SELECTED SIMULATION                                         **
!     **************************************************************************
      USE SIMULATION_MODULE, ONLY: THIS,SELECTED
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: LEN
      LOGICAL(4), INTENT(OUT) :: VAL(LEN)
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SIMULATION SELECTED')
        CALL ERROR$STOP('SIMULATION$GETL4A')
      END IF
      IF(.NOT.THIS%INITIALIZED) THEN
        CALL ERROR$MSG('SIMULATION NOT INITIALIZED')
        CALL ERROR$CHVAL('SELECTED SIMULATION ID: ',THIS%ID)
        CALL ERROR$STOP('SIMULATION$GETL4A')
      END IF
      IF(ID.EQ.'TINVARR') THEN
        IF(LEN.NE.THIS%NKPT) THEN
          CALL ERROR$MSG('LENGTH OF TINVARR ARRAY MUST BE EQUAL TO NKPT')
          CALL ERROR$I4VAL('LENGTH OF TINVARR: ',LEN)
          CALL ERROR$I4VAL('NKPT: ',THIS%NKPT)
          CALL ERROR$STOP('SIMULATION$GETL4A')
        END IF
        VAL=THIS%TINVARR
      ELSE IF(ID.EQ.'TIRRKPT') THEN
        IF(LEN.NE.THIS%NKPTTOT) THEN
          CALL ERROR$MSG('LENGTH OF TIRRKPT ARRAY MUST BE EQUAL TO NKPTTOT')
          CALL ERROR$I4VAL('LENGTH OF TIRRKPT: ',LEN)
          CALL ERROR$I4VAL('NKPTTOT: ',THIS%NKPTTOT)
          CALL ERROR$STOP('SIMULATION$GETL4A')
        END IF
        VAL=THIS%TIRRKPT
      ELSE
        CALL ERROR$MSG('SIMULATION GETL4A ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('SIMULATION$GETL4A')
      END IF
      RETURN
      END SUBROUTINE SIMULATION$GETL4A
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION$SETCHA(ID,LEN,VAL)  ! MARK: SIMULATION$SETCHA
!     **************************************************************************
!     ** SET CHARACTER VALUE ARRAY IN SIMULATION MODULE                       **
!     ** REQUIRES SELECTED SIMULATION                                         **
!     **************************************************************************
      USE SIMULATION_MODULE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: LEN
      CHARACTER(*), INTENT(IN) :: VAL(LEN)
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SIMULATION SELECTED')
        CALL ERROR$STOP('SIMULATION$SETCHA')
      END IF
      IF(.NOT.THIS%INITIALIZED) THEN
        CALL ERROR$MSG('SIMULATION NOT INITIALIZED')
        CALL ERROR$CHVAL('SELECTED SIMULATION ID: ',THIS%ID)
        CALL ERROR$STOP('SIMULATION$SETCHA')
      END IF
      IF(ID.EQ.'ATOMID') THEN
        IF(LEN.NE.THIS%NAT) THEN
          CALL ERROR$MSG('LENGTH OF ATOMID ARRAY MUST BE EQUAL TO NAT')
          CALL ERROR$I4VAL('LENGTH OF ATOMID: ',LEN)
          CALL ERROR$I4VAL('NAT: ',THIS%NAT)
          CALL ERROR$STOP('SIMULATION$SETCHA')
        END IF
        THIS%ATOMID=VAL
      ELSE
        CALL ERROR$MSG('SIMULATION SETCHA ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('SIMULATION$SETCHA')
      END IF
      RETURN
      END SUBROUTINE SIMULATION$SETCHA
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION$GETCHA(ID,LEN,VAL)  ! MARK: SIMULATION$GETCHA
!     **************************************************************************
!     ** GET CHARACTER VALUE ARRAY FROM SIMULATION MODULE                     **
!     ** REQUIRES SELECTED SIMULATION                                         **
!     **************************************************************************
      USE SIMULATION_MODULE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: LEN
      CHARACTER(*), INTENT(OUT) :: VAL(LEN)
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SIMULATION SELECTED')
        CALL ERROR$STOP('SIMULATION$GETCHA')
      END IF
      IF(.NOT.THIS%INITIALIZED) THEN
        CALL ERROR$MSG('SIMULATION NOT INITIALIZED')
        CALL ERROR$CHVAL('SELECTED SIMULATION ID: ',THIS%ID)
        CALL ERROR$STOP('SIMULATION$GETCHA')
      END IF
      IF(ID.EQ.'ATOMID') THEN
        IF(LEN.NE.THIS%NAT) THEN
          CALL ERROR$MSG('LENGTH OF ATOMID ARRAY MUST BE EQUAL TO NAT')
          CALL ERROR$I4VAL('LENGTH OF ATOMID: ',LEN)
          CALL ERROR$I4VAL('NAT: ',THIS%NAT)
          CALL ERROR$STOP('SIMULATION$GETCHA')
        END IF
        VAL=THIS%ATOMID
      ELSE
        CALL ERROR$MSG('SIMULATION GETCHA ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('SIMULATION$GETCHA')
      END IF
      RETURN
      END SUBROUTINE SIMULATION$GETCHA
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION$SETCH(ID,VAL)  ! MARK: SIMULATION$SETCH
!     **************************************************************************
!     ** SET CHARACTER VALUE IN SIMULATION MODULE                             **
!     ** CAN SET VALUES BEFORE INITIALIZATION                                 **
!     ** REQUIRES SELECTED SIMULATION                                         **
!     **************************************************************************
      USE SIMULATION_MODULE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      CHARACTER(*), INTENT(IN) :: VAL
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SIMULATION SELECTED')
        CALL ERROR$STOP('SIMULATION$SETCH')
      END IF
      IF(ID.EQ.'ID') THEN
        THIS%ID=VAL
      ELSE IF(ID.EQ.'FILE') THEN
        THIS%FILE=VAL
      ELSE
        CALL ERROR$MSG('SIMULATION SETCH ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('SIMULATION$SETCH')
      END IF
      RETURN
      END SUBROUTINE SIMULATION$SETCH
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION$GETCH(ID,VAL)  ! MARK: SIMULATION$GETCH
!     **************************************************************************
!     ** GET CHARACTER VALUE FROM SIMULATION MODULE                           **
!     ** REQUIRES SELECTED SIMULATION                                         **
!     **************************************************************************
      USE SIMULATION_MODULE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      CHARACTER(*), INTENT(OUT) :: VAL
      LOGICAL(4) :: TOVERLAP
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SIMULATION SELECTED')
        CALL ERROR$STOP('SIMULATION$GETCH')
      END IF
      IF(ID.EQ.'ID') THEN
        VAL=THIS%ID
      ELSE IF(ID.EQ.'FILE') THEN
        CALL XCNTL$GETL4('TOVERLAP',TOVERLAP)
        IF(TOVERLAP) THEN
          CALL ERROR$MSG('SAFEGUARD FUNCTION:')
          CALL ERROR$MSG('FILE NOT AVAILABLE WHEN OVERLAP IS ACTIVE')
          CALL ERROR$CHVAL('SELECTED SIMULATION ID: ',THIS%ID)
          CALL ERROR$STOP('SIMULATION$GETCH')
        END IF
        VAL=THIS%FILE
      ELSE IF(ID.EQ.'FLAG') THEN
        IF(.NOT.THIS%INITIALIZED) THEN
        CALL ERROR$MSG('SIMULATION NOT INITIALIZED')
        CALL ERROR$CHVAL('SELECTED SIMULATION ID: ',THIS%ID)
        CALL ERROR$STOP('SIMULATION$GETCH')
      END IF
        VAL=THIS%FLAG
      ELSE
        CALL ERROR$MSG('SIMULATION GETCH ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('SIMULATION$GETCH')
      END IF
      RETURN
      END SUBROUTINE SIMULATION$GETCH
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION_ECORE
!     **************************************************************************
!     ** CALCULATE ECORE FOR SELECTED SIMULATION                              **
!     ** REQUIRES SELECTED SIMULATION                                         **
!     **************************************************************************
      USE SIMULATION_MODULE, ONLY: SELECTED,THIS
      IMPLICIT NONE
      REAL(8) :: E
      INTEGER(4) :: IAT
      INTEGER(4) :: ISP
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SIMULATION SELECTED')
        CALL ERROR$STOP('SIMULATION_ECORE')
      END IF
      THIS%ECORE=0.D0
      CALL XSETUP$SELECT(THIS%ID)
      DO IAT=1,THIS%NAT
        ISP=THIS%ISPECIES(IAT)
        CALL XSETUP$GETR8('ECORE',ISP,E)
        THIS%ECORE=THIS%ECORE+E
      ENDDO
      CALL XSETUP$UNSELECT
      RETURN
      END SUBROUTINE SIMULATION_ECORE
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION_WRITEOVERLAP(NFIL)
!     **************************************************************************
!     ** WRITE SIMULATION MODULE TO OVERLAP FILE WHICH SERVES AS A RESTART    **
!     ** FILE FOR THE SIMULATION                                              **
!     ** REQUIRES NO SELECTED SIMULATION                                      **
!     **************************************************************************
      USE SIMULATION_MODULE, ONLY: THIS,SELECTED,ATOMMAP
      USE STRINGS_MODULE
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: NFIL
      INTEGER(4) :: NTASKS,THISTASK,RTASK
      INTEGER(4), PARAMETER :: NSIM=2
      INTEGER(4) :: ISIM
      INTEGER(4) :: ILOGICAL
      CHARACTER(10) :: KEY

      CALL MPE$QUERY('~',NTASKS,THISTASK)
      CALL KSMAP$READTASK(RTASK)
      IF(RTASK.NE.THISTASK) RETURN
                          CALL TRACE$PUSH('SIMULATION_WRITEOVERLAP')
      IF(SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('CANNOT WRITEOVERLAP WHEN SIMULATION IS SELECTED')
        CALL ERROR$CHVAL('SELECTED SIMULATION ID: ',THIS%ID)
        CALL ERROR$STOP('SIMULATION_WRITEOVERLAP')
      END IF
      KEY=+'SIMULATION'
      WRITE(NFIL)KEY
      DO ISIM=1,NSIM
        CALL SIMULATION$ISELECT(ISIM)
        IF(.NOT.THIS%INITIALIZED) THEN
          CALL ERROR$MSG('SIMULATION NOT INITIALIZED')
          CALL ERROR$CHVAL('SELECTED SIMULATION ID: ',THIS%ID)
          CALL ERROR$STOP('SIMULATION_WRITEOVERLAP')
        END IF
        ! ID,NAT,NSP,NKPT,NSPIN,NDIM,NPRO,LNXX,FLAG
        WRITE(NFIL)THIS%ID,THIS%NAT,THIS%NSP,THIS%NKPT,THIS%NSPIN,THIS%NDIM, &
     &             THIS%NPRO,THIS%LNXX,THIS%FLAG
        ILOGICAL=0
        IF(THIS%TINV) ILOGICAL=1
        ! TINV,NKDIV,ISHIFT,RNTOT,NEL,ETOT,EDFT,ECORE
        WRITE(NFIL)ILOGICAL,THIS%NKDIV,THIS%ISHIFT,THIS%RNTOT,THIS%NEL, &
     &             THIS%ETOT,THIS%EDFT,THIS%ECORE
        ILOGICAL=0
        IF(THIS%TSHIFT) ILOGICAL=1
        ! TSHIFT,RBAS,R,ATOMID,ISPECIES
        WRITE(NFIL)ILOGICAL,THIS%RBAS,THIS%R,THIS%ATOMID,THIS%ISPECIES
        ! XK,WKPT
        WRITE(NFIL)THIS%XK,THIS%WKPT
        ! ATOMMAP
        WRITE(NFIL)ATOMMAP
        CALL SIMULATION$UNSELECT
      ENDDO
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE SIMULATION_WRITEOVERLAP
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION_READOVERLAP(NFIL)
!     **************************************************************************
!     ** READ SIMULATION MODULE FROM OVERLAP FILE WHICH SERVES AS A RESTART   **
!     ** FILE FOR THE SIMULATION                                              **
!     ** REQUIRES NO SELECTED SIMULATION                                      **
!     **************************************************************************
      USE SIMULATION_MODULE, ONLY: THIS,SELECTED
      USE MPE_MODULE
      USE STRINGS_MODULE
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: NFIL
      INTEGER(4) :: NTASKS,THISTASK,RTASK
      INTEGER(4), PARAMETER :: NSIM=2
      INTEGER(4) :: ISIM
      INTEGER(4) :: ILOGICAL
      CHARACTER(6) :: ID,FLAG
      INTEGER(4) :: NAT,NSP,NKPT,NSPIN,NDIM,NPRO,LNXX
      INTEGER(4) :: NKDIV(3),ISHIFT(3)
      LOGICAL(4) :: TINV,TSHIFT
      REAL(8) :: RNTOT,NEL,ETOT,EDFT,ECORE
      REAL(8) :: RBAS(3,3)
      REAL(8), ALLOCATABLE :: R(:,:)
      REAL(8), ALLOCATABLE :: XK(:,:)
      REAL(8), ALLOCATABLE :: WKPT(:)
      CHARACTER(16), ALLOCATABLE :: ATOMID(:)
      INTEGER(4), ALLOCATABLE :: ISPECIES(:)
      INTEGER(4), ALLOCATABLE :: ATOMMAP(:)
      REAL(8) :: VCELL
      CHARACTER(10) :: KEY

                          CALL TRACE$PUSH('SIMULATION_READOVERLAP')
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      ! CHECK FOR KEY
      IF(THISTASK.EQ.1) THEN 
        READ(NFIL)KEY
        IF(KEY.NE.+'SIMULATION') THEN
          CALL ERROR$MSG('OVERLAP FILE CORRUPTED')
          CALL ERROR$CHVAL('KEY: ',KEY)
          CALL ERROR$STOP('SIMULATION_READOVERLAP')
        END IF
      END IF
      DO ISIM=1,NSIM
        CALL SIMULATION$ISELECT(ISIM)
        IF(THISTASK.EQ.1) THEN
          ! ID,NAT,NSP,NKPT,NSPIN,NDIM,NPRO,LNXX,FLAG
          READ(NFIL)ID,NAT,NSP,NKPT,NSPIN,NDIM,NPRO,LNXX,FLAG
          ! TINV,NKDIV,ISHIFT,RNTOT,NEL,ETOT,EDFT,ECORE
          READ(NFIL)ILOGICAL,NKDIV,ISHIFT,RNTOT,NEL,ETOT,EDFT,ECORE
          TINV=.FALSE.
          IF(ILOGICAL.EQ.1) TINV=.TRUE.
        END IF
        CALL MPE$BROADCAST('~',1,ID)
        CALL SIMULATION$SETCH('ID',ID)
        CALL MPE$BROADCAST('~',1,NAT)
        CALL MPE$BROADCAST('~',1,NSP)
        CALL MPE$BROADCAST('~',1,NKPT)
        CALL MPE$BROADCAST('~',1,NSPIN)
        CALL MPE$BROADCAST('~',1,NDIM)
        CALL MPE$BROADCAST('~',1,NPRO)
        CALL MPE$BROADCAST('~',1,LNXX)
        CALL MPE$BROADCAST('~',1,FLAG)
        CALL SIMULATION$INIT(NAT,NSP,NKPT,NSPIN,NDIM,NPRO,LNXX,FLAG)
        ! DISTRIBUTE WORKLOAD FOR K-POINT AND SPIN LOOPS WHILE READING
        CALL KSMAP$INIT(NKPT,NSPIN)
        CALL KSMAP$READTASK(RTASK)

        CALL MPE$BROADCAST('~',1,TINV)
        CALL MPE$BROADCAST('~',1,NKDIV)
        CALL MPE$BROADCAST('~',1,ISHIFT)
        CALL MPE$BROADCAST('~',1,RNTOT)
        CALL MPE$BROADCAST('~',1,NEL)
        CALL MPE$BROADCAST('~',1,ETOT)
        CALL MPE$BROADCAST('~',1,EDFT)
        CALL MPE$BROADCAST('~',1,ECORE)
        CALL SIMULATION$SETL4('TINV',TINV)
        CALL SIMULATION$SETI4A('NKDIV',3,NKDIV)
        CALL SIMULATION$SETI4A('ISHIFT',3,ISHIFT)
        CALL SIMULATION$SETR8('RNTOT',RNTOT)
        CALL SIMULATION$SETR8('NEL',NEL)
        CALL SIMULATION$SETR8('ETOT',ETOT)
        CALL SIMULATION$SETR8('EDFT',EDFT)
        CALL SIMULATION$SETR8('ECORE',ECORE)

        ALLOCATE(R(3,NAT))
        ALLOCATE(ATOMID(NAT))
        ALLOCATE(ISPECIES(NAT))
        ALLOCATE(XK(3,NKPT))
        ALLOCATE(WKPT(NKPT))
        ALLOCATE(ATOMMAP(NAT))
        IF(THISTASK.EQ.RTASK) THEN
          ! TSHIFT,RBAS,R,ATOMID,ISPECIES
          READ(NFIL)ILOGICAL,RBAS,R,ATOMID,ISPECIES
          TSHIFT=.FALSE.
          IF(ILOGICAL.EQ.1) TSHIFT=.TRUE.
          ! XK,WKPT
          READ(NFIL)XK,WKPT
          ! ATOMMAP
          READ(NFIL)ATOMMAP
        END IF
        CALL MPE$BROADCAST('~',RTASK,TSHIFT)
        CALL MPE$BROADCAST('~',RTASK,RBAS)
        CALL MPE$BROADCAST('~',RTASK,R)
        CALL MPE$BROADCAST('~',RTASK,ATOMID)
        CALL MPE$BROADCAST('~',RTASK,ISPECIES)
        CALL MPE$BROADCAST('~',RTASK,XK)
        CALL MPE$BROADCAST('~',RTASK,WKPT)
        CALL MPE$BROADCAST('~',RTASK,ATOMMAP)
        CALL SIMULATION$SETL4('TSHIFT',TSHIFT)
        CALL SIMULATION$SETR8A('RBAS',9,RBAS)
        CALL SIMULATION$SETR8A('R',3*NAT,R)
        CALL SIMULATION$SETCHA('ATOMID',NAT,ATOMID)
        CALL SIMULATION$SETI4A('ISPECIES',NAT,ISPECIES)
        CALL SIMULATION$SETR8A('XK',3*NKPT,XK)
        CALL SIMULATION$SETR8A('WKPT',NKPT,WKPT)
        CALL BRILLOUIN$MSHNOSYM(TINV,RBAS,NKDIV,ISHIFT)
        CALL SIMULATION$CHECKINVERSION
        CALL SIMULATION$KPTMAP
        DEALLOCATE(R)
        DEALLOCATE(ATOMID)
        DEALLOCATE(ISPECIES)
        DEALLOCATE(XK)
        DEALLOCATE(WKPT)
        DEALLOCATE(ATOMMAP)
        CALL SIMULATION$UNSELECT
      ENDDO
      CALL SIMULATION_ATOMMAP
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE SIMULATION_READOVERLAP
!
!     ==========================================================================
!     ==========================================================================
!     ==                   XSETUP MODULE FUNCTIONS                            ==
!     ==========================================================================
!     ==========================================================================
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XSETUP$REPORT(NFIL)  ! MARK: XSETUP$REPORT
!     **************************************************************************
!     ** REPORT XSETUP ARRAY                                                  **
!     ** REQUIRES SELECTED XSETUP ARRAY                                       **
!     **************************************************************************
      USE XSETUP_MODULE, ONLY: THIS,SELECTED,THISNSP
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: NFIL
      INTEGER(4) :: ISP
      CHARACTER(256) :: FORMAT
      INTEGER(4) :: NTASKS,THISTASK,RTASK
      LOGICAL(4) :: TOVERLAP
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      CALL KSMAP$READTASK(RTASK)
      IF(RTASK.NE.THISTASK) RETURN
      CALL XCNTL$GETL4('TOVERLAP',TOVERLAP)
      IF(TOVERLAP) RETURN
                          CALL TRACE$PUSH('XSETUP$REPORT')
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO XSETUP SELECTED')
        CALL ERROR$STOP('XSETUP$REPORT')
      END IF
      WRITE(NFIL,FMT='(A)')'SETUP REPORT'
      WRITE(NFIL,FMT='(5A10)')'SETUP','GID','ECORE[H]','LNX','LOX'
      ! LNXX IS THE SAME FOR ALL SPECIES WITHIN ONE SIMULATION
      WRITE(FORMAT,'("(2I10,F10.4,I10,",I0,"I10)")')THIS(1)%LNXX
      DO ISP=1,THISNSP
        WRITE(NFIL,FMT=FORMAT)ISP,THIS(ISP)%GID,THIS(ISP)%ECORE, &
     &                          THIS(ISP)%LNX,THIS(ISP)%L(:)
      ENDDO
      WRITE(NFIL,FMT='(A)')'RADIAL REPORT'
      CALL RADIAL$REPORT(NFIL)
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE XSETUP$REPORT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XSETUP$SELECT(ID)  ! MARK: XSETUP$SELECT
!     **************************************************************************
!     ** SELECT XSETUP ARRAY                                                  **
!     **************************************************************************
      USE XSETUP_MODULE, ONLY: GROUND,EXCITE,SELECTED,THIS, &
     &                         NSPGROUND,NSPEXCITE,THISNSP
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      LOGICAL(4) :: TOVERLAP
      CALL XCNTL$GETL4('TOVERLAP',TOVERLAP)
      IF(TOVERLAP) RETURN
      IF(SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('CANNOT SELECT SETUP WHEN ALREADY SELECTED')
        CALL ERROR$STOP('XSETUP$SELECT')
      END IF
      IF(ID.EQ.'GROUND') THEN
        IF(.NOT.ASSOCIATED(GROUND)) THEN
          CALL ERROR$MSG('GROUND SETUP ARRAY NOT ALLOCATED')
          CALL ERROR$STOP('XSETUP$SELECT')
        END IF
        THIS=>GROUND
        THISNSP=NSPGROUND
      ELSE IF(ID.EQ.'EXCITE') THEN
        IF(.NOT.ASSOCIATED(EXCITE)) THEN
          CALL ERROR$MSG('EXCITE SETUP ARRAY NOT ALLOCATED')
          CALL ERROR$STOP('XSETUP$SELECT')
        END IF
        THIS=>EXCITE
        THISNSP=NSPEXCITE
      ELSE
        CALL ERROR$MSG('XSETUP SELECT ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('XSETUP$SELECT')
      END IF
      SELECTED=.TRUE.
      RETURN
      END SUBROUTINE XSETUP$SELECT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XSETUP$UNSELECT()  ! MARK: XSETUP$UNSELECT
!     **************************************************************************
!     ** UNSELECT XSETUP ARRAY                                                **
!     **************************************************************************
      USE XSETUP_MODULE, ONLY: SELECTED,THIS,THISNSP
      IMPLICIT NONE
      LOGICAL(4) :: TOVERLAP
      CALL XCNTL$GETL4('TOVERLAP',TOVERLAP)
      IF(TOVERLAP) RETURN
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('CANNOT UNSELECT SETUP ARRAY WHEN NOT SELECTED')
        CALL ERROR$STOP('XSETUP$UNSELECT')
      END IF
      SELECTED=.FALSE.
      NULLIFY(THIS)
      THISNSP=0
      RETURN
      END SUBROUTINE XSETUP$UNSELECT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XSETUP$ISELECT(I)  ! MARK: XSETUP$ISELECT
!     **************************************************************************
!     ** SELECT XSETUP ARRAY BY INTEGER INDEX                                 **
!     **************************************************************************
      USE XSETUP_MODULE, ONLY: SELECTED,GROUND,EXCITE,THIS, &
     &                         NSPGROUND,NSPEXCITE,THISNSP
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: I
      LOGICAL(4) :: TOVERLAP
      CALL XCNTL$GETL4('TOVERLAP',TOVERLAP)
      IF(TOVERLAP) RETURN
      IF(SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('CANNOT SELECT SETUP WHEN ALREADY SELECTED')
        CALL ERROR$STOP('XSETUP$ISELECT')
      END IF
      IF(I.EQ.1) THEN
        IF(.NOT.ASSOCIATED(GROUND)) THEN
          CALL ERROR$MSG('GROUND SETUP ARRAY NOT ALLOCATED')
          CALL ERROR$STOP('XSETUP$ISELECT')
        END IF
        THIS=>GROUND
        THISNSP=NSPGROUND
      ELSE IF(I.EQ.2) THEN
        IF(.NOT.ASSOCIATED(EXCITE)) THEN
          CALL ERROR$MSG('EXCITE SETUP ARRAY NOT ALLOCATED')
          CALL ERROR$STOP('XSETUP$ISELECT')
        END IF
        THIS=>EXCITE
        THISNSP=NSPEXCITE
      ELSE
        CALL ERROR$MSG('XSETUP ISELECT INDEX NOT RECOGNIZED')
        CALL ERROR$I4VAL('INDEX: ',I)
        CALL ERROR$STOP('XSETUP$ISELECT')
      END IF
      SELECTED=.TRUE.
      RETURN
      END SUBROUTINE XSETUP$ISELECT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XSETUP$INIT(I,NSP)  ! MARK: XSETUP$INIT
!     **************************************************************************
!     ** INITIALIZE XSETUP ARRAY                                              **  
!     ** REQUIRES SELECTED SETUP ARRAY                                        **
!     **************************************************************************
      USE XSETUP_MODULE, ONLY: GROUND,EXCITE,NSPGROUND,NSPEXCITE
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: I
      INTEGER(4), INTENT(IN) :: NSP
      LOGICAL(4) :: TOVERLAP
      CALL XCNTL$GETL4('TOVERLAP',TOVERLAP)
      IF(TOVERLAP) RETURN
      IF(NSP.LE.0) THEN
        CALL ERROR$MSG('INVALID NUMBER OF SPECIES')
        CALL ERROR$I4VAL('NUMBER OF SPECIES: ',NSP)
        CALL ERROR$STOP('XSETUP$INIT')
      END IF
      IF(I.EQ.1) THEN
        IF(ASSOCIATED(GROUND)) THEN
          CALL ERROR$MSG('GROUND SETUP ARRAY ALREADY ALLOCATED')
          CALL ERROR$STOP('XSETUP$INIT')
        END IF
        ALLOCATE(GROUND(NSP))
        NSPGROUND=NSP
      ELSE IF(I.EQ.2) THEN
        IF(ASSOCIATED(EXCITE)) THEN
          CALL ERROR$MSG('EXCITE SETUP ARRAY ALREADY ALLOCATED')
          CALL ERROR$STOP('XSETUP$INIT')
        END IF
        ALLOCATE(EXCITE(NSP))
        NSPEXCITE=NSP
      ELSE
        CALL ERROR$MSG('XSETUP INIT INDEX NOT RECOGNIZED')
        CALL ERROR$I4VAL('INDEX: ',I)
        CALL ERROR$STOP('XSETUP$INIT')
      END IF
      RETURN
      END SUBROUTINE XSETUP$INIT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XSETUP$NEW(ISP,GID,ECORE,LNXX,LNX,L,NBATOM)  ! MARK: XSETUP$NEW
!     **************************************************************************
!     ** ADD NEW SETUP TO SETUP ARRAY                                         **
!     ** REQUIRES SELECTED SETUP ARRAY                                        **
!     **************************************************************************
      USE XSETUP_MODULE, ONLY: SELECTED,THIS
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: ISP
      INTEGER(4), INTENT(IN) :: GID
      REAL(8), INTENT(IN) :: ECORE
      INTEGER(4), INTENT(IN) :: LNXX
      INTEGER(4), INTENT(IN) :: LNX
      INTEGER(4), INTENT(IN) :: L(LNXX)
      INTEGER(4), INTENT(IN) :: NBATOM
      INTEGER(4) :: NR
      LOGICAL(4) :: TOVERLAP
      CALL XCNTL$GETL4('TOVERLAP',TOVERLAP)
      IF(TOVERLAP) RETURN
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SETUP SELECTED')
        CALL ERROR$STOP('XSETUP$INIT')
      END IF
      IF(ISP.LE.0.OR.ISP.GT.SIZE(THIS)) THEN
        CALL ERROR$MSG('INVALID SPECIES INDEX')
        CALL ERROR$I4VAL('SPECIES INDEX: ',ISP)
        CALL ERROR$STOP('XSETUP$NEW')
      END IF
      CALL RADIAL$GETI4(GID,'NR',NR)
      THIS(ISP)%GID=GID
      THIS(ISP)%ECORE=ECORE
      THIS(ISP)%LNXX=LNXX
      THIS(ISP)%LNX=LNX
      ALLOCATE(THIS(ISP)%L(LNXX))
      THIS(ISP)%L(:)=L(:)
      ALLOCATE(THIS(ISP)%PSPHI(NR,LNX))
      ALLOCATE(THIS(ISP)%AEPHI(NR,LNX))
      THIS(ISP)%NBATOM=NBATOM
      ALLOCATE(THIS(ISP)%LATOM(NBATOM))
      ALLOCATE(THIS(ISP)%AEPSI(NR,NBATOM))
      RETURN
      END SUBROUTINE XSETUP$NEW
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XSETUP$GETI4A(ID,ISP,LEN,VAL)  ! MARK: XSETUP$GETI4A
!     **************************************************************************
!     ** GET INTEGER VALUE ARRAY FROM SELECTED SETUP                          **
!     ** REQUIRES SELECTED SETUP ARRAY                                        **
!     **************************************************************************
      USE XSETUP_MODULE, ONLY: SELECTED,THIS
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: ISP
      INTEGER(4), INTENT(IN) :: LEN
      INTEGER(4), INTENT(OUT) :: VAL(LEN)
      LOGICAL(4) :: TOVERLAP
      CALL XCNTL$GETL4('TOVERLAP',TOVERLAP)
      IF(TOVERLAP) THEN
        CALL ERROR$MSG('XSETUP GETI4A NOT ALLOWED IN OVERLAP MODE')
        CALL ERROR$STOP('XSETUP$GETI4A')
      END IF
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SETUP SELECTED')
        CALL ERROR$STOP('XSETUP$GETI4A')
      END IF
      IF(ISP.LE.0.OR.ISP.GT.SIZE(THIS)) THEN
        CALL ERROR$MSG('INVALID SPECIES INDEX')
        CALL ERROR$I4VAL('SPECIES INDEX: ',ISP)
        CALL ERROR$STOP('XSETUP$GETI4A')
      END IF
      IF(ID.EQ.'LATOM') THEN
        IF(LEN.NE.THIS(ISP)%NBATOM) THEN
          CALL ERROR$MSG('LENGTH OF LATOM ARRAY MUST BE EQUAL TO NBATOM')
          CALL ERROR$I4VAL('LENGTH OF LATOM: ',LEN)
          CALL ERROR$I4VAL('NBATOM: ',THIS(ISP)%NBATOM)
          CALL ERROR$STOP('XSETUP$GETI4A')
        END IF
        VAL(:)=THIS(ISP)%LATOM(:)
      ELSE
        CALL ERROR$MSG('XSETUP GETI4A ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('XSETUP$GETI4A')
      END IF
      RETURN
      END SUBROUTINE XSETUP$GETI4A
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XSETUP$SETI4A(ID,ISP,LEN,VAL)  ! MARK: XSETUP$SETI4A
!     **************************************************************************
!     ** SET INTEGER VALUE ARRAY IN SELECTED SETUP                            **
!     ** REQUIRES SELECTED SETUP ARRAY                                        **
!     **************************************************************************
      USE XSETUP_MODULE, ONLY: SELECTED,THIS
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: ISP
      INTEGER(4), INTENT(IN) :: LEN
      INTEGER(4), INTENT(IN) :: VAL(LEN)
      LOGICAL(4) :: TOVERLAP
      CALL XCNTL$GETL4('TOVERLAP',TOVERLAP)
      IF(TOVERLAP) THEN
        CALL ERROR$MSG('XSETUP SETI4A NOT ALLOWED IN OVERLAP MODE')
        CALL ERROR$STOP('XSETUP$SETI4A')
      END IF
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SETUP SELECTED')
        CALL ERROR$STOP('XSETUP$SETI4A')
      END IF
      IF(ISP.LE.0.OR.ISP.GT.SIZE(THIS)) THEN
        CALL ERROR$MSG('INVALID SPECIES INDEX')
        CALL ERROR$I4VAL('SPECIES INDEX: ',ISP)
        CALL ERROR$STOP('XSETUP$SETI4A')
      END IF
      IF(ID.EQ.'LATOM') THEN
        IF(LEN.NE.THIS(ISP)%NBATOM) THEN
          CALL ERROR$MSG('LENGTH OF LATOM ARRAY MUST BE EQUAL TO NBATOM')
          CALL ERROR$I4VAL('LENGTH OF LATOM: ',LEN)
          CALL ERROR$I4VAL('NBATOM: ',THIS(ISP)%NBATOM)
          CALL ERROR$STOP('XSETUP$SETI4A')
        END IF
        THIS(ISP)%LATOM(:)=VAL(:)
      ELSE
        CALL ERROR$MSG('XSETUP SETI4A ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('XSETUP$SETI4A')
      END IF
      RETURN
      END SUBROUTINE XSETUP$SETI4A
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XSETUP$GETI4(ID,ISP,VAL)  ! MARK: XSETUP$GETI4
!     **************************************************************************
!     ** GET INTEGER VALUE FROM SELECTED SETUP                                **
!     ** REQUIRES SELECTED SETUP ARRAY                                        **
!     **************************************************************************
      USE XSETUP_MODULE, ONLY: SELECTED,THIS
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: ISP
      INTEGER(4), INTENT(OUT) :: VAL
      LOGICAL(4) :: TOVERLAP
      CALL XCNTL$GETL4('TOVERLAP',TOVERLAP)
      IF(TOVERLAP) THEN
        CALL ERROR$MSG('XSETUP GETI4 NOT ALLOWED IN OVERLAP MODE')
        CALL ERROR$STOP('XSETUP$GETI4')
      END IF
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SETUP SELECTED')
        CALL ERROR$STOP('XSETUP$GETI4')
      END IF
      IF(ISP.LE.0.OR.ISP.GT.SIZE(THIS)) THEN
        CALL ERROR$MSG('INVALID SPECIES INDEX')
        CALL ERROR$I4VAL('SPECIES INDEX: ',ISP)
        CALL ERROR$STOP('XSETUP$GETI4')
      END IF
      IF(ID.EQ.'GID') THEN
        VAL=THIS(ISP)%GID
      ELSE IF(ID.EQ.'NBATOM') THEN
        VAL=THIS(ISP)%NBATOM
      ELSE
        CALL ERROR$MSG('XSETUP GETI4 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('XSETUP$GETI4')
      END IF
      RETURN
      END SUBROUTINE XSETUP$GETI4
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XSETUP$GETR8A(ID,ISP,LEN,VAL)  ! MARK: XSETUP$GETR8A
!     **************************************************************************
!     ** GET REAL VALUE ARRAY FROM SELECTED SETUP                             **
!     ** REQUIRES SELECTED SETUP ARRAY                                        **
!     **************************************************************************
      USE XSETUP_MODULE, ONLY: SELECTED,THIS
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: ISP
      INTEGER(4), INTENT(IN) :: LEN
      REAL(8), INTENT(OUT) :: VAL(LEN)
      INTEGER(4) :: NR
      LOGICAL(4) :: TOVERLAP
      CALL XCNTL$GETL4('TOVERLAP',TOVERLAP)
      IF(TOVERLAP) THEN
        CALL ERROR$MSG('XSETUP GETR8A NOT ALLOWED IN OVERLAP MODE')
        CALL ERROR$STOP('XSETUP$GETR8A')
      END IF
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SETUP SELECTED')
        CALL ERROR$STOP('XSETUP$GETR8A')
      END IF
      IF(ISP.LE.0.OR.ISP.GT.SIZE(THIS)) THEN
        CALL ERROR$MSG('INVALID SPECIES INDEX')
        CALL ERROR$I4VAL('SPECIES INDEX: ',ISP)
        CALL ERROR$STOP('XSETUP$GETR8A')
      END IF
      CALL RADIAL$GETI4(THIS(ISP)%GID,'NR',NR)
      IF(ID.EQ.'PSPHI') THEN
        IF(LEN.NE.NR*THIS(ISP)%LNX) THEN
          CALL ERROR$MSG('LENGTH MUST BE EQUAL TO NR*LNX')
          CALL ERROR$I4VAL('LENGTH: ',LEN)
          CALL ERROR$I4VAL('NR*LNX: ',NR*THIS(ISP)%LNX)
          CALL ERROR$STOP('XSETUP$GETR8A')
        END IF
        VAL(:)=RESHAPE(THIS(ISP)%PSPHI,(/LEN/))
      ELSE IF(ID.EQ.'AEPHI') THEN
        IF(LEN.NE.NR*THIS(ISP)%LNX) THEN
          CALL ERROR$MSG('LENGTH MUST BE EQUAL TO NR*LNX')
          CALL ERROR$I4VAL('LENGTH: ',LEN)
          CALL ERROR$I4VAL('NR*LNX: ',NR*THIS(ISP)%LNX)
          CALL ERROR$STOP('XSETUP$GETR8A')
        END IF
        VAL(:)=RESHAPE(THIS(ISP)%AEPHI,(/LEN/))
      ELSE IF(ID.EQ.'AEPSI') THEN
        IF(LEN.NE.NR*THIS(ISP)%NBATOM) THEN
          CALL ERROR$MSG('LENGTH MUST BE EQUAL TO NR*NBATOM')
          CALL ERROR$I4VAL('LENGTH: ',LEN)
          CALL ERROR$I4VAL('NR*NBATOM: ',NR*THIS(ISP)%NBATOM)
          CALL ERROR$STOP('XSETUP$GETR8A')
        END IF
        VAL(:)=RESHAPE(THIS(ISP)%AEPSI,(/LEN/))
      ELSE
        CALL ERROR$MSG('XSETUP GETR8A ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('XSETUP$GETR8A')
      END IF
      RETURN
      END SUBROUTINE XSETUP$GETR8A
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XSETUP$SETR8A(ID,ISP,LEN,VAL)  ! MARK: XSETUP$SETR8A
!     **************************************************************************
!     ** SET REAL VALUE ARRAY IN SELECTED SETUP                               **
!     ** REQUIRES SELECTED SETUP ARRAY                                        **
!     **************************************************************************
      USE XSETUP_MODULE, ONLY: SELECTED,THIS
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: ISP
      INTEGER(4), INTENT(IN) :: LEN
      REAL(8), INTENT(IN) :: VAL(LEN)
      INTEGER(4) :: NR
      LOGICAL(4) :: TOVERLAP
      CALL XCNTL$GETL4('TOVERLAP',TOVERLAP)
      IF(TOVERLAP) THEN
        CALL ERROR$MSG('XSETUP SETR8A NOT ALLOWED IN OVERLAP MODE')
        CALL ERROR$STOP('XSETUP$SETR8A')
      END IF
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SETUP SELECTED')
        CALL ERROR$STOP('XSETUP$SETR8A')
      END IF
      IF(ISP.LE.0.OR.ISP.GT.SIZE(THIS)) THEN
        CALL ERROR$MSG('INVALID SPECIES INDEX')
        CALL ERROR$I4VAL('SPECIES INDEX: ',ISP)
        CALL ERROR$STOP('XSETUP$SETR8A')
      END IF
      CALL RADIAL$GETI4(THIS(ISP)%GID,'NR',NR)
      IF(ID.EQ.'PSPHI') THEN
        IF(LEN.NE.NR*THIS(ISP)%LNX) THEN
          CALL ERROR$MSG('LENGTH MUST BE EQUAL TO NR*LNX')
          CALL ERROR$I4VAL('LENGTH: ',LEN)
          CALL ERROR$I4VAL('NR*LNX: ',NR*THIS(ISP)%LNX)
          CALL ERROR$STOP('XSETUP$SETR8A')
        END IF
        THIS(ISP)%PSPHI(:,:)=RESHAPE(VAL,(/NR,THIS(ISP)%LNX/))
      ELSE IF(ID.EQ.'AEPHI') THEN
        IF(LEN.NE.NR*THIS(ISP)%LNX) THEN
          CALL ERROR$MSG('LENGTH MUST BE EQUAL TO NR*LNX')
          CALL ERROR$I4VAL('LENGTH: ',LEN)
          CALL ERROR$I4VAL('NR*LNX: ',NR*THIS(ISP)%LNX)
          CALL ERROR$STOP('XSETUP$SETR8A')
        END IF
        THIS(ISP)%AEPHI(:,:)=RESHAPE(VAL,(/NR,THIS(ISP)%LNX/))
      ELSE IF(ID.EQ.'AEPSI') THEN
        IF(LEN.NE.NR*THIS(ISP)%NBATOM) THEN
          CALL ERROR$MSG('LENGTH MUST BE EQUAL TO NR*NBATOM')
          CALL ERROR$I4VAL('LENGTH: ',LEN)
          CALL ERROR$I4VAL('NR*NBATOM: ',NR*THIS(ISP)%NBATOM)
          CALL ERROR$STOP('XSETUP$SETR8A')
        END IF
        THIS(ISP)%AEPSI(:,:)=RESHAPE(VAL,(/NR,THIS(ISP)%NBATOM/))
      ELSE
        CALL ERROR$MSG('XSETUP SETR8A ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('XSETUP$SETR8A')
      END IF
      RETURN
      END SUBROUTINE XSETUP$SETR8A
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XSETUP$GETR8(ID,ISP,VAL)  ! MARK: XSETUP$GETR8
!     **************************************************************************
!     ** GET REAL VALUE FROM SELECTED SETUP                                   **
!     ** REQUIRES SELECTED SETUP ARRAY                                        **
!     **************************************************************************
      USE XSETUP_MODULE, ONLY: SELECTED,THIS
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: ISP
      REAL(8), INTENT(OUT) :: VAL
      LOGICAL(4) :: TOVERLAP
      CALL XCNTL$GETL4('TOVERLAP',TOVERLAP)
      IF(TOVERLAP) THEN
        CALL ERROR$MSG('XSETUP GETR8 NOT ALLOWED IN OVERLAP MODE')
        CALL ERROR$STOP('XSETUP$GETR8')
      END IF
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SETUP SELECTED')
        CALL ERROR$STOP('XSETUP$GETR8')
      END IF
      IF(ISP.LE.0.OR.ISP.GT.SIZE(THIS)) THEN
        CALL ERROR$MSG('INVALID SPECIES INDEX')
        CALL ERROR$I4VAL('SPECIES INDEX: ',ISP)
        CALL ERROR$STOP('XSETUP$GETR8')
      END IF
      IF(ID.EQ.'ECORE') THEN
        VAL=THIS(ISP)%ECORE
      ELSE
        CALL ERROR$MSG('XSETUP GETR8 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('XSETUP$GETR8')
      END IF
      RETURN
      END SUBROUTINE XSETUP$GETR8
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XSETUP$SETR8(ID,ISP,VAL)  ! MARK: XSETUP$SETR8
!     **************************************************************************
!     ** SET REAL VALUE IN SELECTED SETUP                                     **
!     ** REQUIRES SELECTED SETUP ARRAY                                        **
!     **************************************************************************
      USE XSETUP_MODULE, ONLY: SELECTED,THIS
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: ISP
      REAL(8), INTENT(IN) :: VAL
      LOGICAL(4) :: TOVERLAP
      CALL XCNTL$GETL4('TOVERLAP',TOVERLAP)
      IF(TOVERLAP) THEN
        CALL ERROR$MSG('XSETUP SETR8 NOT ALLOWED IN OVERLAP MODE')
        CALL ERROR$STOP('XSETUP$SETR8')
      END IF
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SETUP SELECTED')
        CALL ERROR$STOP('XSETUP$SETR8')
      END IF
      IF(ISP.LE.0.OR.ISP.GT.SIZE(THIS)) THEN
        CALL ERROR$MSG('INVALID SPECIES INDEX')
        CALL ERROR$I4VAL('SPECIES INDEX: ',ISP)
        CALL ERROR$STOP('XSETUP$SETR8')
      END IF
      IF(ID.EQ.'ECORE') THEN
        THIS(ISP)%ECORE=VAL
      ELSE
        CALL ERROR$MSG('XSETUP SETR8 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('XSETUP$SETR8')
      END IF
      RETURN
      END SUBROUTINE XSETUP$SETR8
!
!     ==========================================================================
!     ==========================================================================
!     ==                    KSMAP MODULE FUNCTIONS                            ==
!     ==========================================================================
!     ==========================================================================
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE KSMAP$INIT(NKPTG_,NSPING_)
!     **************************************************************************
!     ** INITIALIZE KSMAP FOR TASKS                                           **
!     ** KSMAP(NKPTG,NSPING) IS THE MAP OF KPOINTS AND SPINS TO TASKS         **
!     ** RTASK IS THE TASK RESPONSIBLE FOR READING AND WRITING                **
!     **************************************************************************
      USE KSMAP_MODULE, ONLY: NKPTG,NSPING,RTASK,KSMAP,INITIALIZED
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: NKPTG_
      INTEGER(4), INTENT(IN) :: NSPING_
      INTEGER(4) :: NTASKS,THISTASK
      INTEGER(4) :: IKPT,ISPIN,IND
      IF(INITIALIZED) THEN
        ! IF ALREADY INITIALIZED, CHECK IF SAME VALUES
        IF(NKPTG_.NE.NKPTG.OR.NSPING_.NE.NSPING) THEN
          CALL ERROR$MSG('KSMAP ALREADY INITIALIZED WITH DIFFERENT VALUES')
          CALL ERROR$I4VAL('OLD NKPTG: ',NKPTG)
          CALL ERROR$I4VAL('OLD NSPING: ',NSPING)
          CALL ERROR$I4VAL('NEW NKPTG: ',NKPTG_)
          CALL ERROR$I4VAL('NEW NSPING: ',NSPING)
          CALL ERROR$STOP('KSMAP$INIT')
        END IF
        RETURN
      END IF
                          CALL TRACE$PUSH('KSMAP$INIT')
      NSPING=NSPING_
      NKPTG=NKPTG_
      ALLOCATE(KSMAP(NKPTG,NSPING))
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      ! ONLY ONE TASK: 
      !   BOTH READ TASK AND RESPONSIBLE FOR EVERY KPOINT
      IF(NTASKS.EQ.1) THEN
        RTASK=1
        KSMAP=1
      ! MORE THAN ONE TASK:
      !   FIRST IS READ TASK, OTHERS ARE RESPONSIBLE FOR DIFFERENT KPOINTS
      ELSE
        RTASK=1
        DO IKPT=1,NKPTG
          DO ISPIN=1,NSPING
            IND=NSPING*(IKPT-1)+ISPIN
            IND=MOD(IND-1,NTASKS-1)+2
            KSMAP(IKPT,ISPIN)=IND
          ENDDO
        ENDDO
      END IF
      INITIALIZED=.TRUE.
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE KSMAP$INIT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE KSMAP$REPORT(NFIL)
!     **************************************************************************
!     ** REPORT KSMAP TO FILE                                                 **
!     **************************************************************************
      USE KSMAP_MODULE, ONLY: NKPTG,NSPING,RTASK,KSMAP,INITIALIZED
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: NFIL
      INTEGER(4), PARAMETER :: PERLINE=14
      INTEGER(4) :: IKPT
      INTEGER(4) :: BEGINKPT,ENDKPT
      INTEGER(4) :: NTASKS,THISTASK
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      IF(THISTASK.NE.RTASK) RETURN
                          CALL TRACE$PUSH('KSMAP$REPORT')
      IF(.NOT.INITIALIZED) THEN
        CALL ERROR$MSG('KSMAP NOT INITIALIZED')
        CALL ERROR$STOP('KSMAP$REPORT')
      END IF    
      WRITE(NFIL,FMT='(A)')''
      WRITE(NFIL,'(80("#"))')
      WRITE(NFIL,FMT='(A)')'KSMAP REPORT'
      WRITE(NFIL,'(80("#"))')
      WRITE(NFIL,FMT='(A8,I5)')'NTASKS:',NTASKS    
      WRITE(NFIL,FMT='(A8,I5)')'RW TASK:',RTASK
      BEGINKPT=1
      DO WHILE(.TRUE.)
        ! KPT IN THIS LINE (HALF FOR NSPIN=2)
        ENDKPT=MIN(BEGINKPT+PERLINE/NSPING-1,NKPTG)
        WRITE(NFIL,FMT='(80("-"))')
        IF(NSPING.EQ.1) THEN
          WRITE(NFIL,FMT='(A8,*(I4,"|"))')'KPOINT:',(IKPT, IKPT=BEGINKPT,ENDKPT)
          WRITE(NFIL,FMT='(A8,*(I4,"|"))')'SPIN:',(1, IKPT=BEGINKPT,ENDKPT)
        ELSE
          WRITE(NFIL,FMT='(A8,*(I9,"|"))')'KPOINT:',(IKPT, IKPT=BEGINKPT,ENDKPT)
           WRITE(NFIL,FMT='(A8,*(I4,"|"))')'SPIN:',(MOD(IKPT-1,NSPING)+1, IKPT=NSPING*BEGINKPT-1,NSPING*ENDKPT)
        END IF
        ! WRITE(NFIL,FMT='(A8,*(I4,"|"))')'SPIN:',(MOD(IND-1,NSPING)+1, IND=BEGINKPT*NSPING-1,ENDKPT*NSPING)
        WRITE(NFIL,FMT='(A8,*(I4,"|"))')'KSMAP:',(KSMAP(IKPT,:), IKPT=BEGINKPT,ENDKPT)
        IF(ENDKPT.NE.NKPTG) THEN
          BEGINKPT=ENDKPT+1
        ELSE
          EXIT
        END IF
      ENDDO
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE KSMAP$REPORT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE KSMAP$READTASK(RTASK_)  ! MARK: KSMAP$READTASK
!     **************************************************************************
!     ** GET READ TASK                                                        **
!     ** REQUIRES KSMAP INITIALIZED                                           **
!     **************************************************************************
      USE KSMAP_MODULE, ONLY: RTASK,INITIALIZED
      IMPLICIT NONE
      INTEGER(4), INTENT(OUT) :: RTASK_
      IF(.NOT.INITIALIZED) THEN
        CALL ERROR$MSG('KSMAP NOT INITIALIZED')
        CALL ERROR$STOP('KSMAP$READTASK')
      END IF
      RTASK_=RTASK
      RETURN
      END SUBROUTINE KSMAP$READTASK
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE KSMAP$WORKTASK(IKPT,ISPIN,TASK_)  ! MARK: KSMAP$WORKTASK
!     **************************************************************************  
!     ** GET WORK TASK FOR KPOINT AND SPIN                                    **
!     ** REQUIRES KSMAP INITIALIZED                                           **
!     **************************************************************************
      USE KSMAP_MODULE, ONLY: KSMAP,INITIALIZED,NKPTG,NSPING
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: IKPT
      INTEGER(4), INTENT(IN) :: ISPIN
      INTEGER(4), INTENT(OUT) :: TASK_
      IF(.NOT.INITIALIZED) THEN
        CALL ERROR$MSG('KSMAP NOT INITIALIZED')
        CALL ERROR$STOP('KSMAP$WORKTASK')
      END IF
      IF(IKPT.LE.0.OR.IKPT.GT.NKPTG) THEN
        CALL ERROR$MSG('INVALID KPOINT INDEX')
        CALL ERROR$I4VAL('KPOINT INDEX: ',IKPT)
        CALL ERROR$STOP('KSMAP$WORKTASK')
      END IF
      IF(ISPIN.LE.0.OR.ISPIN.GT.NSPING) THEN
        CALL ERROR$MSG('INVALID SPIN INDEX')
        CALL ERROR$I4VAL('SPIN INDEX: ',ISPIN)
        CALL ERROR$STOP('KSMAP$WORKTASK')
      END IF
      TASK_=KSMAP(IKPT,ISPIN)
      RETURN
      END SUBROUTINE KSMAP$WORKTASK
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE KSMAP$WORKTASKSKPT(IKPT,TASKS_)  ! MARK: KSMAP$WORKTASKSKPT
!     **************************************************************************  
!     ** GET WORK TASKS FOR KPOINT                                            **
!     ** REQUIRES KSMAP INITIALIZED                                           **
!     **************************************************************************
      USE KSMAP_MODULE, ONLY: KSMAP,INITIALIZED,NKPTG,NSPING
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: IKPT
      INTEGER(4), INTENT(OUT) :: TASKS_(NSPING)
      IF(.NOT.INITIALIZED) THEN
        CALL ERROR$MSG('KSMAP NOT INITIALIZED')
        CALL ERROR$STOP('KSMAP$WORKTASK')
      END IF
      IF(IKPT.LE.0.OR.IKPT.GT.NKPTG) THEN
        CALL ERROR$MSG('INVALID KPOINT INDEX')
        CALL ERROR$I4VAL('KPOINT INDEX: ',IKPT)
        CALL ERROR$STOP('KSMAP$WORKTASK')
      END IF
      TASKS_(:)=KSMAP(IKPT,:)
      RETURN
      END SUBROUTINE KSMAP$WORKTASKSKPT
!
!     ==========================================================================
!     ==========================================================================
!     ==                  SETTINGS MODULE FUNCTIONS                           ==
!     ==========================================================================
!     ==========================================================================
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SETTINGS$REPORT(NFIL)  ! MARK: SETTINGS$REPORT
!     **************************************************************************
!     ** REPORT SETTINGS MODULE TO FILE                                       **
!     ** REQUIRES SETTINGS MODULE INITIALIZED                                 **
!     **************************************************************************
      USE SETTINGS_MODULE, ONLY: NCORE,LCORE,IATOM,COREHOLE
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: NFIL
      INTEGER(4) :: NTASKS,THISTASK,RTASK
      LOGICAL(4) :: TOVERLAP
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      CALL KSMAP$READTASK(RTASK)
      IF(THISTASK.NE.RTASK) RETURN
      CALL XCNTL$GETL4('TOVERLAP',TOVERLAP)
                          CALL TRACE$PUSH('SETTINGS$REPORT')
      WRITE(NFIL,'(80("#"))')
      WRITE(NFIL,FMT='(A19)')'SETTINGS'
      WRITE(NFIL,'(80("#"))')
      IF(TOVERLAP) WRITE(NFIL,FMT='(A)')'SETTINGS TAKEN FROM OVERLAP FILE'
      WRITE(NFIL,FMT='(A10,X,A)')'HOLE ATOM:',TRIM(COREHOLE)
      IF(IATOM.EQ.-HUGE(1)) THEN
        CALL ERROR$MSG('SAFEGUARD: IATOM NOT SET')
        CALL ERROR$STOP('SETTINGS$REPORT')
      END IF
      WRITE(NFIL,FMT='(A10,I10)')'IND1 ATOM:',IATOM
      WRITE(NFIL,FMT='(A10,I10)')'NCORE:',NCORE
      WRITE(NFIL,FMT='(A10,I10)')'LCORE:',LCORE
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE SETTINGS$REPORT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SETTINGS_IATOM  ! MARK: SETTINGS_IATOM
!     **************************************************************************
!     ** FIND COREHOLE ATOM IN SIMULATION GROUND                              **
!     **************************************************************************
      USE SETTINGS_MODULE, ONLY: IATOM,COREHOLE
      IMPLICIT NONE
      CHARACTER(16), ALLOCATABLE :: ATOMID(:)
      INTEGER(4) :: NAT
      INTEGER(4) :: IAT
      LOGICAL(4) :: FOUND
                          CALL TRACE$PUSH('SETTINGS_IATOM')
      IF(IATOM.NE.-HUGE(1)) THEN
        CALL ERROR$MSG('SAFEGUARD: IATOM ALREADY SET')
        CALL ERROR$STOP('SETTINGS_IATOM')
      END IF
      CALL SIMULATION$SELECT('GROUND')
      CALL SIMULATION$GETI4('NAT',NAT)
      ALLOCATE(ATOMID(NAT))
      CALL SIMULATION$GETCHA('ATOMID',NAT,ATOMID)
      DO IAT=1,NAT
        IF(TRIM(COREHOLE).EQ.TRIM(ATOMID(IAT))) THEN
          FOUND=.TRUE.
          EXIT
        END IF
      ENDDO
      IF(FOUND) THEN
        IATOM=IAT
      ELSE
        CALL ERROR$MSG('COREHOLE ATOM NOT FOUND IN SIMULATION GROUND')
        CALL ERROR$CHVAL('COREHOLE: ',COREHOLE)
        CALL ERROR$STOP('SETTINGS_IATOM')
      END IF
      CALL SIMULATION$UNSELECT
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE SETTINGS_IATOM
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SETTINGS$GETI4(ID,VAL)  ! MARK: SETTINGS$GETI4
!     **************************************************************************
!     ** GET INTEGER FROM SETTINGS MODULE                                     **
!     **************************************************************************
      USE SETTINGS_MODULE, ONLY: NCORE,LCORE,IATOM
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(OUT) :: VAL
      IF(ID.EQ.'NCORE') THEN
        VAL=NCORE
      ELSE IF(ID.EQ.'LCORE') THEN
        VAL=LCORE
      ELSE IF(ID.EQ.'IATOM') THEN
        ! CALL SHOULD BE UNNECESSARY, BUT IS A SAFEGUARD
        IF(IATOM.EQ.-HUGE(1)) CALL SETTINGS_IATOM
        VAL=IATOM
      ELSE
        CALL ERROR$MSG('SETTINGS GETI4 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('SETTINGS$GETI4')
      END IF
      RETURN
      END SUBROUTINE SETTINGS$GETI4
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SETTINGS$SETI4(ID,VAL)  ! MARK: SETTINGS$SETI4
!     **************************************************************************
!     ** SET INTEGER IN SETTINGS MODULE                                       **
!     **************************************************************************
      USE SETTINGS_MODULE, ONLY: NCORE,LCORE,IATOM
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: VAL
      IF(ID.EQ.'NCORE') THEN
        NCORE=VAL
      ELSE IF(ID.EQ.'LCORE') THEN
        LCORE=VAL
      ELSE IF(ID.EQ.'IATOM') THEN
        IATOM=VAL
      ELSE
        CALL ERROR$MSG('SETTINGS SETI4 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('SETTINGS$SETI4')
      END IF
      RETURN
      END SUBROUTINE SETTINGS$SETI4
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SETTINGS$GETCH(ID,VAL)  ! MARK: SETTINGS$GETCH
!     **************************************************************************
!     ** GET CHARACTER FROM SETTINGS MODULE                                   **
!     **************************************************************************
      USE SETTINGS_MODULE, ONLY: COREHOLE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      CHARACTER(*), INTENT(OUT) :: VAL
      IF(ID.EQ.'COREHOLE') THEN
        VAL=COREHOLE
      ELSE
        CALL ERROR$MSG('SETTINGS GETCH ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('SETTINGS$GETCH')
      END IF
      RETURN
      END SUBROUTINE SETTINGS$GETCH
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SETTINGS$SETCH(ID,VAL)  ! MARK: SETTINGS$SETCH
!     **************************************************************************
!     ** SET CHARACTER IN SETTINGS MODULE                                     **
!     **************************************************************************
      USE SETTINGS_MODULE, ONLY: COREHOLE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      CHARACTER(*), INTENT(IN) :: VAL
      IF(ID.EQ.'COREHOLE') THEN
        COREHOLE=VAL
      ELSE
        CALL ERROR$MSG('SETTINGS SETCH ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('SETTINGS$SETCH')
      END IF
      RETURN
      END SUBROUTINE
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SETTINGS_WRITEOVERLAP(NFIL)  ! MARK: SETTINGS_WRITEOVERLAP
!     **************************************************************************
!     ** WRITE SETTINGS MODULE TO OVERLAP FILE WHICH SERVES AS RESTART FILE   **
!     ** FOR THE SIMULATION                                                   **
!     **************************************************************************
      USE SETTINGS_MODULE, ONLY: NCORE,LCORE,IATOM,COREHOLE
      USE STRINGS_MODULE
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: NFIL
      INTEGER(4) :: NTASKS,THISTASK,RTASK
      CHARACTER(8) :: KEY
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      CALL KSMAP$READTASK(RTASK)
      IF(THISTASK.NE.RTASK) RETURN
                          CALL TRACE$PUSH('SETTINGS_WRITEOVERLAP')
      KEY=+'SETTINGS'
      WRITE(NFIL)KEY
      WRITE(NFIL)COREHOLE,IATOM,NCORE,LCORE
                           CALL TRACE$POP
      RETURN
      END SUBROUTINE SETTINGS_WRITEOVERLAP
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SETTINGS_READOVERLAP(NFIL)  ! MARK: SETTINGS_READOVERLAP
!     **************************************************************************
!     ** READ SETTINGS MODULE FROM OVERLAP FILE WHICH SERVES AS RESTART FILE  **
!     ** FOR THE SIMULATION                                                   **
!     **************************************************************************
      USE SETTINGS_MODULE, ONLY: NCORE,LCORE,IATOM,COREHOLE
      USE STRINGS_MODULE
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: NFIL
      INTEGER(4) :: NTASKS,THISTASK,RTASK
      CHARACTER(8) :: KEY
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      CALL KSMAP$READTASK(RTASK)
      IF(THISTASK.NE.RTASK) RETURN
                          CALL TRACE$PUSH('SETTINGS_READOVERLAP')
      READ(NFIL)KEY
      IF(KEY.NE.+'SETTINGS') THEN
        CALL ERROR$MSG('OVERLAP FILE CORRUPTED')
        CALL ERROR$CHVAL('KEY: ',KEY)
        CALL ERROR$STOP('SETTINGS_READOVERLAP')
      END IF
      READ(NFIL)COREHOLE,IATOM,NCORE,LCORE
                           CALL TRACE$POP
      RETURN
      END SUBROUTINE SETTINGS_READOVERLAP
!
!     ==========================================================================
!     ==========================================================================
!     ==                      XAS MODULE FUNCTIONS                            ==
!     ==========================================================================
!     ==========================================================================
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$CALCULATE  ! MARK: XAS$CALCULATE
!     **************************************************************************
!     ** CALCULATE XAS SPECTRA                                                **
!     ** REQUIRES XAS ACTIVE AND INITIALIZED                                  **
!     **************************************************************************
      USE XAS_MODULE, ONLY: TACTIVE,TINITIALIZE,NSPEC,THIS,DE,SINGLEPARTICLE
      USE SHARED_DATA_MODULE, ONLY: ABSORB,ADETPROD
      USE MPE_MODULE
      IMPLICIT NONE
      INTEGER(4) :: NTASKS,THISTASK,WTASK
      INTEGER(4) :: ISPEC
      INTEGER(4) :: NKPT
      INTEGER(4) :: IKPT
      INTEGER(4) :: NSPIN
      INTEGER(4) :: ISPIN
      REAL(8) :: EMIN
      REAL(8) :: EMAX
      INTEGER(4) :: NE
      INTEGER(4) :: I
      INTEGER(4) :: NB2
      INTEGER(4) :: NOCC
      REAL(8) :: EEXCITE
      REAL(8) :: EGROUND
      INTEGER(4) :: IEMP
      COMPLEX(8) :: AMPL(3)
      COMPLEX(8) :: POLXYZ(3)
      COMPLEX(8), ALLOCATABLE :: KMAT(:,:)
      COMPLEX(8), ALLOCATABLE :: DIPOLE(:,:)
      REAL(8), ALLOCATABLE :: EIG(:)
      REAL(8), ALLOCATABLE :: WKPT(:)
      REAL(8) :: EFINAL
      REAL(8) :: EDIFF ! EFINAL - EGROUND
      COMPLEX(8) :: CVAR
      REAL(8) :: SIGMA
      LOGICAL(4), ALLOCATABLE :: TINVARR(:)
      LOGICAL(4) :: TNEGATIVEKPT
      INTEGER(4) :: NKDIV(3)
      REAL(8) :: TOTALWKPT
      LOGICAL(4) :: TADET
      LOGICAL(4) :: TBASISWGHT
      LOGICAL(4) :: TNORMALIZE
      REAL(8) :: ADETSUM
      COMPLEX(8) :: ADET
      COMPLEX(8) :: ADETOP ! ADET FROM OPPOSITE SPIN DIRECTION
      INTEGER(4) :: ISPINOP ! SPIN OPPOSITE TO ISPIN
      IF(.NOT.TACTIVE) RETURN
                          CALL TRACE$PUSH('XAS$CALCULATE')
                          CALL TIMING$CLOCKON('XAS$CALCULATE')
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      IF(.NOT.TINITIALIZE) THEN
        CALL ERROR$MSG('XAS NOT INITIALIZED')
        CALL ERROR$STOP('XAS$CALCULATE')
      END IF

      CALL XCNTL$GETL4('ADET',TADET)
      CALL XCNTL$GETL4('BASISWGHT',TBASISWGHT)
      CALL XCNTL$GETL4('NORMALIZE',TNORMALIZE)
      CALL OVERLAP$GETR8('ADETSUM',ADETSUM)
      
      CALL SIMULATION$SELECT('GROUND')
      CALL SIMULATION$GETI4('NKPT',NKPT)
      CALL SIMULATION$GETI4A('NKDIV',3,NKDIV)
      ALLOCATE(WKPT(NKPT))
      CALL SIMULATION$GETR8A('WKPT',NKPT,WKPT)
      ALLOCATE(TINVARR(NKPT))
      CALL SIMULATION$GETL4A('TINVARR',NKPT,TINVARR)
      CALL SIMULATION$GETI4('NSPIN',NSPIN)
      CALL SIMULATION$GETR8('ETOT',EGROUND)
      CALL SIMULATION$UNSELECT
      TOTALWKPT=1.D0/REAL(PRODUCT(NKDIV),KIND=8)

      CALL SIMULATION$SELECT('EXCITE')
      CALL SIMULATION$GETR8('ETOT',EEXCITE)
      CALL SIMULATION$UNSELECT

      CALL XAS$GETR8('EMIN',EMIN)
      CALL XAS$GETR8('EMAX',EMAX)
      CALL XAS$GETI4('NE',NE)

      
      ! ALLOCATE STORAGE
      ALLOCATE(ABSORB(NKPT,NSPIN))
      DO ISPEC=1,NSPEC
        CALL XAS$ISELECT(ISPEC)
        ALLOCATE(THIS%E(NE))
        ALLOCATE(THIS%SPECTRUM(NKPT,NSPIN,NE))
        THIS%SPECTRUM(:,:,:)=0.D0
        ! TODO: ALLOCATE RAW SPECTRUM
        DO I=1,NE
          THIS%E(I)=EMIN+REAL(I-1,KIND=8)*DE
        ENDDO
        CALL XAS$UNSELECT
      ENDDO
      ALLOCATE(ADETPROD(NKPT,NSPIN))
      ADETPROD(:,:)=0.D0

      CALL STATE$SELECT('EXCITE')
      DO IKPT=1,NKPT
        ! CHECK IF NEGATIVE K-POINT NEEDS TO BE TREATED
        TNEGATIVEKPT=.NOT.TINVARR(IKPT)
        DO ISPIN=1,NSPIN
          CALL KSMAP$WORKTASK(IKPT,ISPIN,WTASK)
          IF(THISTASK.NE.WTASK) CYCLE

          ! NSPIN=1: OPPOSITE SPIN IS THE SAME
          ! NSPIN=2: OPPOSITE SPIN IS DIFFERENT 1->2, 2->1
          ISPINOP=MOD(ISPIN,NSPIN)+1 ! GET OPPOSITE SPIN
          CALL OVERLAP$SELECT(IKPT,ISPINOP)
          ! GET ADET FOR OPPOSITE SPIN
          CALL OVERLAP$GETC8('ADET',ADETOP)
          CALL OVERLAP$UNSELECT

          CALL OVERLAP$SELECT(IKPT,ISPIN)
          CALL OVERLAP$GETC8('ADET',ADET)
          CALL OVERLAP$GETI4('NB2',NB2)
          ALLOCATE(EIG(NB2))
          CALL STATE$GETR8A('EIG',IKPT,ISPIN,NB2,EIG)
          CALL OVERLAP$GETI4('NOCC',NOCC)
          ALLOCATE(DIPOLE(3,NB2))
          CALL OVERLAP$GETC8A('DIPOLE',3*NB2,DIPOLE)
          ALLOCATE(KMAT(NB2-NOCC,NOCC))
          CALL OVERLAP$K(NB2-NOCC,NOCC,KMAT)
          ALLOCATE(ABSORB(IKPT,ISPIN)%AMPL(3,NB2-NOCC))

          ! 0TH ORDER
          ADETPROD(IKPT,ISPIN)=ADETPROD(IKPT,ISPIN)+ABS(ADET)**2

          DO IEMP=1,NB2-NOCC
            ! 1ST ORDER
            DO I=1,NOCC
              ADETPROD(IKPT,ISPIN)=ADETPROD(IKPT,ISPIN)+ABS(KMAT(IEMP,I))**2*ABS(ADET)**2
            ENDDO

            CALL AMPLITUDE(NB2,NOCC,IEMP,KMAT,DIPOLE,AMPL,SINGLEPARTICLE)
            IF(TADET) AMPL=AMPL*CONJG(ADET)*CONJG(ADETOP)
            ! SAVE AMPLITUDES FOR POTENTIAL RIXS LATER ON
            ABSORB(IKPT,ISPIN)%AMPL(:,IEMP)=AMPL(:)

            EFINAL=EEXCITE+EIG(NOCC+IEMP)
            EDIFF=EFINAL-EGROUND
            DO ISPEC=1,NSPEC
              CALL XAS$ISELECT(ISPEC)
              CALL XAS$GETC8A('POLXYZ',3,POLXYZ)
              ! DOT_PRODUCT IS SUM_I CONJG(POLXYZ(I))*AMPL(I)
              ! THEREFORE, POLXYZ MUST BE CONJUGATED TO COMPENSATE
              CVAR=DOT_PRODUCT(CONJG(THIS%POLXYZ),AMPL)
              ! ABSOLUTE SQUARE AND WEIGHT OF K POINT
              ! ERROR: CHECK IMPLEMENTATION WEIGHT OF K POINT AND ROLE OF INVERSION SYMMETRY
              !        WKPT POSSIBLY NOT NECESSARY IF -K IS EXPLICITLY TREATED
              ! SIGMA=WKPT(IKPT)*REAL(CONJG(CVAR)*CVAR,KIND=8)
              SIGMA=TOTALWKPT*REAL(CONJG(CVAR)*CVAR,KIND=8)
              ! MAP TO SPECTRUM
              CALL MAPGRID(EDIFF,SIGMA,NE,THIS%SPECTRUM(IKPT,ISPIN,:),EMIN,DE)
              ! TODO: SAVE RAW SPECTRUM
              IF(TNEGATIVEKPT) THEN
                ! TREAT NEGATIVE K-POINT IF NEEDED
                CVAR=DOT_PRODUCT(CONJG(THIS%POLXYZ),CONJG(AMPL))
                SIGMA=TOTALWKPT*REAL(CONJG(CVAR)*CVAR,KIND=8)
                CALL MAPGRID(EDIFF,SIGMA,NE,THIS%SPECTRUM(IKPT,ISPIN,:),EMIN,DE)
              END IF
              CALL XAS$UNSELECT
            ENDDO ! END ISPEC
          ENDDO ! END IEMP
          DEALLOCATE(EIG)
          DEALLOCATE(KMAT)
          DEALLOCATE(DIPOLE)
          CALL OVERLAP$UNSELECT
        ENDDO ! END ISPIN
      ENDDO ! END IKPT
      CALL STATE$UNSELECT
      DEALLOCATE(WKPT)
      ! TODO: CHECK IF ADETPROD IS USED CORRECTLY FOR NPSIN=1
      CALL MPE$COMBINE('~','+',ADETPROD)
      IF(NSPIN.EQ.2) THEN
        ADETPROD(:,1)=ADETPROD(:,1)*ADETPROD(:,2)
      ELSE
        ! IF NSPIN=1, ASSUME ADETPROD IS THE SAME FOR BOTH SPINS
        ADETPROD(:,1)=ADETPROD(:,1)*ADETPROD(:,1)
      END IF

      ! COMBINE SPECTRA (MAKES IT AVAILABLE AND SAME ON EVERY TASK)
      DO ISPEC=1,NSPEC
        CALL XAS$ISELECT(ISPEC)
        CALL MPE$COMBINE('~','+',THIS%SPECTRUM)
        ! APPLY WEIGHTING AND NORMALIZATION
        DO IKPT=1,NKPT
          DO ISPIN=1,NSPIN
            ! DIVIDE BY BASIS WEIGHT
            IF(TBASISWGHT) THEN
              THIS%SPECTRUM(IKPT,ISPIN,:)=THIS%SPECTRUM(IKPT,ISPIN,:)/ADETPROD(IKPT,1)
            END IF
            ! NORMALIZE SPECTRUM
            IF(TNORMALIZE) THEN
              THIS%SPECTRUM(IKPT,ISPIN,:)=THIS%SPECTRUM(IKPT,ISPIN,:)/ADETSUM
            END IF  
          ENDDO
        ENDDO
        CALL XAS$UNSELECT
      ENDDO ! END ISPEC
                          CALL TIMING$CLOCKOFF('XAS$CALCULATE')
                          CALL TRACE$POP
      END SUBROUTINE XAS$CALCULATE
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$OUTPUT  ! MARK: XAS$OUTPUT
!     **************************************************************************
!     ** OUTPUT XAS SPECTRA TO FILES                                          **
!     ** REQUIRES XAS ACTIVE AND INITIALIZED                                  **
!     **************************************************************************
      USE XAS_MODULE, ONLY: TACTIVE,TINITIALIZE,NSPEC,THIS
      USE SHARED_DATA_MODULE, ONLY: ADETPROD
      USE STRINGS_MODULE
      IMPLICIT NONE
      INTEGER(4) :: NFIL
      INTEGER(4) :: NTASKS,THISTASK,RTASK
      INTEGER(4) :: NKPT
      INTEGER(4) :: NSPIN
      INTEGER(4) :: IKPT,ISPIN
      INTEGER(4) :: NE
      INTEGER(4) :: ISPEC
      REAL(8) :: EV
      CHARACTER(6) :: ID
      REAL(8), ALLOCATABLE :: SUMK(:,:) ! (3,NE) 
      INTEGER(4) :: I

      IF(.NOT.TACTIVE) RETURN
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      CALL KSMAP$READTASK(RTASK)
      IF(THISTASK.NE.RTASK) RETURN
                          CALL TRACE$PUSH('XAS$OUTPUT')
                          CALL TIMING$CLOCKON('XAS$OUTPUT')
      IF(.NOT.TINITIALIZE) THEN
        CALL ERROR$MSG('XAS NOT INITIALIZED')
        CALL ERROR$STOP('XAS$OUTPUT')
      END IF
      CALL CONSTANTS('EV',EV)
      CALL SIMULATION$SELECT('GROUND')
      CALL SIMULATION$GETI4('NKPT',NKPT)
      CALL SIMULATION$GETI4('NSPIN',NSPIN)
      CALL SIMULATION$UNSELECT
      CALL XAS$GETI4('NE',NE)
      ALLOCATE(SUMK(3,NE))

      ID=+'XASOUT'
      CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.XAS')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','REPLACE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','REWIND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','WRITE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')

      DO ISPEC=1,NSPEC
        CALL XAS$ISELECT(ISPEC)
        CALL FILEHANDLER$SETFILE(ID,.FALSE.,TRIM(ADJUSTL(THIS%FILE)))
        CALL FILEHANDLER$UNIT(ID,NFIL)
        CALL XAS_OUTPUTHEADER(NFIL)
        ! SUM OVER KPOINTS FOR SPIN 1
        SUMK(1,:)=SUM(THIS%SPECTRUM(:,1,:),DIM=1)
        IF(NSPIN.EQ.2) THEN
          ! SUM OVER KPOINTS FOR SPIN 2
          SUMK(2,:)=SUM(THIS%SPECTRUM(:,2,:),DIM=1)
        ELSE IF(NSPIN.EQ.1) THEN
          ! IF NSPIN=1, COPY SPIN 1 TO SPIN 2
          SUMK(2,:)=SUMK(1,:)
        ELSE
          CALL ERROR$MSG('INVALID NUMBER OF SPINS')
          CALL ERROR$I4VAL('NSPIN: ',NSPIN)
          CALL ERROR$STOP('XAS$OUTPUT')
        END IF
        ! SUM OVER SPINS
        SUMK(3,:)=SUM(SUMK(1:2,:),DIM=1)
        IF(THIS%BROADMODE.EQ.+'G') THEN
          ! GAUSSIAN BROADENING
          DO I=1,3
            CALL GAUSSCONV(NE,THIS%E,SUMK(I,:),THIS%EBROAD)
          ENDDO
        ELSE IF(THIS%BROADMODE.EQ.+'L') THEN
          ! LORENTZIAN BROADENING
          DO I=1,3
            CALL LORENTZCONV(NE,THIS%E,SUMK(I,:),THIS%EBROAD)
          ENDDO
        END IF
        ! ERROR: CHECK THE FACTOR OMEGA, HOW TO DEAL WITH IT? UNIT CONVERSION?
        DO I=1,NE
          WRITE(NFIL,*) THIS%E(I)/EV,THIS%E(I)/EV*SUMK(3,I),THIS%E(I)/EV*SUMK(1,I),THIS%E(I)/EV*SUMK(2,I)
        ENDDO
        CALL FILEHANDLER$CLOSE(ID)
        CALL XAS$UNSELECT
      ENDDO ! END ISPEC
      DEALLOCATE(SUMK)
                          CALL TIMING$CLOCKOFF('XAS$OUTPUT')
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE XAS$OUTPUT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$REPORT(NFIL)  ! MARK: XAS$REPORT
!     **************************************************************************
!     ** REPORT XAS MODULE TO FILE                                            **
!     ** REQUIRES XAS ACTIVE, INITIALIZED, AND UNSELECTED                     **
!     **************************************************************************
      USE XAS_MODULE, ONLY: TACTIVE,TINITIALIZE,SELECTED,NSPEC,DE,THIS,SINGLEPARTICLE
      USE STRINGS_MODULE
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: NFIL
      REAL(8) :: EV
      INTEGER(4) :: NE
      REAL(8) :: EMIN
      REAL(8) :: EMAX
      INTEGER(4) :: ISPEC
      COMPLEX(8) :: POLXYZ(3)
      CHARACTER(12) :: MODE
      INTEGER(4) :: NTASKS,THISTASK,RTASK
      LOGICAL(4) :: TADET
      LOGICAL(4) :: TBASISWGHT
      LOGICAL(4) :: TNORMALIZE
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      CALL KSMAP$READTASK(RTASK)
      IF(THISTASK.NE.RTASK) RETURN
      IF(.NOT.TACTIVE) RETURN
                          CALL TRACE$PUSH('XAS$REPORT')
      IF(.NOT.TINITIALIZE) THEN
        CALL ERROR$MSG('XAS NOT INITIALIZED')
        CALL ERROR$STOP('XAS$REPORT')
      END IF
      IF(SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('XAS SPECTRUM SELECTED')
        CALL ERROR$STOP('XAS$REPORT')
      END IF
      CALL CONSTANTS('EV',EV)
      CALL XCNTL$GETL4('ADET',TADET)
      CALL XCNTL$GETL4('BASISWGHT',TBASISWGHT)
      CALL XCNTL$GETL4('NORMALIZE',TNORMALIZE)
      WRITE(NFIL,'(A)')''
      WRITE(NFIL,'(80("#"))')
      WRITE(NFIL,FMT='(A19)')'XAS MODULE'
      WRITE(NFIL,'(80("#"))')
      IF(SINGLEPARTICLE) THEN
        WRITE(NFIL,FMT='(A)')'SINGLE PARTICLE CALCULATION (SINGLEPARTICLE=T)'
      ELSE
        WRITE(NFIL,FMT='(A)')'DETERMINANT CALCULATION (SINGLEPARTICLE=F)'
      END IF
      IF(TADET) THEN
        WRITE(NFIL,FMT='(A)')'ADET USED IN CALCULATION (ADET=T)'
      ELSE
        WRITE(NFIL,FMT='(A)')'NO ADET USED IN CALCULATION (ADET=F)'
      END IF
      IF(TNORMALIZE) THEN
        WRITE(NFIL,FMT='(A)')'NORMALIZATION USED (NORMALIZE=T)'
      ELSE
        WRITE(NFIL,FMT='(A)')'NO NORMALIZATION USED (NORMALIZE=F)'
      END IF
      IF(TBASISWGHT) THEN
        WRITE(NFIL,FMT='(A)')'K POINT BASIS WEIGHT USED (BASISWEIGHT=T)'
      ELSE
        WRITE(NFIL,FMT='(A)')'NO K POINT BASIS WEIGHT USED (BASISWEIGHT=F)'
      END IF
      WRITE(NFIL,FMT='(A12,I10)')'NSPEC:',NSPEC
      ! SAFEGUARD TO SET EMIN IF NOT PROVIDED
      CALL XAS$GETR8('EMIN',EMIN)
      WRITE(NFIL,FMT='(A12,F10.3)')'EMIN:',EMIN/EV
      ! SAFEGUARD TO SET EMAX IF NOT PROVIDED
      CALL XAS$GETR8('EMAX',EMAX)
      WRITE(NFIL,FMT='(A12,F10.3)')'EMAX:',EMAX/EV
      WRITE(NFIL,FMT='(A12,F10.3)')'DE:',DE/EV
      ! SAFEGUARD TO SET NE
      CALL XAS$GETI4('NE',NE)
      WRITE(NFIL,FMT='(A12,I10)')'NE:',NE

      DO ISPEC=1,NSPEC
        CALL XAS$ISELECT(ISPEC)
        WRITE(NFIL,'(80("-"))')
        WRITE(NFIL,FMT='(A12,I10)')'SPECTRUM:',ISPEC
        WRITE(NFIL,FMT='(A12,X,A)')'FILE:',TRIM(THIS%FILE)
        WRITE(NFIL,FMT='(A12,3F10.4)')'NORMAL:',THIS%NORMAL(:)
        WRITE(NFIL,FMT='(A12,3F10.4)')'KDIR:',THIS%KDIR(:)
        WRITE(NFIL,FMT=-'(A12,2(F8.5,SP,F8.5,"I ",S))')'POL:',THIS%POL(:)
        ! SAFEGUARD TO SET POLXYZ
        CALL XAS$GETC8A('POLXYZ',3,POLXYZ)
        WRITE(NFIL,FMT=-'(A12,3(F8.5,SP,F8.5,"I ",S))')'POLXYZ:',THIS%POLXYZ(:)
        WRITE(NFIL,FMT='(A12,F10.4)')'EBROAD[EV]:',THIS%EBROAD/EV
        IF(THIS%BROADMODE.EQ.+'G') THEN
          MODE='(GAUSSIAN)'
        ELSE IF(THIS%BROADMODE.EQ.+'L') THEN
          MODE='(LORENTZIAN)'
        ELSE IF(THIS%BROADMODE.EQ.+'N') THEN
          MODE='(NONE)'
        END IF
        WRITE(NFIL,FMT='(A12,A2,X,A)')'BROADMODE:',THIS%BROADMODE,TRIM(ADJUSTL(MODE))
        CALL XAS$UNSELECT
      ENDDO
      FLUSH(NFIL)
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE XAS$REPORT
! 
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$DEALLOCATESPECTRA  ! MARK: XAS$DEALLOCATESPECTRA
!     **************************************************************************
!     ** DEALLOCATE XAS SPECTRA                                               **
!     ** REQUIRES XAS ACTIVE AND INITIALIZED                                  **
!     **************************************************************************
      USE XAS_MODULE, ONLY: TACTIVE,TINITIALIZE,NSPEC,THIS,SPECTRA
      IMPLICIT NONE
      INTEGER(4) :: ISPEC
      IF(.NOT.TACTIVE) RETURN
                          CALL TRACE$PUSH('XAS$DEALLOCATESPECTRA')
      IF(.NOT.TINITIALIZE) THEN
        CALL ERROR$MSG('XAS NOT INITIALIZED')
        CALL ERROR$STOP('XAS$DEALLOCATESPECTRA')
      END IF
      DO ISPEC=1,NSPEC
        CALL XAS$ISELECT(ISPEC)
        IF(ALLOCATED(THIS%E)) DEALLOCATE(THIS%E)
        IF(ALLOCATED(THIS%SPECTRUM)) DEALLOCATE(THIS%SPECTRUM)
        IF(ALLOCATED(THIS%ERAW)) DEALLOCATE(THIS%ERAW)
        IF(ALLOCATED(THIS%SPECTRUMRAW)) DEALLOCATE(THIS%SPECTRUMRAW)
        CALL XAS$UNSELECT
      ENDDO ! END ISPEC
      IF(ALLOCATED(SPECTRA)) DEALLOCATE(SPECTRA)
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE XAS$DEALLOCATESPECTRA
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS_AUTOMATICENERGYWINDOW  ! MARK: XAS_AUTOMATICENERGYWINDOW
!     **************************************************************************
!     ** AUTOMATICALLY SET ENERGY WINDOW FOR XAS SPECTRUMS IF NOT GIVEN       **
!     ** IN CNTL FILE                                                         **
!     **************************************************************************
      USE XAS_MODULE, ONLY: TACTIVE,TINITIALIZE,EMIN,EMAX,NE,DE
      USE MPE_MODULE
      IMPLICIT NONE
      LOGICAL(4) :: TCALCMIN=.FALSE.
      LOGICAL(4) :: TCALCMAX=.FALSE.
      INTEGER(4) :: NKPT
      INTEGER(4) :: NSPIN
      INTEGER(4) :: IKPT
      INTEGER(4) :: ISPIN
      REAL(8) :: EGROUND
      REAL(8) :: EEXCITE
      REAL(8) :: EV
      INTEGER(4) :: EMIN_INT
      INTEGER(4) :: EMAX_INT
      REAL(8) :: E
      INTEGER(4) :: NB
      INTEGER(4) :: NOCC
      REAL(8), ALLOCATABLE :: EIG(:)
      INTEGER(4) :: IFINAL
      REAL(8) :: EFINAL
      INTEGER(4) :: NTASKS,THISTASK,RTASK
      IF(.NOT.TACTIVE) RETURN
      IF(.NOT.TINITIALIZE) THEN
        CALL ERROR$MSG('XAS NOT INITIALIZED')
        CALL ERROR$STOP('XAS_AUTOMATICENERGYWINDOW')
      END IF
      IF(EMIN.EQ.-HUGE(1.D0)) TCALCMIN=.TRUE.
      IF(EMAX.EQ.HUGE(1.D0)) TCALCMAX=.TRUE.
      IF(.NOT.TCALCMIN.AND..NOT.TCALCMAX) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('XAS AUTOMATIC ENERGY WINDOW NOT NEEDED')
        CALL ERROR$MSG('SHOULD HAVE BEEN CAUGHT BEFORE')
        CALL ERROR$STOP('XAS_AUTOMATICENERGYWINDOW')
      END IF
                          CALL TRACE$PUSH('XAS_AUTOMATICENERGYWINDOW')
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      CALL KSMAP$READTASK(RTASK)
      CALL CONSTANTS('EV',EV)
      ! GET TOTAL ENERGY FROM GROUND AND EXCITE SIMULATION
      CALL SIMULATION$SELECT('GROUND')
      CALL SIMULATION$GETI4('NKPT',NKPT)
      CALL SIMULATION$GETI4('NSPIN',NSPIN)
      CALL SIMULATION$GETR8('ETOT',EGROUND)
      CALL SIMULATION$UNSELECT
      CALL SIMULATION$SELECT('EXCITE')
      CALL SIMULATION$GETR8('ETOT',EEXCITE)
      CALL SIMULATION$UNSELECT

      IF(TCALCMIN) EMIN=HUGE(EMIN)
      IF(TCALCMAX) EMAX=-HUGE(EMAX)
      ! ONLY THE READ TASK HAS ALL ENERGY VALUES
      IF(THISTASK.EQ.RTASK) THEN
        CALL STATE$SELECT('EXCITE')
        DO IKPT=1,NKPT
          DO ISPIN=1,NSPIN
            CALL STATE$GETI4('NB',IKPT,ISPIN,NB)
            CALL STATE$GETI4('NOCC',IKPT,ISPIN,NOCC)
            ALLOCATE(EIG(NB))
            CALL STATE$GETR8A('EIG',IKPT,ISPIN,NB,EIG)
            DO IFINAL=1,NB-NOCC
              EFINAL=EEXCITE+EIG(NOCC+IFINAL)
              E=EFINAL-EGROUND
              IF(E.LT.EMIN.AND.TCALCMIN) EMIN=E
              IF(E.GT.EMAX.AND.TCALCMAX) EMAX=E
            ENDDO
            DEALLOCATE(EIG)
          ENDDO
        ENDDO
        CALL STATE$UNSELECT
      END IF
      IF(TCALCMIN) THEN
        ! LOWER EMIN TO NEXT INTEGER VALUE THAT IS AT LEAST 2EV LOWER
        ! TURN INTO ELECTRONVOLT
        EMIN=EMIN/EV
        EMIN_INT=FLOOR(EMIN)
        IF(REAL(EMIN_INT, KIND=8).GT.EMIN-2.D0) EMIN_INT=EMIN_INT-1
        EMIN=REAL(EMIN_INT,KIND=8)
        ! TURN BACK INTO ENERGY UNITS
        EMIN=EMIN*EV
      END IF
      IF(TCALCMAX) THEN
        ! UPPER EMAX TO NEXT INTEGER VALUE THAT IS AT LEAST 2EV HIGHER
        ! TURN INTO ELECTRONVOLT
        EMAX=EMAX/EV
        EMAX_INT=CEILING(EMAX)
        IF(REAL(EMAX_INT, KIND=8).LT.EMAX+2.D0) EMAX_INT=EMAX_INT+1
        EMAX=REAL(EMAX_INT,KIND=8)
        ! TURN BACK INTO ENERGY UNITS
        EMAX=EMAX*EV
      END IF
      IF(TCALCMIN.OR.TCALCMAX) THEN
        NE=INT((EMAX-EMIN)/DE)+1
        CALL MPE$BROADCAST('~',RTASK,NE)
      END IF
      IF(TCALCMIN) CALL MPE$BROADCAST('~',RTASK,EMIN)
      IF(TCALCMAX) CALL MPE$BROADCAST('~',RTASK,EMAX)
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE XAS_AUTOMATICENERGYWINDOW
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS_OUTPUTHEADER(NFIL)  ! MARK: XAS_OUTPUTHEADER
!     **************************************************************************
!     ** OUTPUT HEADER FOR XAS SPECTRUM                                       **
!     ** REQUIRES XAS ACTIVE AND INITIALIZED                                  **
!     ** REQUIRES XAS SPECTRUM SELECTED                                      **
!     **************************************************************************
      USE XAS_MODULE, ONLY: TACTIVE,TINITIALIZE,SELECTED,THIS,SINGLEPARTICLE
      USE CLOCK_MODULE
      USE STRINGS_MODULE
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: NFIL
      CHARACTER(32) :: DATETIME
      REAL(8) :: EV
      INTEGER(4) :: NTASKS,THISTASK,RTASK
      CHARACTER(512) :: RELEASE=''
      CHARACTER(512) :: REMOTE='UNKNOWN'
      CHARACTER(512) :: HASH='UNKNOWN'
      CHARACTER(512) :: BRANCH='UNKNOWN'
      CHARACTER(512) :: SHORTREVISIONNUMBER='UNKNOWN'
      CHARACTER(512) :: AUTHOR='UNKNOWN'
      CHARACTER(512) :: COMMITDATE='UNKNOWN'
      CHARACTER(512) :: COMPILEDATE='UNKNOWN'
      CHARACTER(512) :: COMPILEPERSON='UNKNOWN'
      INTEGER(4)     :: NUMCHANGES=0
      LOGICAL(4) :: TADET
      LOGICAL(4) :: TBASISWGHT
      LOGICAL(4) :: TNORMALIZE
      INCLUDE 'CPPAW_VERSION.INFO'  ! FILENAME MADE LOWERCASE BY F90PP.SED 
      IF(.NOT.TACTIVE) RETURN
      IF(.NOT.TINITIALIZE) THEN
        CALL ERROR$MSG('XAS NOT INITIALIZED')
        CALL ERROR$STOP('XAS_OUTPUTHEADER')
      END IF
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('XAS SPECTRUM NOT SELECTED')
        CALL ERROR$STOP('XAS_OUTPUTHEADER')
      END IF
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      CALL KSMAP$READTASK(RTASK)
      IF(THISTASK.NE.RTASK) RETURN
      CALL XCNTL$GETL4('ADET',TADET)
      CALL XCNTL$GETL4('BASISWGHT',TBASISWGHT)
      CALL XCNTL$GETL4('NORMALIZE',TNORMALIZE)
      CALL CONSTANTS('EV',EV)
      WRITE(NFIL,'(80("#"))')
      WRITE(NFIL,FMT='("# ",A)')'XAS OUTPUT'
      CALL CLOCK$NOW(DATETIME)
      WRITE(NFIL,FMT='("# ",A12,X,A32)')'DATE:',DATETIME
      WRITE(NFIL,FMT='("# ",A)')-'HASH=        '//TRIM(HASH)
      WRITE(NFIL,FMT='("# ",A)')-'BRANCH=      '//TRIM(BRANCH)
      WRITE(NFIL,FMT='("# ",A)')-'REMOTE=      '//TRIM(REMOTE)
      IF(NUMCHANGES.GT.0) THEN
        WRITE(NFIL,FMT='("# ",I6,A)')NUMCHANGES,-' CHANGES SINCE LAST COMMIT'
      ELSE
        WRITE(NFIL,FMT='("# ",A)')-'NO CHANGES SINCE LAST COMMIT'
      END IF
      IF(SINGLEPARTICLE) THEN
        WRITE(NFIL,FMT='("# ",A)')'SINGLE PARTICLE CALCULATION (SINGLEPARTICLE=T)'
      ELSE
        WRITE(NFIL,FMT='("# ",A)')'DETERMINANT CALCULATION (SINGLEPARTICLE=F)'
      END IF
      IF(TADET) THEN
        WRITE(NFIL,FMT='("# ",A)')'ADET USED IN CALCULATION (ADET=T)'
      ELSE
        WRITE(NFIL,FMT='("# ",A)')'NO ADET USED IN CALCULATION (ADET=F)'
      END IF
      IF(TNORMALIZE) THEN
        WRITE(NFIL,FMT='("# ",A)')'NORMALIZATION USED (NORMALIZE=T)'
      ELSE
        WRITE(NFIL,FMT='("# ",A)')'NO NORMALIZATION USED (NORMALIZE=F)'
      END IF
      IF(TBASISWGHT) THEN
        WRITE(NFIL,FMT='("# ",A)')'K POINT BASIS WEIGHT USED (BASISWEIGHT=T)'
      ELSE
        WRITE(NFIL,FMT='("# ",A)')'NO K POINT BASIS WEIGHT USED (BASISWEIGHT=F)'
      END IF
      IF(THIS%BROADMODE.EQ.+'N') THEN
        WRITE(NFIL,FMT='("# ",A12,X,A)')'BROADEN:','NONE'
      ELSE IF(THIS%BROADMODE.EQ.+'G') THEN
        WRITE(NFIL,FMT='("# ",A12,X,A)')'BROADEN:','GAUSSIAN'
      ELSE IF(THIS%BROADMODE.EQ.+'L') THEN
        WRITE(NFIL,FMT='("# ",A12,X,A)')'BROADEN:','LORENTZIAN'
      END IF      
      IF(THIS%BROADMODE.NE.+'N') THEN
        WRITE(NFIL,FMT='("# ",A12,F10.4)')'EBROAD[EV]:',THIS%EBROAD/EV
      END IF
      WRITE(NFIL,FMT='("# ",A12,3F10.4)')'NORMAL:',THIS%NORMAL(:)
      WRITE(NFIL,FMT='("# ",A12,3F10.4)')'KDIR:',THIS%KDIR(:)
      WRITE(NFIL,FMT=-'("# ",A12,2(F8.5,SP,F8.5,"I ",S))')'POL:',THIS%POL(:)
      WRITE(NFIL,FMT=-'("# ",A12,3(F8.5,SP,F8.5,"I ",S))')'POLXYZ:',THIS%POLXYZ(:)
      WRITE(NFIL,'(80("#"))')
      RETURN
      END SUBROUTINE XAS_OUTPUTHEADER
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$ISELECT(ISPEC)  ! MARK: XAS$ISELECT
!     **************************************************************************
!     ** SELECT SPECTRUM FOR XAS MODULE                                       **
!     ** REQUIRES XAS INITIALIZED                                             **
!     **************************************************************************
      USE XAS_MODULE, ONLY: TINITIALIZE,NSPEC,SELECTED,SPECTRA,THIS
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: ISPEC
      IF(.NOT.TINITIALIZE) THEN
        CALL ERROR$MSG('XAS NOT INITIALIZED')
        CALL ERROR$STOP('XAS$ISELECT')
      END IF
      IF(SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('XAS SPECTRUM ALREADY SELECTED')
        CALL ERROR$STOP('XAS$ISELECT')
      END IF
      IF(ISPEC.LE.0.OR.ISPEC.GT.NSPEC) THEN
        CALL ERROR$MSG('INVALID SPECTRUM INDEX')
        CALL ERROR$I4VAL('SPECTRUM INDEX: ',ISPEC)
        CALL ERROR$STOP('XAS$ISELECT')
      END IF
      THIS=>SPECTRA(ISPEC)
      SELECTED=.TRUE.
      RETURN
      END SUBROUTINE XAS$ISELECT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$UNSELECT()  ! MARK: XAS$UNSELECT
!     **************************************************************************
!     ** UNSELECT SPECTRUM FOR XAS MODULE                                     **
!     ** REQUIRES XAS INITIALIZED AND SELECTED                                **
!     **************************************************************************
      USE XAS_MODULE, ONLY: TINITIALIZE,SELECTED,THIS
      IMPLICIT NONE
      IF(.NOT.TINITIALIZE) THEN
        CALL ERROR$MSG('XAS NOT INITIALIZED')
        CALL ERROR$STOP('XAS$UNSELECT')
      END IF
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('CANNOT UNSELECT SPECTRUM IF NONE SELECTED')
        CALL ERROR$STOP('XAS$UNSELECT')
      END IF
      NULLIFY(THIS)
      SELECTED=.FALSE.
      RETURN
      END SUBROUTINE XAS$UNSELECT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$GETL4(ID,VAL)  ! MARK: XAS$GETL4
!     **************************************************************************
!     ** GET LOGICAL FROM XAS MODULE                                         **
!     **************************************************************************
      USE XAS_MODULE, ONLY: TACTIVE,TINITIALIZE,SELECTED,THIS,SINGLEPARTICLE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      LOGICAL(4), INTENT(OUT) :: VAL
      IF(ID.EQ.'INITIALIZE') THEN
        VAL=TINITIALIZE
      ELSE IF(ID.EQ.'ACTIVE') THEN
        VAL=TACTIVE
      ELSE IF(ID.EQ.'SINGLEPARTICLE') THEN
        VAL=SINGLEPARTICLE
      ELSE IF(ID.EQ.'TPOLXYZ') THEN
          IF(.NOT.TINITIALIZE) THEN
            CALL ERROR$MSG('XAS NOT INITIALIZED')
            CALL ERROR$STOP('XAS$GETL4')
          END IF
          IF(.NOT.SELECTED) THEN
            CALL ERROR$MSG('XAS SPECTRUM NOT SELECTED')
            CALL ERROR$STOP('XAS$GETL4')
          END IF
          VAL=THIS%TPOLXYZ
      ELSE
        CALL ERROR$MSG('XAS GETL4 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('XAS$GETL4')
      END IF
      RETURN
      END SUBROUTINE XAS$GETL4
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$SETL4(ID,VAL)  ! MARK: XAS$SETL4
!     **************************************************************************
!     ** SET LOGICAL IN XAS MODULE                                           **
!     **************************************************************************
      USE XAS_MODULE, ONLY: TACTIVE,TINITIALIZE,SELECTED,THIS,SINGLEPARTICLE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      LOGICAL(4), INTENT(IN) :: VAL
      IF(ID.EQ.'ACTIVE') THEN
        TACTIVE=VAL
      ELSE IF(ID.EQ.'INITIALIZE') THEN
        TINITIALIZE=VAL
      ELSE IF(ID.EQ.'SINGLEPARTICLE') THEN
        SINGLEPARTICLE=VAL
      ELSE IF(ID.EQ.'TPOLXYZ') THEN
        IF(.NOT.SELECTED) THEN
          CALL ERROR$MSG('XAS SPECTRUM NOT SELECTED')
          CALL ERROR$STOP('XAS$SETL4')
        END IF
        THIS%TPOLXYZ=VAL
      ELSE
        CALL ERROR$MSG('XAS SETL4 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('XAS$SETL4')
      END IF
      RETURN
      END SUBROUTINE XAS$SETL4
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$GETI4(ID,VAL)  ! MARK: XAS$GETI4
!     **************************************************************************
!     ** GET INTEGER FROM XAS MODULE                                        **
!     **************************************************************************
      USE XAS_MODULE, ONLY: NSPEC,NE,TINITIALIZE,EMIN,EMAX,DE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(OUT) :: VAL
      IF(.NOT.TINITIALIZE) THEN
        CALL ERROR$MSG('XAS NOT INITIALIZED')
        CALL ERROR$STOP('XAS$GETI4')
      END IF
      IF(ID.EQ.'NSPEC') THEN
        VAL=NSPEC
      ELSE IF(ID.EQ.'NE') THEN
        IF(EMIN.EQ.-HUGE(1.D0).OR.EMAX.EQ.-HUGE(1.D0)) THEN
          CALL XAS_AUTOMATICENERGYWINDOW
        END IF
        NE=INT((EMAX-EMIN)/DE)+1
        VAL=NE
      ELSE
        CALL ERROR$MSG('XAS GETI4 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('XAS$GETI4')
      END IF
      RETURN
      END SUBROUTINE XAS$GETI4
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$SETI4(ID,VAL)  ! MARK: XAS$SETI4
!     **************************************************************************
!     ** SET INTEGER IN XAS MODULE                                          **
!     **************************************************************************
      USE XAS_MODULE, ONLY: NSPEC,NE,SPECTRA
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: VAL
      IF(ID.EQ.'NSPEC') THEN
        NSPEC=VAL
        IF(.NOT.ALLOCATED(SPECTRA)) THEN
          ALLOCATE(SPECTRA(NSPEC))
        ELSE
          CALL ERROR$MSG('XAS SETI4 NSPEC ALREADY ALLOCATED')
          CALL ERROR$I4VAL('OLD NSPEC: ',SIZE(SPECTRA))
          CALL ERROR$I4VAL('NEW NSPEC: ',VAL)
          CALL ERROR$STOP('XAS$SETI4')
        END IF
      ELSE IF(ID.EQ.'NE') THEN
        NE=VAL
      ELSE
        CALL ERROR$MSG('XAS SETI4 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('XAS$SETI4')
      END IF
      RETURN
      END SUBROUTINE XAS$SETI4
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$GETR8(ID,VAL)  ! MARK: XAS$GETR8
!     **************************************************************************
!     ** GET REAL FROM XAS MODULE                                             **
!     **************************************************************************
      USE XAS_MODULE, ONLY: EMIN,EMAX,DE,TINITIALIZE,SELECTED,THIS
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      REAL(8), INTENT(OUT) :: VAL
      IF(.NOT.TINITIALIZE) THEN
        CALL ERROR$MSG('XAS NOT INITIALIZED')
        CALL ERROR$STOP('XAS$GETR8')
      END IF
      IF(ID.EQ.'EMIN') THEN
        IF(EMIN.EQ.-HUGE(1.D0)) CALL XAS_AUTOMATICENERGYWINDOW
        VAL=EMIN
      ELSE IF(ID.EQ.'EMAX') THEN
        IF(EMAX.EQ.HUGE(1.D0)) CALL XAS_AUTOMATICENERGYWINDOW
        VAL=EMAX
      ELSE IF(ID.EQ.'DE') THEN
        VAL=DE
      ELSE IF(ID.EQ.'EBROAD') THEN
        IF(.NOT.SELECTED) THEN
          CALL ERROR$MSG('XAS SPECTRUM NOT SELECTED')
          CALL ERROR$STOP('XAS$GETR8')
        END IF
        VAL=THIS%EBROAD
      ELSE
        CALL ERROR$MSG('XAS GETR8 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('XAS$GETR8')
      END IF
      RETURN
      END SUBROUTINE XAS$GETR8
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$SETR8(ID,VAL)  ! MARK: XAS$SETR8
!     **************************************************************************
!     ** SET REAL IN XAS MODULE                                               **
!     **************************************************************************
      USE XAS_MODULE, ONLY: EMIN,EMAX,DE,SELECTED,THIS
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      REAL(8), INTENT(IN) :: VAL
      IF(ID.EQ.'EMIN') THEN
        EMIN=VAL
      ELSE IF(ID.EQ.'EMAX') THEN
        EMAX=VAL
      ELSE IF(ID.EQ.'DE') THEN
        DE=VAL
      ELSE IF(ID.EQ.'EBROAD') THEN
        IF(.NOT.SELECTED) THEN
          CALL ERROR$MSG('XAS SPECTRUM NOT SELECTED')
          CALL ERROR$STOP('XAS$SETR8')
        END IF
        THIS%EBROAD=VAL
      ELSE
        CALL ERROR$MSG('XAS SETR8 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('XAS$SETR8')
      END IF
      RETURN
      END SUBROUTINE XAS$SETR8
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$GETCH(ID,VAL)  ! MARK: XAS$GETCH
!     **************************************************************************
!     ** GET CHARACTER FROM XAS MODULE                                       **
!     **************************************************************************
      USE XAS_MODULE, ONLY: TINITIALIZE,SELECTED,THIS
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      CHARACTER(*), INTENT(OUT) :: VAL
      IF(.NOT.TINITIALIZE) THEN
        CALL ERROR$MSG('XAS NOT INITIALIZED')
        CALL ERROR$STOP('XAS$GETCH')
      END IF
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('XAS SPECTRUM NOT SELECTED')
        CALL ERROR$STOP('XAS$GETCH')
      END IF
      IF(ID.EQ.'FILE') THEN
        VAL=THIS%FILE
      ELSE IF(ID.EQ.'BROADMODE') THEN
        VAL=THIS%BROADMODE
      ELSE
        CALL ERROR$MSG('XAS GETCH ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('XAS$GETCH')
      END IF
      RETURN
      END SUBROUTINE XAS$GETCH
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$SETCH(ID,VAL)  ! MARK: XAS$SETCH
!     **************************************************************************
!     ** SET CHARACTER IN XAS MODULE                                         **
!     **************************************************************************
      USE XAS_MODULE, ONLY: SELECTED,THIS
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      CHARACTER(*), INTENT(IN) :: VAL
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('XAS SPECTRUM NOT SELECTED')
        CALL ERROR$STOP('XAS$SETCH')
      END IF
      IF(ID.EQ.'FILE') THEN
        THIS%FILE=VAL
      ELSE IF(ID.EQ.'BROADMODE') THEN
        THIS%BROADMODE=VAL
      ELSE
        CALL ERROR$MSG('XAS SETCH ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('XAS$SETCH')
      END IF
      RETURN
      END SUBROUTINE XAS$SETCH
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$GETR8A(ID,LEN,VAL)  ! MARK: XAS$GETR8A
!     **************************************************************************
!     ** GET REAL ARRAY FROM XAS MODULE                                      **
!     ** REQUIRES XAS INITIALIZED AND SELECTED                                 **
!     **************************************************************************
      USE XAS_MODULE, ONLY: SELECTED,THIS,TINITIALIZE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: LEN
      REAL(8), INTENT(OUT) :: VAL(LEN)
      IF(.NOT.TINITIALIZE) THEN
        CALL ERROR$MSG('XAS NOT INITIALIZED')
        CALL ERROR$STOP('XAS$GETR8A')
      END IF
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('XAS SPECTRUM NOT SELECTED')
        CALL ERROR$STOP('XAS$GETR8A')
      END IF
      IF(ID.EQ.'NORMAL') THEN
        IF(LEN.NE.3) THEN
          CALL ERROR$MSG('XAS GETR8A NORMAL LEN NOT 3')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$STOP('XAS$GETR8A')
        END IF
        VAL(:)=THIS%NORMAL(:)
      ELSE IF(ID.EQ.'KDIR') THEN
        IF(LEN.NE.3) THEN
          CALL ERROR$MSG('XAS GETR8A KDIR LEN NOT 3')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$STOP('XAS$GETR8A')
        END IF
        VAL(:)=THIS%KDIR(:)
      ELSE
        CALL ERROR$MSG('XAS GETR8A ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('XAS$GETR8A')
      END IF
      RETURN
      END SUBROUTINE XAS$GETR8A
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$SETR8A(ID,LEN,VAL)  ! MARK: XAS$SETR8A
!     **************************************************************************
!     ** SET REAL ARRAY IN XAS MODULE                                         **
!     **************************************************************************
      USE XAS_MODULE, ONLY: SELECTED,THIS
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: LEN
      REAL(8), INTENT(IN) :: VAL(LEN)
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('XAS SPECTRUM NOT SELECTED')
        CALL ERROR$STOP('XAS$SETR8A')
      END IF
      IF(ID.EQ.'NORMAL') THEN
        IF(LEN.NE.3) THEN
          CALL ERROR$MSG('XAS SETR8A NORMAL LEN NOT 3')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$STOP('XAS$SETR8A')
        END IF
        THIS%NORMAL(:)=VAL(:)
      ELSE IF(ID.EQ.'KDIR') THEN
        IF(LEN.NE.3) THEN
          CALL ERROR$MSG('XAS SETR8A KDIR LEN NOT 3')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$STOP('XAS$SETR8A')
        END IF
        THIS%KDIR(:)=VAL(:)
      ELSE
        CALL ERROR$MSG('XAS SETR8A ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('XAS$SETR8A')
      END IF
      RETURN
      END SUBROUTINE XAS$SETR8A
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$GETC8A(ID,LEN,VAL)  ! MARK: XAS$GETC8A
!     **************************************************************************
!     ** GET CHARACTER ARRAY FROM XAS MODULE                                 **
!     ** REQUIRES XAS INITIALIZED AND SELECTED                                 **
!     **************************************************************************
      USE XAS_MODULE, ONLY: SELECTED,THIS,TINITIALIZE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: LEN
      COMPLEX(8), INTENT(OUT) :: VAL(LEN)
      IF(.NOT.TINITIALIZE) THEN
        CALL ERROR$MSG('XAS NOT INITIALIZED')
        CALL ERROR$STOP('XAS$GETC8A')
      END IF
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('XAS SPECTRUM NOT SELECTED')
        CALL ERROR$STOP('XAS$GETC8A')
      END IF
      IF(ID.EQ.'POL') THEN
        IF(LEN.NE.2) THEN
          CALL ERROR$MSG('XAS GETC8A POL LEN NOT 2')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$STOP('XAS$GETC8A')
        END IF
        VAL(:)=THIS%POL(:)
      ELSE IF(ID.EQ.'POLXYZ') THEN
        IF(LEN.NE.3) THEN
          CALL ERROR$MSG('XAS GETC8A POLXYZ LEN NOT 3')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$STOP('XAS$GETC8A')
        END IF
        IF(.NOT.THIS%TPOLXYZ) THEN
          CALL POLARISATION_CONVERT(THIS%KDIR,THIS%NORMAL,THIS%POL,THIS%POLXYZ)
          THIS%TPOLXYZ=.TRUE.
        END IF
        VAL(:)=THIS%POLXYZ(:)
      ELSE
        CALL ERROR$MSG('XAS GETC8A ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('XAS$GETC8A')
      END IF
      RETURN
      END SUBROUTINE XAS$GETC8A
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$SETC8A(ID,LEN,VAL)  ! MARK: XAS$SETC8A
!     **************************************************************************
!     ** SET CHARACTER ARRAY IN XAS MODULE                                    **
!     **************************************************************************
      USE XAS_MODULE, ONLY: SELECTED,THIS
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: LEN
      COMPLEX(8), INTENT(IN) :: VAL(LEN)
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('XAS SPECTRUM NOT SELECTED')
        CALL ERROR$STOP('XAS$SETC8A')
      END IF
      IF(ID.EQ.'POL') THEN
        IF(LEN.NE.2) THEN
          CALL ERROR$MSG('XAS SETC8A POL LEN NOT 2')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$STOP('XAS$SETC8A')
        END IF
        THIS%POL(:)=VAL(:)
      ! ELSE IF(ID.EQ.'POLXYZ') THEN
      !   IF(LEN.NE.3) THEN
      !     CALL ERROR$MSG('XAS SETC8A POLXYZ LEN NOT 3')
      !     CALL ERROR$I4VAL('LEN: ',LEN)
      !     CALL ERROR$STOP('XAS$SETC8A')
      !   END IF
      !   THIS%POLXYZ(:)=VAL(:)
      ELSE
        CALL ERROR$MSG('XAS SETC8A ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('XAS$SETC8A')
      END IF
      RETURN
      END SUBROUTINE XAS$SETC8A
!
!     ==========================================================================
!     ==========================================================================
!     ==                      RIXS MODULE FUNCTIONS                           ==
!     ==========================================================================
!     ==========================================================================
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS$CALCULATE  ! MARK: RIXS$CALCULATE
!     **************************************************************************
!     ** CALCULATE RIXS AMPLITUDE                                             **
!     ** REQUIRES RIXS ACTIVE AND INITIALIZED                                 **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: TACTIVE,TINITIALIZE
      USE MPE_MODULE
      IMPLICIT NONE
      IF(.NOT.TACTIVE) RETURN
                          CALL TRACE$PUSH('RIXS$CALCULATE')
                          CALL TIMING$CLOCKON('RIXS$CALCULATE')
      IF(.NOT.TINITIALIZE) THEN
        CALL ERROR$MSG('RIXS NOT INITIALIZED')
        CALL ERROR$STOP('RIXS$CALCULATE')
      END IF
      
      CALL RIXS_ABSORB
      
      CALL RIXS_ONEKPT

      CALL RIXS_TWOKPT

      ! DIFFERENTIATE BETWEEN SPECTRA THAT ARE AT ONE KPT AND ONES THAT ARE AT TWO

      ! WORK OUT EFFICIENT ORDER TO AVOID REPEATED CALCULATIONS

      ! CALCULATE SPECTRA AT TWO KPTS

      ! FIGURE OUT HOW TO STORE SPECTRA AND HOW TO OUTPUT THEM FOR TWO KPTS


                          CALL TIMING$CLOCKOFF('RIXS$CALCULATE')
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE RIXS$CALCULATE
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS$OUTPUT  ! MARK: RIXS$OUTPUT
!     **************************************************************************
!     ** OUTPUT RIXS AMPLITUDES TO FILES                                      **
!     ** REQUIRES RIXS ACTIVE, INITIALIZED, AND UNSELECTED                    **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: TACTIVE,TINITIALIZE,THIS,NSPEC
      USE STRINGS_MODULE
      IMPLICIT NONE
      INTEGER(4) :: NFIL
      INTEGER(4) :: ISPEC
      INTEGER(4) :: NTASKS,THISTASK,RTASK,WTASK
      CHARACTER(256) :: FILENAME
      CHARACTER(7) :: ID

      IF(.NOT.TACTIVE) RETURN
                          CALL TRACE$PUSH('RIXS$OUTPUT')
      IF(.NOT.TINITIALIZE) THEN
        CALL ERROR$MSG('RIXS NOT INITIALIZED')
        CALL ERROR$STOP('RIXS$OUTPUT')
      END IF
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      CALL KSMAP$READTASK(RTASK)

      ID=+'RIXSOUT'
      CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.RIXS')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','WRITE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','UNFORMATTED')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','REWIND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','REPLACE')

      DO ISPEC=1,NSPEC
        CALL RIXS$ISELECT(ISPEC)
        CALL FILEHANDLER$SETFILE(ID,.FALSE.,TRIM(THIS%FILE))
        IF(THISTASK.EQ.RTASK) CALL FILEHANDLER$UNIT(ID,NFIL)

        CALL RIXS_OUTPUTHEADER(NFIL)

        CALL RIXS_OUTPUTDATA(NFIL)

! CONTINUE HERE

        CALL FILEHANDLER$CLOSE(ID)
        CALL RIXS$UNSELECT
      ENDDO
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE RIXS$OUTPUT

!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS$REPORT(NFIL)  ! MARK: RIXS$REPORT
!     **************************************************************************
!     ** REPORT RIXS MODULE TO FILE                                           **
!     ** REQUIRES RIXS ACTIVE, INITIALIZED, AND UNSELECTED                    **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: TACTIVE,TINITIALIZE,THIS,NSPEC,EMIN,EMAX
      USE STRINGS_MODULE
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: NFIL
      INTEGER(4) :: ISPEC
      INTEGER(4) :: IKPT
      INTEGER(4) :: NTASKS,THISTASK,RTASK
      REAL(8) :: EV
      COMPLEX(8) :: POLXYZ(3)
      INTEGER(4) :: NKPTTOT
      REAL(8) :: ANGSTROM
      LOGICAL(4) :: TADET
      LOGICAL(4) :: TBASISWGHT
      LOGICAL(4) :: TNORMALIZE
      LOGICAL(4) :: TMOMEMTUM
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      CALL KSMAP$READTASK(RTASK)
      IF(THISTASK.NE.RTASK) RETURN
      IF(.NOT.TACTIVE) RETURN
                          CALL TRACE$PUSH('RIXS$REPORT')
      IF(.NOT.TINITIALIZE) THEN
        CALL ERROR$MSG('RIXS NOT INITIALIZED')
        CALL ERROR$STOP('RIXS$REPORT')
      END IF
      CALL XCNTL$GETL4('MOMEMTUMTRANSFER',TMOMEMTUM)
      CALL XCNTL$GETL4('ADET',TADET)
      CALL XCNTL$GETL4('BASISWGHT',TBASISWGHT)
      CALL XCNTL$GETL4('NORMALIZE',TNORMALIZE)
      CALL CONSTANTS('EV',EV)
      CALL CONSTANTS('ANGSTROM',ANGSTROM)
      WRITE(NFIL,'(A)')''
      WRITE(NFIL,'(80("#"))')
      WRITE(NFIL,FMT='(A19)')'RIXS MODULE'
      WRITE(NFIL,'(80("#"))')
      IF(TMOMEMTUM) THEN
        WRITE(NFIL,FMT='(A)')'MOMENTUM TRANSFER USED (MOMEMTUMTRANSFER=T)'
      ELSE
        WRITE(NFIL,FMT='(A)')'NO MOMENTUM TRANSFER USED (MOMEMTUMTRANSFER=F)'
      END IF
      IF(TADET) THEN
        WRITE(NFIL,FMT='(A)')'ADET USED IN CALCULATION (ADET=T)'
      ELSE
        WRITE(NFIL,FMT='(A)')'NO ADET USED IN CALCULATION (ADET=F)'
      END IF
      IF(TNORMALIZE) THEN
        WRITE(NFIL,FMT='(A)')'NORMALIZATION USED (NORMALIZE=T)'
      ELSE
        WRITE(NFIL,FMT='(A)')'NO NORMALIZATION USED (NORMALIZE=F)'
      END IF
      IF(TBASISWGHT) THEN
        WRITE(NFIL,FMT='(A)')'K POINT BASIS WEIGHT USED (BASISWEIGHT=T)'
      ELSE
        WRITE(NFIL,FMT='(A)')'NO K POINT BASIS WEIGHT USED (BASISEIWGHT=F)'
      END IF
      WRITE(NFIL,FMT='(A12,I10)')'NSPEC:',NSPEC
      IF(EMIN.NE.-HUGE(1.D0)) WRITE(NFIL,FMT='(A12,F10.3)')'EMIN:',EMIN/EV
      IF(EMAX.NE.HUGE(1.D0)) WRITE(NFIL,FMT='(A12,F10.3)')'EMAX:',EMAX/EV

      DO ISPEC=1,NSPEC
        CALL RIXS$ISELECT(ISPEC)
        WRITE(NFIL,'(80("-"))')
        WRITE(NFIL,FMT='(A12,I10)')'SPECTRUM:',ISPEC
        WRITE(NFIL,FMT='(A12,X,A)')'FILE:',TRIM(THIS%FILE)
        WRITE(NFIL,FMT='(A12,3F10.4)')'NORMAL:',THIS%NORMAL(:)
        WRITE(NFIL,FMT='(A12,F10.4)')'ELIGHT[EV]:',THIS%ELIGHT/EV
        WRITE(NFIL,FMT='(A12,F10.4)')'GAMMA[EV]:',THIS%GAMMA/EV
        ! INCOMING LIGHT
        WRITE(NFIL,FMT='(A)') 'INCOMING LIGHT'
        WRITE(NFIL,FMT='(A12,3F10.4)')'KDIRI:',THIS%KDIRI(:)
        WRITE(NFIL,FMT='(A12,3F10.4)')'KI[1/AA]:',THIS%KI(:)*ANGSTROM
        WRITE(NFIL,FMT='(A12,3F10.4)')'XKI:',THIS%XKI(:)
        WRITE(NFIL,FMT=-'(A12,2(F8.5,SP,F8.5,"I ",S))')'POLI:',THIS%POLI(:)
        ! SAFEGUARD TO SET POLXYZI
        CALL RIXS$GETC8A('POLXYZI',3,POLXYZ)
        WRITE(NFIL,FMT=-'(A12,3(F8.5,SP,F8.5,"I ",S))')'POLXYZI:',THIS%POLXYZI(:)

        ! OUTGOING LIGHT
        WRITE(NFIL,FMT='(A)') 'OUTGOING LIGHT'
        WRITE(NFIL,FMT='(A12,3F10.4)')'KDIRO:',THIS%KDIRO(:)
        WRITE(NFIL,FMT='(A12,3F10.4)')'KO[1/AA]:',THIS%KO(:)*ANGSTROM
        WRITE(NFIL,FMT='(A12,3F10.4)')'XKO:',THIS%XKO(:)
        WRITE(NFIL,FMT=-'(A12,2(F8.5,SP,F8.5,"I ",S))')'POLO:',THIS%POLO(:)
        ! SAFEGUARD TO SET POLXYZO
        CALL RIXS$GETC8A('POLXYZO',3,POLXYZ)
        WRITE(NFIL,FMT=-'(A12,3(F8.5,SP,F8.5,"I ",S))')'POLXYZO:',THIS%POLXYZO(:)
        ! MOMENTUM TRANSFER
        WRITE(NFIL,FMT='(A,L2)')'MOMENTUM TRANSFER ACTIVE: ',THIS%TKPTSHIFT
        IF(.NOT.TMOMEMTUM) THEN
          WRITE(NFIL,FMT='(A)')'WARNING: MOMENTUM TRANSFER ARTIFICIALLY DISABLED'
        END IF
        WRITE(NFIL,FMT='(A12,3F10.4)')'Q[1/AA]:',THIS%Q(:)*ANGSTROM
        WRITE(NFIL,FMT='(A12,3F10.4)')'QAPPROX:',THIS%QAPPROX(:)*ANGSTROM
        WRITE(NFIL,FMT='(A12,F10.4)')'QERROR:',THIS%QERROR*ANGSTROM
        WRITE(NFIL,FMT='(A12,3F10.4)')'XQ:',THIS%XQ(:)
        WRITE(NFIL,FMT='(A12,3F10.4)')'XQAPPROX:',THIS%XQAPPROX(:)
        
        IF(THIS%TKPTSHIFT) THEN
          CALL SIMULATION$SELECT('GROUND')
          CALL SIMULATION$GETI4('NKPTTOT',NKPTTOT)
          CALL SIMULATION$UNSELECT
          WRITE(NFIL,FMT='(A)')'MOMENTUM TRANSFER KPT SHIFT'
          WRITE(NFIL,FMT='(2A10)') 'IKPTTOT','JKPTTOT'
          DO IKPT=1,NKPTTOT
            WRITE(NFIL,FMT='(I10,"->",I8)') IKPT,THIS%JOFIKPT(IKPT)
          ENDDO
        END IF
        CALL RIXS$UNSELECT
      ENDDO
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE RIXS$REPORT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS$KVECTORS  ! MARK: RIXS$KVECTORS
!     **************************************************************************
!     ** CALCULATE K-VECTORS FOR RIXS MODULE                                  **
!     ** REQUIRES RIXS INITIALIZED                                            **
!     ** REQUIRES RIXS SPECTRUM UNSELECTED                                    **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: TINITIALIZE,SELECTED,THIS,NSPEC
      IMPLICIT NONE
      INTEGER(4) :: ISPEC
      REAL(8) :: RBAS(3,3)
      LOGICAL(4) :: TACTIVE
      CALL RIXS$GETL4('ACTIVE',TACTIVE)
      IF(.NOT.TACTIVE) RETURN
                          CALL TRACE$PUSH('RIXS$KVECTORS')
      CALL SIMULATION$SELECT('GROUND')
      CALL SIMULATION$GETR8A('RBAS',9,RBAS)
      CALL SIMULATION$UNSELECT
      IF(.NOT.TINITIALIZE) THEN
        CALL ERROR$MSG('RIXS NOT INITIALIZED')
        CALL ERROR$STOP('RIXS$KVECTORS')
      END IF
      IF(SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('RIXS SPECTRUM ALREADY SELECTED')
        CALL ERROR$STOP('RIXS$KVECTORS')
      END IF
      DO ISPEC=1,NSPEC
        CALL RIXS$ISELECT(ISPEC)
        CALL KVEC(THIS%ELIGHT,THIS%KDIRI,THIS%KI)
        ! WARNING: APPROXIMATION KF IS CALCULATED WITH THE EXCITATION ENERGY 
        !          AND NOT THE EMISSION ENERGY
        CALL KVEC(THIS%ELIGHT,THIS%KDIRO,THIS%KO)
        THIS%Q=THIS%KI-THIS%KO
        CALL KTOXK(THIS%KI,RBAS,THIS%XKI)
        CALL KTOXK(THIS%KO,RBAS,THIS%XKO)
        CALL KTOXK(THIS%Q,RBAS,THIS%XQ)
        CALL RIXS$UNSELECT
      ENDDO
      ! CALCULATE APPROXIMATED Q VECTOR
      CALL RIXS_QTRANSFER
      ! CALCULATE MAPPING FOR KPT SHIFT
      CALL RIXS_SHIFTMAP
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE RIXS$KVECTORS
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS_QTRANSFER  ! MARK: RIXS_QTRANSFER
!     **************************************************************************
!     ** CALCULATE Q TRANSFER FOR RIXS MODULE                                 **
!     ** REQUIRES RIXS INITIALIZED AND NOT SELECTED                           **
!     **************************************************************************
! TODO: CHECK SIGN
! TODO: CHECK FUNCTION FOR MORE COMPLEX SYSTEMS
! TODO: CHECK FUNCTION FOR ISHIFT
      USE RIXS_MODULE, ONLY: TINITIALIZE,SELECTED,THIS,NSPEC,TONEK,TTWOK
      IMPLICIT NONE
      INTEGER(4) :: NKPT
      REAL(8), ALLOCATABLE :: XK(:,:)
      REAL(8) :: XCORNER(3)
      REAL(8) :: CORNER(3)
      INTEGER(4) :: ICORNER(3)
      INTEGER(4) :: NKDIV(3)
      REAL(8) :: RBAS(3,3)
      REAL(8) :: XQ1(3)
      REAL(8) :: Q1(3)
      REAL(8) :: QAPPROX(3)
      REAL(8) :: XQAPPROX(3)
      REAL(8) :: DISTANCE
      REAL(8) :: SVAR
      INTEGER(4) :: ISPEC
      INTEGER(4) :: BASE(3)
      INTEGER(4) :: DI,DJ,DK
      LOGICAL(4) :: TMOMENTUM
                          CALL TRACE$PUSH('RIXS_QTRANSFER')
      IF(.NOT.TINITIALIZE) THEN
        CALL ERROR$MSG('RIXS NOT INITIALIZED')
        CALL ERROR$STOP('RIXS_QTRANSFER')
      END IF
      IF(SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('RIXS SPECTRUM ALREADY SELECTED')
        CALL ERROR$STOP('RIXS_QTRANSFER')
      END IF

      CALL XCNTL$GETL4('MOMEMTUMTRANSFER',TMOMENTUM)
      CALL SIMULATION$SELECT('GROUND')
      CALL SIMULATION$GETI4('NKPT',NKPT)
      CALL SIMULATION$GETR8A('RBAS',9,RBAS)
      CALL SIMULATION$GETI4A('NKDIV',3,NKDIV)
      ALLOCATE(XK(3,NKPT))
      CALL SIMULATION$GETR8A('XK',3*NKPT,XK)
      CALL SIMULATION$UNSELECT
      ! WARNING: NOT SURE IF THIS WORKS WITH ISHIFT
      DO ISPEC=1,NSPEC
        CALL RIXS$ISELECT(ISPEC)
        ! GO FROM FIRST K POINT WITH Q TRANSFER (K'=K-Q)
        XQ1(:)=XK(:,1)-THIS%XQ(:)
        ! REAL COORDINATES OF Q1
        CALL XKTOK(XQ1,RBAS,Q1)
        ! CHANGE TO COORDINATES WHERE EACH K-POINT IS ON AN INTEGER GRID
        ! THIS IS DONE BY MULTIPLYING BY THE NUMBER OF K POINTS IN EACH DIRECTION
        XQ1(:)=XQ1(:)*REAL(NKDIV(:),KIND=8)
        ! FIND NEAREST INTEGER K POINT IN RELATIVE COORDINATES MAPPED TO INTEGER GRID
        BASE(:)=NINT(XQ1(:))
        DISTANCE=HUGE(1.D0)
        ! LOOP THROUGH NEIGHBOURING K POINTS AND FIND BEST APPROXIMATION FOR K'
        ! (K'=K-Q) BY MINIMIZING DISTANCE IN REAL COORDINATES
        DO DI=-1,1
          DO DJ=-1,1
            DO DK=-1,1
              ! CALCULATE CORNER K POINT
              ICORNER(:)=BASE(:)+(/DI,DJ,DK/)
              ! TRANSFORM TO RELATIVE COORDINATES
              XCORNER(:)=REAL(ICORNER(:),KIND=8)/REAL(NKDIV(:),KIND=8)
              ! TRANSFORM TO REAL COORDINATES
              CALL XKTOK(XCORNER,RBAS,CORNER)
              ! CALCULATE DISTANCE BETWEEN Q1 AND CORNER K POINT
              SVAR=NORM2(Q1-CORNER)
              IF(SVAR.LT.DISTANCE) THEN
                DISTANCE=SVAR
                QAPPROX(:)=CORNER
              END IF
            ENDDO ! END DK
          ENDDO ! END DJ
        ENDDO ! END DI
        
        ! IF MOMENTUM TRANSFER IS NOT ACTIVE, SET QAPPROX TO ZERO
        IF(.NOT.TMOMENTUM) THEN
          QAPPROX(:)=0.D0
          DISTANCE=NORM2(Q1-QAPPROX)
        END IF

        IF(NORM2(QAPPROX(:))<1.D-10) THEN
          THIS%TKPTSHIFT=.FALSE.
          TONEK=.TRUE. ! FOUND AT LEAST ONE SPECTRUM AT ONE KPT
        ELSE
          THIS%TKPTSHIFT=.TRUE.
          TTWOK=.TRUE. ! FOUND AT LEAST ONE SPECTRUM AT TWO KPTS
        END IF

        ! TRANSFORM TO RELATIVE COORDINATES
        CALL KTOXK(QAPPROX,RBAS,XQAPPROX)
        ! MAKE NUMERICS ACCURATE BY MULTIPLYING BY NUMBER OF K POINTS IN EACH
        ! DIRECTION, FINDING NEAREST INTEGER, AND THEN DIVIDING BY NUMBER OF 
        ! K POINTS IN EACH DIRECTION
        XQAPPROX(:)=XQAPPROX(:)*REAL(NKDIV(:),KIND=8)
        BASE(:)=NINT(XQAPPROX(:))
        XQAPPROX(:)=REAL(BASE(:),KIND=8)/REAL(NKDIV(:),KIND=8)

        ! K'=K-QAPPROX
        ! QAPPROX=K-K'
        THIS%XQAPPROX(:)=XK(:,1)-XQAPPROX(:)
        ! TRANSFORM TO REAL COORDINATES
        CALL XKTOK(THIS%XQAPPROX,RBAS,THIS%QAPPROX)
        ! SAVE DISTANCE AS ERROR
        THIS%QERROR=DISTANCE

        CALL RIXS$UNSELECT
      ENDDO ! END ISPEC
      DEALLOCATE(XK)
                          CALL TRACE$POP
      END SUBROUTINE RIXS_QTRANSFER
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS_SHIFTMAP  ! MARK: RIXS_SHIFTMAP
!     **************************************************************************
!     ** SHIFT MAP FOR RIXS MODULE                                            **
!     ** REQUIRES RIXS INITIALIZED AND NOT SELECTED                           **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: THIS,NSPEC
      IMPLICIT NONE
      INTEGER(4) :: NKPTTOT,NKPT
      INTEGER(4) :: ISPEC
      INTEGER(4) :: I
      INTEGER(4) :: IIRR
      INTEGER(4) :: ISHIFT
      LOGICAL(4) :: TIRR
      REAL(8), ALLOCATABLE :: XK(:,:)
      REAL(8) :: XK1(3)
      REAL(8) :: XQA(3)
      REAL(8) :: XKSHIFT(3)
      REAL(8) :: XKTEST(3)
      INTEGER(4), ALLOCATABLE :: TOIRRKPT(:)
      LOGICAL(4), ALLOCATABLE :: TIRRKPT(:)
      INTEGER(4), ALLOCATABLE :: TOTOTKPT(:)

      CALL SIMULATION$SELECT('GROUND')
      CALL SIMULATION$GETI4('NKPT',NKPT)
      ALLOCATE(XK(3,NKPT))
      CALL SIMULATION$GETR8A('XK',3*NKPT,XK)
      CALL SIMULATION$GETI4('NKPTTOT',NKPTTOT)
      ALLOCATE(TOIRRKPT(NKPTTOT))
      ALLOCATE(TIRRKPT(NKPTTOT))
      ALLOCATE(TOTOTKPT(NKPT))
      CALL SIMULATION$GETI4A('TOIRRKPT',NKPTTOT,TOIRRKPT)
      CALL SIMULATION$GETL4A('TIRRKPT',NKPTTOT,TIRRKPT)
      CALL SIMULATION$GETI4A('TOTOTKPT',NKPT,TOTOTKPT)
      CALL SIMULATION$UNSELECT

      DO ISPEC=1,NSPEC
        CALL RIXS$ISELECT(ISPEC)
        ALLOCATE(THIS%JOFIKPT(NKPTTOT))

        XQA(:)=THIS%XQAPPROX(:)
        ! LOOP THROUGH ALL KPT
        DO I=1,NKPTTOT
          ! GET REL. COORD. OF KPT
          IIRR=TOIRRKPT(I)
          XK1(:)=XK(:,IIRR)
          IF(.NOT.TIRRKPT(I)) THEN
            ! IF KPT IS NOT IRREDUCIBLE, GET -XK
            XK1(:)=-XK1(:)
            ! SHIFT INTO FIRST BRILLOUIN ZONE
            XK1=MODULO(XK1,1.D0)
          END IF
          ! GET SHIFTED KPT
          ! TODO: CHECK SIGN
          XKSHIFT(:)=XK1(:)-XQA(:)
          XKSHIFT(:)=MODULO(XKSHIFT(:),1.D0)
          ! GET INDEX OF IRR. SHIFTED KPT
          CALL BRILLOUIN$IKP(XKSHIFT,ISHIFT)
          ! CHECK IF SHIFTED KPT IS IRREDUCIBLE
          XKTEST(:)=XK(:,ISHIFT)
          IF(NORM2(XKTEST(:)-XKSHIFT(:)).GT.1.D-8) THEN
            XKTEST(:)=-XKTEST(:)
            XKTEST(:)=MODULO(XKTEST(:),1.D0)
            ! IS NOT IRREDUCIBLE
            TIRR=.FALSE.
          ELSE
            ! IS IRREDUCIBLE
            TIRR=.TRUE.
          END IF
          ! TRANSFORM IRR. INDEX AND WETHER IT IS IRREDUCIBLE OR NOT TO TOTAL
          ! KPT INDEX
          ISHIFT=TOTOTKPT(ISHIFT)
          IF(.NOT.TIRR) THEN
            ! IF NOT IRREDUCIBLE, INDEX INCREASE BY ONE
            ISHIFT=ISHIFT+1
          END IF
          ! SAVE INDEX
          THIS%JOFIKPT(I)=ISHIFT
        ENDDO

        CALL RIXS$UNSELECT
      ENDDO
      DEALLOCATE(TOIRRKPT)
      DEALLOCATE(TIRRKPT)
      DEALLOCATE(XK)

      END SUBROUTINE RIXS_SHIFTMAP
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS_ABSORB  ! MARK: RIXS_ABSORB
!     **************************************************************************
!     ** CALCULATE ABSORPTION AMPLITUDES FOR RIXS MODULE                      **
!     ** NOT NECESSARY IF IT HAS BEEN DONE IN XAS MODULE                      **
!     ** REQUIRES RIXS INITIALIZED AND NOT SELECTED                           **
!     **************************************************************************
      USE SHARED_DATA_MODULE, ONLY: ABSORB,ADETPROD
      USE RIXS_MODULE, ONLY: TINITIALIZE,SELECTED,TACTIVE
      IMPLICIT NONE
      LOGICAL(4) :: TXAS
      INTEGER(4) :: NKPT,NSPIN
      INTEGER(4) :: IKPT,ISPIN
      INTEGER(4) :: NTASKS,THISTASK,WTASK
      INTEGER(4) :: NB2,NOCC
      COMPLEX(8), ALLOCATABLE :: DIPOLE(:,:) ! (3,NB2)
      COMPLEX(8), ALLOCATABLE :: KMAT(:,:) ! (NB2-NOCC,NOCC)
      COMPLEX(8) :: AMPL(3)
      INTEGER(4) :: IEMP
      LOGICAL(4) :: SP
      LOGICAL(4) :: TADET
      COMPLEX(8) :: ADET
      COMPLEX(8) :: ADETOP
      INTEGER(4) :: ISPINOP
      INTEGER(4) :: I
      IF(.NOT.TACTIVE) RETURN
                          CALL TRACE$PUSH('RIXS_ABSORB')
      IF(.NOT.TINITIALIZE) THEN
        CALL ERROR$MSG('RIXS NOT INITIALIZED')
        CALL ERROR$STOP('RIXS_ABSORB')
      END IF
      IF(SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('RIXS SPECTRUM ALREADY SELECTED')
        CALL ERROR$STOP('RIXS_ABSORB')
      END IF
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      CALL XAS$GETL4('ACTIVE',TXAS)
      ! IF XAS IS ACTIVE, ABSORB SHOULD BE ALLOCATED, NO NEED TO CALCULATE
      ! IF SINGLEPARTICLE, CALCULATE DETERMINANT INSTEAD
      IF(TXAS) THEN
        CALL XAS$GETL4('SINGLEPARTICLE',SP)
        IF(ALLOCATED(ABSORB).OR.ALLOCATED(ADETPROD)) THEN
          CALL TRACE$PASS('ABSORB OR ADETPROD ALREADY CALCULATED IN XAS')
          IF(SP) THEN
            CALL TRACE$PASS('ABSORB IS SINGLE PARTICLE, CALCULATE DETERMINANT INSTEAD')
            DEALLOCATE(ABSORB)
            DEALLOCATE(ADETPROD)
          ELSE
            CALL TRACE$POP
            RETURN
          END IF
        ELSE
          CALL ERROR$MSG('ABSORB OR ADETPROD NOT CALCULATED IN XAS DESPITE XAS ACTIVE')
          CALL ERROR$STOP('RIXS_ABSORB')
        END IF
      END IF
      ! IF XAS IS NOT ACTIVE, ABSORB SHOULD NOT BE ALLOCATED
      IF(.NOT.TXAS) THEN
        IF(ALLOCATED(ABSORB)) THEN
          CALL ERROR$MSG('SAFEGUARD FUNCTION:')
          CALL ERROR$MSG('ABSORB ALLOCATED BUT XAS NOT ACTIVE')
          CALL ERROR$STOP('RIXS_ABSORB')
        END IF
        IF(ALLOCATED(ADETPROD)) THEN
          CALL ERROR$MSG('SAFEGUARD FUNCTION:')
          CALL ERROR$MSG('ADETPROD ALLOCATED BUT XAS NOT ACTIVE')
          CALL ERROR$STOP('RIXS_ABSORB')
        END IF
      END IF

      CALL XCNTL$GETL4('ADET',TADET)

      ! CALCULATE ABSORB
      CALL SIMULATION$SELECT('GROUND')
      CALL SIMULATION$GETI4('NKPT',NKPT)
      CALL SIMULATION$GETI4('NSPIN',NSPIN)
      CALL SIMULATION$UNSELECT

      ALLOCATE(ABSORB(NKPT,NSPIN))
      ALLOCATE(ADETPROD(NKPT,NSPIN))
      ADETPROD(:,:)=0.D0

      DO IKPT=1,NKPT
        DO ISPIN=1,NSPIN
          CALL KSMAP$WORKTASK(IKPT,ISPIN,WTASK)
          IF(THISTASK.NE.WTASK) CYCLE

          ! NSPIN=1: OPPOSITE SPIN IS THE SAME
          ! NSPIN=2: OPPOSITE SPIN IS DIFFERENT 1->2, 2->1
          ISPINOP=MOD(ISPIN,NSPIN)+1 ! GET OPPOSITE SPIN
          CALL OVERLAP$SELECT(IKPT,ISPINOP)
          ! GET ADET FOR OPPOSITE SPIN
          CALL OVERLAP$GETC8('ADET',ADETOP)
          CALL OVERLAP$UNSELECT

          CALL OVERLAP$SELECT(IKPT,ISPIN)
          CALL OVERLAP$GETC8('ADET',ADET)
          CALL OVERLAP$GETI4('NB2',NB2)
          CALL OVERLAP$GETI4('NOCC',NOCC)
          ALLOCATE(DIPOLE(3,NB2))
          CALL OVERLAP$GETC8A('DIPOLE',3*NB2,DIPOLE)
          ALLOCATE(KMAT(NB2-NOCC,NOCC))
          CALL OVERLAP$K(NB2-NOCC,NOCC,KMAT)
          CALL OVERLAP$UNSELECT
          ALLOCATE(ABSORB(IKPT,ISPIN)%AMPL(3,NB2-NOCC))

          ! 0TH ORDER
          ADETPROD(IKPT,ISPIN)=ADETPROD(IKPT,ISPIN)+ABS(ADET)**2

          DO IEMP=1,NB2-NOCC
            ! 1ST ORDER
            DO I=1,NOCC
              ADETPROD(IKPT,ISPIN)=ADETPROD(IKPT,ISPIN)+ABS(KMAT(IEMP,I))**2*ABS(ADET)**2
            ENDDO ! END I
            CALL AMPLITUDE(NB2,NOCC,IEMP,KMAT,DIPOLE,AMPL,.FALSE.)
            IF(TADET) AMPL=AMPL*CONJG(ADET)*CONJG(ADETOP)
            ABSORB(IKPT,ISPIN)%AMPL(:,IEMP)=AMPL(:)
          ENDDO ! END IEMP
          DEALLOCATE(KMAT)
          DEALLOCATE(DIPOLE)
        ENDDO ! END ISPIN
      ENDDO ! END IKPT
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE RIXS_ABSORB
! !
! !     ...1.........2.........3.........4.........5.........6.........7.........8
!       SUBROUTINE RIXS_ONEKPT  ! MARK: RIXS_ONEKPT
! !     **************************************************************************
! !     ** CALCULATE RIXS SPECTRA AT ONE KPT                                    **
! !     ** REQUIRES RIXS INITIALIZED, UNSELECTED, AND ABSORB CALCULATED         **
! !     **************************************************************************
!       USE RIXS_MODULE, ONLY: TINITIALIZE,SELECTED,THIS,NSPEC,EMIN,EMAX,TONEK
!       USE SHARED_DATA_MODULE, ONLY: ABSORB
!       IMPLICIT NONE
!       COMPLEX(8), PARAMETER :: CI=(0.D0,1.D0)
!       INTEGER(4) :: ISPEC
!       INTEGER(4) :: NKPT,NSPIN,NKPTTOT
!       INTEGER(4) :: IKPT,ISPIN
!       INTEGER(4) :: NTASKS,THISTASK,WTASK
!       INTEGER(4) :: NB1,NB2,NOCC
!       INTEGER(4) :: IOCC
!       INTEGER(4) :: IEMP
!       INTEGER(4) :: IEMPTOT
!       REAL(8), ALLOCATABLE :: EIGGROUND(:)
!       REAL(8), ALLOCATABLE :: EIGEXCITE(:)
!       COMPLEX(8), ALLOCATABLE :: DIPOLE(:,:)
!       REAL(8) :: ELOSS
!       REAL(8) :: EGROUND
!       REAL(8) :: EEXCITE
!       COMPLEX(8), ALLOCATABLE :: L(:,:)
!       COMPLEX(8), ALLOCATABLE :: H(:,:)
!       COMPLEX(8) :: AMPL(3)
!       COMPLEX(8) :: CVAR
!       INTEGER(4) :: IELL
!       INTEGER(4) :: IELLTOT
!       COMPLEX(8) :: DENOMINATOR
!       INTEGER(4) :: NKDIV(3)
!       REAL(8) :: TOTALWKPT
!       LOGICAL(4), ALLOCATABLE :: TINVARR(:)
!       LOGICAL(4) :: TNEGATIVEKPT
!       COMPLEX(8), ALLOCATABLE :: AMPLTOT(:)
!       COMPLEX(8), ALLOCATABLE :: AMPLTOTNEG(:)
!       INTEGER(4) :: IKPTTOT
!       ! SKIP COMPLETELY IF ONLY SPECTRA AT TWO KPTS
!       IF(.NOT.TONEK) RETURN
!                           CALL TRACE$PUSH('RIXS_ONEKPT')
!       IF(.NOT.TINITIALIZE) THEN
!         CALL ERROR$MSG('RIXS NOT INITIALIZED')
!         CALL ERROR$STOP('RIXS_ONEKPT')
!       END IF
!       IF(SELECTED) THEN
!         CALL ERROR$MSG('SAFEGUARD FUNCTION:')
!         CALL ERROR$MSG('RIXS SPECTRUM ALREADY SELECTED')
!         CALL ERROR$STOP('RIXS_ONEKPT')
!       END IF
!       IF(.NOT.ALLOCATED(ABSORB)) THEN
!         CALL ERROR$MSG('RIXS ABSORB NOT CALCULATED')
!         CALL ERROR$STOP('RIXS_ONEKPT')
!       END IF
!       CALL MPE$QUERY('~',NTASKS,THISTASK)

!       ALLOCATE(AMPLTOT(NSPEC))
!       ALLOCATE(AMPLTOTNEG(NSPEC))

!       CALL SIMULATION$SELECT('GROUND')
!       CALL SIMULATION$GETI4('NKPT',NKPT)
!       ALLOCATE(TINVARR(NKPT))
!       CALL SIMULATION$GETL4A('TINVARR',NKPT,TINVARR)
!       CALL SIMULATION$GETI4('NSPIN',NSPIN)
!       CALL SIMULATION$GETR8('ETOT',EGROUND)
!       CALL SIMULATION$GETI4A('NKDIV',3,NKDIV)
!       NKPTTOT=PRODUCT(NKDIV(:))
!       CALL SIMULATION$UNSELECT
!       TOTALWKPT=1.D0/REAL(NKPTTOT,KIND=8)

!       CALL SIMULATION$SELECT('EXCITE')
!       CALL SIMULATION$GETR8('ETOT',EEXCITE)
!       CALL SIMULATION$UNSELECT

!       ! == ALLOCATE STORAGE FOR AMPLITUDES =====================================
!       DO ISPEC=1,NSPEC
!         CALL RIXS$ISELECT(ISPEC)
!         ! ONLY ALLOCATE IF SPECTRUM IS NOT AT TWO KPTS
!         IF(.NOT.THIS%TKPTSHIFT) ALLOCATE(THIS%ONEAMPL(NKPTTOT,NSPIN))
!         CALL RIXS$UNSELECT
!       ENDDO ! END ISPEC

!       IKPTTOT=0
!       DO IKPT=1,NKPT
!         ! COUNT TOTAL K-POINTS UP BY ONE
!         IKPTTOT=IKPTTOT+1
!         ! CHECK IF NEGATIVE K-POINT NEEDS TO BE TREATED
!         TNEGATIVEKPT=.NOT.TINVARR(IKPT)
!         DO ISPIN=1,NSPIN
!           CALL KSMAP$WORKTASK(IKPT,ISPIN,WTASK)
!           IF(THISTASK.NE.WTASK) CYCLE
!           ! GET NB1,NB2,NOCC
!           CALL STATE$SELECT('GROUND')
!           CALL STATE$GETI4('NB',IKPT,ISPIN,NB1)
!           CALL STATE$GETI4('NOCC',IKPT,ISPIN,NOCC)
!           ALLOCATE(EIGGROUND(NB1))
!           CALL STATE$GETR8A('EIG',IKPT,ISPIN,NB1,EIGGROUND)
!           CALL STATE$UNSELECT
!           CALL STATE$SELECT('EXCITE')
!           CALL STATE$GETI4('NB',IKPT,ISPIN,NB2)
!           ALLOCATE(EIGEXCITE(NB2))
!           CALL STATE$GETR8A('EIG',IKPT,ISPIN,NB2,EIGEXCITE)
!           CALL STATE$UNSELECT

!           ! == ALLOCATE INDIVIDUAL AMPLITUDE ARRAYS (ONLY ON RESPONSIBLE TASK)
!           DO ISPEC=1,NSPEC
!             CALL RIXS$ISELECT(ISPEC)
!             ! ONLY ALLOCATE IF SPECTRUM IS NOT AT TWO KPTS
!             IF(.NOT.THIS%TKPTSHIFT) THEN
!               ALLOCATE(THIS%ONEAMPL(IKPTTOT,ISPIN)%XY(NB1-NOCC,NOCC))
!               THIS%ONEAMPL(IKPTTOT,ISPIN)%XY(:,:)=(0.D0,0.D0)
!               ! ALLOCATE NEGATIVE K-POINT AMPLITUDE ARRAY IF REQUIRED
!               IF(TNEGATIVEKPT) THEN
!                 ALLOCATE(THIS%ONEAMPL(IKPTTOT+1,ISPIN)%XY(NB1-NOCC,NOCC))
!                 THIS%ONEAMPL(IKPTTOT+1,ISPIN)%XY(:,:)=(0.D0,0.D0)
!               END IF
!             END IF
!             CALL RIXS$UNSELECT
!           ENDDO ! END ISPEC

!           CALL OVERLAP$SELECT(IKPT,ISPIN)
!           ALLOCATE(DIPOLE(3,NB2))
!           CALL OVERLAP$GETC8A('DIPOLE',3*NB2,DIPOLE)
!           ALLOCATE(H(NOCC,NB1-NOCC))
!           CALL OVERLAP$H(NB1,NOCC,H)
!           ALLOCATE(L(NB2-NOCC,NOCC))

!           ! == LOOP OVER FINAL STATES (X,Y) -> (IEMP,IOCC) =====================
!           DO IOCC=1,NOCC
!             DO IEMP=1,NB1-NOCC
!               IEMPTOT=IEMP+NOCC
!               ! CALCULATE ENERGY LOSS
!               ! LOSS=EFINAL-EGROUND=(EGROUND+EIG(IEMPTOT)-EIG(IOCC))-EGROUND
!               ELOSS=EIGGROUND(IEMPTOT)-EIGGROUND(IOCC)
!               ! SKIP CALCULATION OF FINAL STATE IF ELOSS OUTSIDE SET ENERGY RANGE
!               IF(ELOSS.GT.EMAX.OR.ELOSS.LT.EMIN) CYCLE
!               ! CALCULATE LINEAR DEPENDENCY MATRIX L
!               CALL OVERLAP$L(NB2,NOCC,IOCC,IEMP,L)

!               AMPLTOT(:)=(0.D0,0.D0)
!               AMPLTOTNEG(:)=(0.D0,0.D0)
!               ! == LOOP OVER EMPTY STATES IN INTERMEDIATE STATE ================
!               DO IELL=1,NB2-NOCC
!                 IELLTOT=IELL+NOCC
!                 ! CALCULATE EMISSION AMPLITUDE <PSI_IELL|R|S>
!                 CALL AMPLITUDE(NB2,NOCC,IELL,L,DIPOLE,AMPL)
!                 ! GET <S|R|PSI_IELL>
!                 AMPL(:)=CONJG(AMPL(:))
                
!                 ! == APPLY POLARIZATION VECTORS AND INCIDENT LIGHT ENERGY ======
!                 DO ISPEC=1,NSPEC
!                   CALL RIXS$ISELECT(ISPEC)
!                   ! DO NOT CALCULATE SPECTRUM IF AT TWO KPTS
!                   IF(THIS%TKPTSHIFT) THEN
!                     CALL RIXS$UNSELECT
!                     CYCLE
!                   END IF
!                   ! CALCULATE DENOMINATOR
!                   DENOMINATOR=EEXCITE+EIGEXCITE(IELLTOT)-EGROUND
!                   DENOMINATOR=THIS%ELIGHT-DENOMINATOR+CI*THIS%GAMMA

!                   ! == NORMAL K-POINT ==========================================
!                   ! CALCULATE SPECTRUM AMPLITUDE
!                   ! EPSILON^Q * <PSI_IELL|R|S> (DOT_PRODUCT DOES CONJG)
!                   CVAR=DOT_PRODUCT(CONJG(THIS%POLXYZI),ABSORB(IKPT,ISPIN)%AMPL(:,IELL))
!                   ! CONJG(EPSILON^P) * <S|R|PSI_IELL> (DOT_PRODUCT DOES CONJG)
!                   CVAR=CVAR*DOT_PRODUCT(THIS%POLXYZO,AMPL)
!                   ! DENOMINATOR
!                   CVAR=CVAR/DENOMINATOR
!                   ! SAVE AMPLITUDE BY ADDING UP
!                   AMPLTOT(ISPEC)=AMPLTOT(ISPEC)+CVAR
                  
!                   ! == NEGATIVE K-POINT (IF APPLICABLE) ========================
!                   IF(TNEGATIVEKPT) THEN
!                     ! CALCULATE SPECTRUM AMPLITUDE
!                     CVAR=DOT_PRODUCT(CONJG(THIS%POLXYZI),CONJG(ABSORB(IKPT,ISPIN)%AMPL(:,IELL)))
!                     CVAR=CVAR*DOT_PRODUCT(THIS%POLXYZO,CONJG(AMPL))
!                     CVAR=CVAR/DENOMINATOR
!                     AMPLTOTNEG(ISPEC)=AMPLTOTNEG(ISPEC)+CVAR
!                   END IF
!                   CALL RIXS$UNSELECT
!                 ENDDO ! END ISPEC
!               ENDDO ! END IELL

!               ! MULTIPLY SUMMED AMPLITUDES WITH H MATRIX ELEMENT
!               AMPLTOT(:)=H(IOCC,IEMP)*AMPLTOT(:)
!               IF(TNEGATIVEKPT) AMPLTOTNEG(:)=CONJG(H(IOCC,IEMP))*AMPLTOTNEG(:)
!               ! TODO: CHECK IF WE NEED WKPT HERE IN ANY FORM

!               ! == SAVE AMPLITUDE FOR EACH SPECTRUM ============================
!               DO ISPEC=1,NSPEC
!                 CALL RIXS$ISELECT(ISPEC)
!                 ! ONLY SELECT SPECTRUM IF NOT AT TWO KPTS
!                 IF(.NOT.THIS%TKPTSHIFT) THEN
!                   ! SAVE AMPLITUDE FOR THIS SPECTRUM
!                   THIS%ONEAMPL(IKPTTOT,ISPIN)%XY(IEMP,IOCC)=AMPLTOT(ISPEC)
!                   ! SAVE NEGATIVE K-POINT AMPLITUDE FOR THIS SPECTRUM
!                   IF(TNEGATIVEKPT) THEN
!                     THIS%ONEAMPL(IKPTTOT+1,ISPIN)%XY(IEMP,IOCC)=AMPLTOTNEG(ISPEC)
!                   END IF
!                 END IF
!                 CALL RIXS$UNSELECT
!               ENDDO ! END ISPEC

!             ENDDO ! END IEMP
!           ENDDO ! END IOCC
!           DEALLOCATE(EIGEXCITE)
!           DEALLOCATE(EIGGROUND)
!           DEALLOCATE(L)
!           DEALLOCATE(H)
!           DEALLOCATE(DIPOLE)
!           CALL OVERLAP$UNSELECT
!         ENDDO ! END ISPIN
!         ! == IF NEGATIVE K-POINT WAS TREATED, COUNT UP EXTRA ===================
!         IF(TNEGATIVEKPT) IKPTTOT=IKPTTOT+1
!       ENDDO ! END IKPT
!       DEALLOCATE(TINVARR)
!       DEALLOCATE(AMPLTOT)
!       DEALLOCATE(AMPLTOTNEG)
!                           CALL TRACE$POP
!       RETURN
!       END SUBROUTINE RIXS_ONEKPT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS_ONEKPT  ! MARK: RIXS_ONEKPT
!     **************************************************************************
!     ** CALCULATE RIXS SPECTRA AT ONE KPT                                    **
!     ** REQUIRES RIXS INITIALIZED, UNSELECTED, AND ABSORB CALCULATED         **
!     **************************************************************************
! TODO: CHECK IMPLEMENTATION OF ADET, NORMALIZE, AND BASISWGHT
      USE RIXS_MODULE, ONLY: TINITIALIZE,SELECTED,THIS,NSPEC,EMIN,EMAX,TONEK
      USE SHARED_DATA_MODULE, ONLY: ABSORB,ADETPROD
      IMPLICIT NONE
      COMPLEX(8), PARAMETER :: CI=(0.D0,1.D0)
      INTEGER(4) :: ISPEC
      INTEGER(4) :: NKPT,NSPIN,NKPTTOT
      INTEGER(4) :: IKPT,ISPIN
      INTEGER(4) :: NTASKS,THISTASK,WTASK
      INTEGER(4) :: NB1,NB2,NOCC
      INTEGER(4) :: IOCC
      INTEGER(4) :: IEMP
      INTEGER(4) :: IEMPTOT
      REAL(8), ALLOCATABLE :: EIGGROUND(:)
      REAL(8), ALLOCATABLE :: EIGEXCITE(:)
      COMPLEX(8), ALLOCATABLE :: DIPOLE(:,:)
      REAL(8) :: ELOSS
      REAL(8) :: EGROUND
      REAL(8) :: EEXCITE
      COMPLEX(8), ALLOCATABLE :: L(:,:)
      COMPLEX(8), ALLOCATABLE :: H(:,:)
      COMPLEX(8) :: AMPL(3)
      COMPLEX(8) :: CVAR
      INTEGER(4) :: IELL
      INTEGER(4) :: IELLTOT
      COMPLEX(8) :: DENOMINATOR
      INTEGER(4) :: NKDIV(3)
      REAL(8) :: TOTALWKPT
      INTEGER(4), ALLOCATABLE :: TOIRRKPT(:)
      LOGICAL(4), ALLOCATABLE :: TIRRKPT(:)
      LOGICAL(4) :: TIRR
      LOGICAL(4) :: TNEGATIVEKPT
      COMPLEX(8), ALLOCATABLE :: AMPLTOT(:)
      COMPLEX(8), ALLOCATABLE :: AMPLTOTNEG(:)
      INTEGER(4) :: IKPTTOT
      COMPLEX(8) :: DUMMY(3)
      LOGICAL(4) :: TADET
      LOGICAL(4) :: TBASISWGHT
      LOGICAL(4) :: TNORMALIZE
      COMPLEX(8) :: ADET
      COMPLEX(8) :: ADETOP
      INTEGER(4) :: ISPINOP
      REAL(8) :: ADETSUM
      ! SKIP COMPLETELY IF ONLY SPECTRA AT TWO KPTS
      IF(.NOT.TONEK) RETURN
                          CALL TRACE$PUSH('RIXS_ONEKPT')
      IF(.NOT.TINITIALIZE) THEN
        CALL ERROR$MSG('RIXS NOT INITIALIZED')
        CALL ERROR$STOP('RIXS_ONEKPT')
      END IF
      IF(SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('RIXS SPECTRUM ALREADY SELECTED')
        CALL ERROR$STOP('RIXS_ONEKPT')
      END IF
      IF(.NOT.ALLOCATED(ABSORB)) THEN
        CALL ERROR$MSG('RIXS ABSORB NOT CALCULATED')
        CALL ERROR$STOP('RIXS_ONEKPT')
      END IF
      CALL MPE$QUERY('~',NTASKS,THISTASK)

      CALL XCNTL$GETL4('ADET',TADET)
      CALL XCNTL$GETL4('BASISWGHT',TBASISWGHT)
      CALL XCNTL$GETL4('NORMALIZE',TNORMALIZE)
      CALL OVERLAP$GETR8('ADETSUM',ADETSUM)

      ALLOCATE(AMPLTOT(NSPEC))

      CALL SIMULATION$SELECT('GROUND')
      CALL SIMULATION$GETI4('NKPT',NKPT)
      CALL SIMULATION$GETI4('NKPTTOT',NKPTTOT)
      ALLOCATE(TOIRRKPT(NKPTTOT))
      ALLOCATE(TIRRKPT(NKPTTOT))
      CALL SIMULATION$GETI4A('TOIRRKPT',NKPTTOT,TOIRRKPT)
      CALL SIMULATION$GETL4A('TIRRKPT',NKPTTOT,TIRRKPT)
      CALL SIMULATION$GETI4('NSPIN',NSPIN)
      CALL SIMULATION$GETR8('ETOT',EGROUND)
      CALL SIMULATION$GETI4A('NKDIV',3,NKDIV)
      CALL SIMULATION$UNSELECT
      TOTALWKPT=1.D0/REAL(NKPTTOT,KIND=8)

      CALL SIMULATION$SELECT('EXCITE')
      CALL SIMULATION$GETR8('ETOT',EEXCITE)
      CALL SIMULATION$UNSELECT

      ! == ALLOCATE STORAGE FOR AMPLITUDES =====================================
      DO ISPEC=1,NSPEC
        CALL RIXS$ISELECT(ISPEC)
        ! ONLY ALLOCATE IF SPECTRUM IS NOT AT TWO KPTS
        IF(.NOT.THIS%TKPTSHIFT) ALLOCATE(THIS%ONEAMPL(NKPTTOT,NSPIN))
        CALL RIXS$GETC8A('POLXYZI',3,DUMMY)
        CALL RIXS$GETC8A('POLXYZO',3,DUMMY)
        CALL RIXS$UNSELECT
      ENDDO ! END ISPEC

      DO IKPTTOT=1,NKPTTOT
        ! CHECK IF K-POINT IS IRREDUCIBLE OR NOT
        TIRR=TIRRKPT(IKPTTOT)
        ! GET K-POINT INDEX OF IRREDUCIBLE K-POINT
        IKPT=TOIRRKPT(IKPTTOT)
        DO ISPIN=1,NSPIN
          CALL KSMAP$WORKTASK(IKPT,ISPIN,WTASK)
          IF(THISTASK.NE.WTASK) CYCLE
                          CALL TRACE$I4VAL(' ONEKPT IKPTTOT',IKPTTOT)
                          CALL TRACE$I4VAL(' ONEKPT ISPIN',ISPIN)
          ! GET NB1,NB2,NOCC
          CALL STATE$SELECT('GROUND')
          CALL STATE$GETI4('NB',IKPT,ISPIN,NB1)
          CALL STATE$GETI4('NOCC',IKPT,ISPIN,NOCC)
          ALLOCATE(EIGGROUND(NB1))
          CALL STATE$GETR8A('EIG',IKPT,ISPIN,NB1,EIGGROUND)
          CALL STATE$UNSELECT
          CALL STATE$SELECT('EXCITE')
          CALL STATE$GETI4('NB',IKPT,ISPIN,NB2)
          ALLOCATE(EIGEXCITE(NB2))
          CALL STATE$GETR8A('EIG',IKPT,ISPIN,NB2,EIGEXCITE)
          CALL STATE$UNSELECT

          ! == ALLOCATE INDIVIDUAL AMPLITUDE ARRAYS (ONLY ON RESPONSIBLE TASK)
          DO ISPEC=1,NSPEC
            CALL RIXS$ISELECT(ISPEC)
            ! ONLY ALLOCATE IF SPECTRUM IS NOT AT TWO KPTS
            IF(.NOT.THIS%TKPTSHIFT) THEN
              ALLOCATE(THIS%ONEAMPL(IKPTTOT,ISPIN)%XY(NB1-NOCC,NOCC))
              THIS%ONEAMPL(IKPTTOT,ISPIN)%XY(:,:)=(0.D0,0.D0)
            END IF
            CALL RIXS$UNSELECT
          ENDDO ! END ISPEC

          ! NSPIN=1: OPPOSITE SPIN IS THE SAME
          ! NSPIN=2: OPPOSITE SPIN IS DIFFERENT 1->2, 2->1
          ISPINOP=MOD(ISPIN,NSPIN)+1 ! GET OPPOSITE SPIN
          CALL OVERLAP$SELECT(IKPT,ISPINOP)
          ! GET ADET FOR OPPOSITE SPIN
          CALL OVERLAP$GETC8('ADET',ADETOP)
          CALL OVERLAP$UNSELECT

          CALL OVERLAP$SELECT(IKPT,ISPIN)
          CALL OVERLAP$GETC8('ADET',ADET)
          ALLOCATE(DIPOLE(3,NB2))
          CALL OVERLAP$GETC8A('DIPOLE',3*NB2,DIPOLE)
          ALLOCATE(H(NOCC,NB1-NOCC))
          CALL OVERLAP$H(NB1,NOCC,H)
          ALLOCATE(L(NB2-NOCC,NOCC))

          ! == LOOP OVER FINAL STATES (X,Y) -> (IEMP,IOCC) =====================
          DO IOCC=1,NOCC
                          CALL TRACE$I4VAL(' ONEKPT IOCC',IOCC)
            DO IEMP=1,NB1-NOCC
              IEMPTOT=IEMP+NOCC
              ! CALCULATE ENERGY LOSS
              ! LOSS=EFINAL-EGROUND=(EGROUND+EIG(IEMPTOT)-EIG(IOCC))-EGROUND
              ELOSS=EIGGROUND(IEMPTOT)-EIGGROUND(IOCC)
              ! SKIP CALCULATION OF FINAL STATE IF ELOSS OUTSIDE SET ENERGY RANGE
              IF(ELOSS.GT.EMAX.OR.ELOSS.LT.EMIN) CYCLE
              ! CALCULATE LINEAR DEPENDENCY MATRIX L
              CALL OVERLAP$L(NB2,NOCC,IOCC,IEMP,L)

              AMPLTOT(:)=(0.D0,0.D0)
              ! == LOOP OVER EMPTY STATES IN INTERMEDIATE STATE ================
              DO IELL=1,NB2-NOCC
                IELLTOT=IELL+NOCC
                ! CALCULATE EMISSION AMPLITUDE <PSI_IELL|R|S>
                CALL AMPLITUDE(NB2,NOCC,IELL,L,DIPOLE,AMPL,.FALSE.)
                ! GET <S|R|PSI_IELL>
                AMPL(:)=CONJG(AMPL(:))
                IF(TADET) AMPL(:)=AMPL(:)*ADET*ADETOP
                
                ! == APPLY POLARIZATION VECTORS AND INCIDENT LIGHT ENERGY ======
                DO ISPEC=1,NSPEC
                  CALL RIXS$ISELECT(ISPEC)
                  ! DO NOT CALCULATE SPECTRUM IF AT TWO KPTS
                  IF(THIS%TKPTSHIFT) THEN
                    CALL RIXS$UNSELECT
                    CYCLE
                  END IF
                  ! CALCULATE DENOMINATOR
                  DENOMINATOR=EEXCITE+EIGEXCITE(IELLTOT)-EGROUND
                  DENOMINATOR=THIS%ELIGHT-DENOMINATOR+CI*THIS%GAMMA

                  ! CALCULATE SPECTRUM AMPLITUDE
                  ! IRREDUCIBLE K-POINT
                  IF(TIRR) THEN
                    ! EPSILON^Q * <PSI_IELL|R|S> (DOT_PRODUCT DOES CONJG)
                    CVAR=DOT_PRODUCT(CONJG(THIS%POLXYZI),ABSORB(IKPT,ISPIN)%AMPL(:,IELL))
                    ! CONJG(EPSILON^P) * <S|R|PSI_IELL> (DOT_PRODUCT DOES CONJG)
                    CVAR=CVAR*DOT_PRODUCT(THIS%POLXYZO,AMPL)
                  ! NON-IRREDUCIBLE K-POINT (REQUIRES CONJG)
                  ELSE
                    CVAR=DOT_PRODUCT(CONJG(THIS%POLXYZI),CONJG(ABSORB(IKPT,ISPIN)%AMPL(:,IELL)))
                    CVAR=CVAR*DOT_PRODUCT(THIS%POLXYZO,CONJG(AMPL))
                  END IF
                  ! DENOMINATOR
                  CVAR=CVAR/DENOMINATOR
                  ! SAVE AMPLITUDE BY ADDING UP
                  AMPLTOT(ISPEC)=AMPLTOT(ISPEC)+CVAR
                  CALL RIXS$UNSELECT
                ENDDO ! END ISPEC
              ENDDO ! END IELL

              ! MULTIPLY SUMMED AMPLITUDES WITH H MATRIX ELEMENT
              AMPLTOT(:)=H(IOCC,IEMP)*AMPLTOT(:)
              ! MULTIPLY BY BASIS WEIGHT FOR K POINT
              IF(TBASISWGHT) THEN
                AMPLTOT(:)=AMPLTOT(:)/ADETPROD(IKPT,1)
              END IF
              ! NORMALIZE AMPLITUDE
              IF(TNORMALIZE) THEN
                AMPLTOT(:)=AMPLTOT(:)/ADETSUM
              END IF
              ! TODO: CHECK IF WE NEED WKPT HERE IN ANY FORM
              !       CURRENTLY TREATED IN PAW_RIXSCOMBINE

              ! == SAVE AMPLITUDE FOR EACH SPECTRUM ============================
              DO ISPEC=1,NSPEC
                CALL RIXS$ISELECT(ISPEC)
                ! ONLY SELECT SPECTRUM IF NOT AT TWO KPTS
                IF(.NOT.THIS%TKPTSHIFT) THEN
                  ! SAVE AMPLITUDE FOR THIS SPECTRUM
                  THIS%ONEAMPL(IKPTTOT,ISPIN)%XY(IEMP,IOCC)=AMPLTOT(ISPEC)
                END IF
                CALL RIXS$UNSELECT
              ENDDO ! END ISPEC

            ENDDO ! END IEMP
          ENDDO ! END IOCC
          DEALLOCATE(EIGEXCITE)
          DEALLOCATE(EIGGROUND)
          DEALLOCATE(L)
          DEALLOCATE(H)
          DEALLOCATE(DIPOLE)
          CALL OVERLAP$UNSELECT
        ENDDO ! END ISPIN
      ENDDO ! END IKPT
      DEALLOCATE(AMPLTOT)
      DEALLOCATE(TOIRRKPT)
      DEALLOCATE(TIRRKPT)
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE RIXS_ONEKPT
! !
! !     ...1.........2.........3.........4.........5.........6.........7.........8
!       SUBROUTINE RIXS_TWOKPT  ! MARK: RIXS_TWOKPT
! !     **************************************************************************
! !     ** CALCULATE RIXS SPECTRA AT TWO KPTS                                   **
! !     ** REQUIRES RIXS INITIALIZED, UNSELECTED, AND ABSORB CALCULATED         **
! !     **************************************************************************
!       USE RIXS_MODULE, ONLY: TINITIALIZE,SELECTED,THIS,NSPEC,EMIN,EMAX,TTWOK
!       USE SHARED_DATA_MODULE, ONLY: ABSORB
!       IMPLICIT NONE
!       COMPLEX(8), PARAMETER :: CI=(0.D0,1.D0)
!       INTEGER(4) :: ISPEC
!       INTEGER(4) :: NKPT,NSPIN,NKPTTOT
!       INTEGER(4) :: IKPT,ISPIN
!       INTEGER(4) :: NTASKS,THISTASK,WTASK
!       INTEGER(4) :: NB1,NB2,NOCC
!       INTEGER(4) :: IOCC
!       INTEGER(4) :: IEMP
!       INTEGER(4) :: IEMPTOT
!       REAL(8), ALLOCATABLE :: EIGGROUND(:)
!       REAL(8), ALLOCATABLE :: EIGEXCITE(:)
!       COMPLEX(8), ALLOCATABLE :: DIPOLE(:,:)
!       REAL(8) :: ELOSS
!       REAL(8) :: EGROUND
!       REAL(8) :: EEXCITE
!       COMPLEX(8), ALLOCATABLE :: L(:,:)
!       COMPLEX(8), ALLOCATABLE :: H(:,:)
!       COMPLEX(8) :: AMPL(3)
!       COMPLEX(8) :: CVAR
!       INTEGER(4) :: IELL
!       INTEGER(4) :: IELLTOT
!       COMPLEX(8) :: DENOMINATOR
!       INTEGER(4) :: NKDIV(3)
!       REAL(8) :: TOTALWKPT
!       LOGICAL(4), ALLOCATABLE :: TINVARR(:)
!       LOGICAL(4) :: TNEGATIVEKPT
!       COMPLEX(8), ALLOCATABLE :: AMPLTOT(:)
!       COMPLEX(8), ALLOCATABLE :: AMPLTOTNEG(:)
!       INTEGER(4) :: IKPTTOT
!       ! SKIP COMPLETELY IF ONLY SPECTRA AT ONE KPT
!       IF(.NOT.TTWOK) RETURN
!                           CALL TRACE$PUSH('RIXS_TWOKPT')
!       IF(.NOT.TINITIALIZE) THEN
!         CALL ERROR$MSG('RIXS NOT INITIALIZED')
!         CALL ERROR$STOP('RIXS_TWOKPT')
!       END IF
!       IF(SELECTED) THEN
!         CALL ERROR$MSG('SAFEGUARD FUNCTION:')
!         CALL ERROR$MSG('RIXS SPECTRUM ALREADY SELECTED')
!         CALL ERROR$STOP('RIXS_TWOKPT')
!       END IF
!       IF(.NOT.ALLOCATED(ABSORB)) THEN
!         CALL ERROR$MSG('RIXS ABSORB NOT CALCULATED')
!         CALL ERROR$STOP('RIXS_TWOKPT')
!       END IF
!       CALL MPE$QUERY('~',NTASKS,THISTASK)
!       ALLOCATE(AMPLTOT(NSPEC))
!       ALLOCATE(AMPLTOTNEG(NSPEC))

!       CALL SIMULATION$SELECT('GROUND')
!       CALL SIMULATION$GETI4('NKPT',NKPT)
!       ALLOCATE(TINVARR(NKPT))
!       CALL SIMULATION$GETL4A('TINVARR',NKPT,TINVARR)
!       CALL SIMULATION$GETI4('NSPIN',NSPIN)
!       CALL SIMULATION$GETR8('ETOT',EGROUND)
!       CALL SIMULATION$GETI4A('NKDIV',3,NKDIV)
!       NKPTTOT=PRODUCT(NKDIV(:))
!       CALL SIMULATION$UNSELECT
!       TOTALWKPT=1.D0/REAL(NKPTTOT,KIND=8)

!       CALL SIMULATION$SELECT('EXCITE')
!       CALL SIMULATION$GETR8('ETOT',EEXCITE)
!       CALL SIMULATION$UNSELECT

!       ! == ALLOCATE STORAGE FOR AMPLITUDES =====================================
!       DO ISPEC=1,NSPEC
!         CALL RIXS$ISELECT(ISPEC)
!         ! ONLY ALLOCATE IF SPECTRUM IS AT TWO KPTS
!         IF(THIS%TKPTSHIFT) ALLOCATE(THIS%TWOAMPL(NKPTTOT,NSPIN))
!         CALL RIXS$UNSELECT
!       ENDDO ! END ISPEC

!       IKPTTOT=0
!       DO IKPT=1,NKPT
!         ! COUNT TOTAL K-POINTS UP BY ONE
!         IKPTTOT=IKPTTOT+1
!         ! CHECK IF NEGATIVE K-POINT NEEDS TO BE TREATED
!         TNEGATIVEKPT=.NOT.TINVARR(IKPT)
!         DO ISPIN=1,NSPIN
!           CALL KSMAP$WORKTASK(IKPT,ISPIN,WTASK)
!           IF(THISTASK.NE.WTASK) CYCLE
!           ! GET NB1,NB2,NOCC
!           CALL STATE$SELECT('GROUND')
!           CALL STATE$GETI4('NB',IKPT,ISPIN,NB1)
!           CALL STATE$GETI4('NOCC',IKPT,ISPIN,NOCC)
!           ALLOCATE(EIGGROUND(NB1))
!           CALL STATE$GETR8A('EIG',IKPT,ISPIN,NB1,EIGGROUND)
!           CALL STATE$UNSELECT
!           CALL STATE$SELECT('EXCITE')
!           CALL STATE$GETI4('NB',IKPT,ISPIN,NB2)
!           ALLOCATE(EIGEXCITE(NB2))
!           CALL STATE$GETR8A('EIG',IKPT,ISPIN,NB2,EIGEXCITE)
!           CALL STATE$UNSELECT

!           ! == ALLOCATE INDIVIDUAL AMPLITUDE ARRAYS (ONLY ON RESPONSIBLE TASK)
!           DO ISPEC=1,NSPEC
!             CALL RIXS$ISELECT(ISPEC)
!             ! ONLY ALLOCATE IF SPECTRUM IS AT TWO KPTS
!             IF(THIS%TKPTSHIFT) THEN
!               ALLOCATE(THIS%TWOAMPL(IKPTTOT,ISPIN)%X(NB1-NOCC))
!               ALLOCATE(THIS%TWOAMPL(IKPTTOT,ISPIN)%Y(NOCC))
!               THIS%TWOAMPL(IKPTTOT,ISPIN)%X(:)=(0.D0,0.D0)
!               THIS%TWOAMPL(IKPTTOT,ISPIN)%Y(:)=(0.D0,0.D0)
!               ! ALLOCATE NEGATIVE K-POINT AMPLITUDE ARRAY IF REQUIRED
!               IF(TNEGATIVEKPT) THEN
!                 ALLOCATE(THIS%TWOAMPL(IKPTTOT+1,ISPIN)%X(NB1-NOCC))
!                 ALLOCATE(THIS%TWOAMPL(IKPTTOT+1,ISPIN)%Y(NOCC))
!                 THIS%TWOAMPL(IKPTTOT+1,ISPIN)%X(:)=(0.D0,0.D0)
!                 THIS%TWOAMPL(IKPTTOT+1,ISPIN)%Y(:)=(0.D0,0.D0)
!               END IF
!             END IF
!             CALL RIXS$UNSELECT
!           ENDDO ! END ISPEC

!           ! CONTINUE HERE
!           ! DETERMINE IF IKPTTOT IS POSITIVE OR NEGATIVE K-POINT
!           ! FIND SHIFTED K-POINT
!           ! DETERMINE IF SHIFTED K-POINT IS POSITIVE OR NEGATIVE
!           ! CALCULATE AMPLITUDES

!           DEALLOCATE(EIGGROUND)
!           DEALLOCATE(EIGEXCITE)
!         ENDDO ! END ISPIN
!         IF(TNEGATIVEKPT) IKPTTOT=IKPTTOT+1
!       ENDDO ! END IKPT
!       DEALLOCATE(TINVARR)
!       DEALLOCATE(AMPLTOT)
!       DEALLOCATE(AMPLTOTNEG)
!                           CALL TRACE$POP
!       RETURN
!       END SUBROUTINE RIXS_TWOKPT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS_TWOKPT  ! MARK: RIXS_TWOKPT
!     **************************************************************************
!     ** CALCULATE RIXS SPECTRA AT TWO KPTS                                   **
!     ** REQUIRES RIXS INITIALIZED, UNSELECTED, AND ABSORB CALCULATED         **
!     **************************************************************************
! TODO: CHECK ADET, BASISWGHT, NORMALIZE
      USE RIXS_MODULE, ONLY: TINITIALIZE,SELECTED,THIS,NSPEC,EMIN,EMAX,TTWOK
      USE SHARED_DATA_MODULE, ONLY: ABSORB,ADETPROD
      IMPLICIT NONE
      COMPLEX(8), PARAMETER :: CI=(0.D0,1.D0)
      INTEGER(4) :: ISPEC
      INTEGER(4) :: NKPT,NSPIN,NKPTTOT
      INTEGER(4) :: IKPT,ISPIN
      INTEGER(4) :: NTASKS,THISTASK,WTASK
      INTEGER(4) :: NB1,NB2,NOCC
      INTEGER(4) :: IOCC
      INTEGER(4) :: IEMP
      INTEGER(4) :: IEMPTOT
      REAL(8), ALLOCATABLE :: EIGGROUND(:)
      REAL(8), ALLOCATABLE :: EIGEXCITE(:)
      COMPLEX(8), ALLOCATABLE :: DIPOLE(:,:)
      REAL(8) :: ELOSS
      REAL(8) :: EGROUND
      REAL(8) :: EEXCITE
      COMPLEX(8), ALLOCATABLE :: L(:,:)
      COMPLEX(8), ALLOCATABLE :: H(:,:)
      COMPLEX(8) :: AMPL(3)
      COMPLEX(8) :: CVAR
      INTEGER(4) :: IELL
      INTEGER(4) :: IELLTOT
      COMPLEX(8) :: DENOMINATOR
      REAL(8) :: TOTALWKPT
      INTEGER(4), ALLOCATABLE :: TOIRRKPT(:)
      LOGICAL(4), ALLOCATABLE :: TIRRKPT(:)
      LOGICAL(4) :: TIRR
      COMPLEX(8), ALLOCATABLE :: AMPLTOT(:)
      INTEGER(4) :: IKPTTOT
      INTEGER(4) :: IKPTTOTSHIFT
      COMPLEX(8), ALLOCATABLE :: MU(:,:) ! (NB2-NOCC,NB1-NOCC)
      COMPLEX(8), ALLOCATABLE :: AINV(:,:) ! (NOCC,NOCC)
      COMPLEX(8) :: DUMMY(3)
      LOGICAL(4) :: TADET
      COMPLEX(8) :: ADET
      COMPLEX(8) :: ADETOP
      INTEGER(4) :: ISPINOP
      LOGICAL(4) :: TBASISWGHT
      LOGICAL(4) :: TNORMALIZE
      REAL(8) :: ADETSUM
      ! SKIP COMPLETELY IF ONLY SPECTRA AT ONE KPT
      IF(.NOT.TTWOK) RETURN
                          CALL TRACE$PUSH('RIXS_TWOKPT')
      IF(.NOT.TINITIALIZE) THEN
        CALL ERROR$MSG('RIXS NOT INITIALIZED')
        CALL ERROR$STOP('RIXS_TWOKPT')
      END IF
      IF(SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('RIXS SPECTRUM ALREADY SELECTED')
        CALL ERROR$STOP('RIXS_TWOKPT')
      END IF
      IF(.NOT.ALLOCATED(ABSORB)) THEN
        CALL ERROR$MSG('RIXS ABSORB NOT CALCULATED')
        CALL ERROR$STOP('RIXS_TWOKPT')
      END IF
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      ALLOCATE(AMPLTOT(NSPEC))

      CALL XCNTL$GETL4('ADET',TADET)
      CALL XCNTL$GETL4('BASISWGHT',TBASISWGHT)
      CALL XCNTL$GETL4('NORMALIZE',TNORMALIZE)
      CALL OVERLAP$GETR8('ADETSUM',ADETSUM)


      CALL SIMULATION$SELECT('GROUND')
      CALL SIMULATION$GETI4('NKPT',NKPT)
      CALL SIMULATION$GETI4('NKPTTOT',NKPTTOT)
      ALLOCATE(TOIRRKPT(NKPTTOT))
      ALLOCATE(TIRRKPT(NKPTTOT))
      CALL SIMULATION$GETI4A('TOIRRKPT',NKPTTOT,TOIRRKPT)
      CALL SIMULATION$GETL4A('TIRRKPT',NKPTTOT,TIRRKPT)
      CALL SIMULATION$GETI4('NSPIN',NSPIN)
      CALL SIMULATION$GETR8('ETOT',EGROUND)
      CALL SIMULATION$UNSELECT
      TOTALWKPT=1.D0/REAL(NKPTTOT,KIND=8)

      CALL SIMULATION$SELECT('EXCITE')
      CALL SIMULATION$GETR8('ETOT',EEXCITE)
      CALL SIMULATION$UNSELECT

      ! == ALLOCATE STORAGE FOR AMPLITUDES =====================================
      DO ISPEC=1,NSPEC
        CALL RIXS$ISELECT(ISPEC)
        ! ONLY ALLOCATE IF SPECTRUM IS AT TWO KPTS
        IF(THIS%TKPTSHIFT) ALLOCATE(THIS%TWOAMPL(NKPTTOT,NSPIN))
        CALL RIXS$GETC8A('POLXYZI',3,DUMMY)
        CALL RIXS$GETC8A('POLXYZO',3,DUMMY)
        CALL RIXS$UNSELECT
      ENDDO ! END ISPEC

      DO IKPTTOT=1,NKPTTOT
        ! CHECK IF K-POINT IS IRREDUCIBLE OR NOT
        TIRR=TIRRKPT(IKPTTOT)
        ! GET K-POINT INDEX OF IRREDUCIBLE K-POINT
        IKPT=TOIRRKPT(IKPTTOT)
        DO ISPIN=1,NSPIN
          CALL KSMAP$WORKTASK(IKPT,ISPIN,WTASK)
          IF(THISTASK.NE.WTASK) CYCLE
                          CALL TRACE$I4VAL(' ONEKPT IKPTTOT',IKPTTOT)
                          CALL TRACE$I4VAL(' ONEKPT ISPIN',ISPIN)
          ! GET NB1,NB2,NOCC
          CALL STATE$SELECT('GROUND')
          CALL STATE$GETI4('NB',IKPT,ISPIN,NB1)
          CALL STATE$GETI4('NOCC',IKPT,ISPIN,NOCC)
          ALLOCATE(EIGGROUND(NB1))
          CALL STATE$GETR8A('EIG',IKPT,ISPIN,NB1,EIGGROUND)
          CALL STATE$UNSELECT
          CALL STATE$SELECT('EXCITE')
          CALL STATE$GETI4('NB',IKPT,ISPIN,NB2)
          ALLOCATE(EIGEXCITE(NB2))
          CALL STATE$GETR8A('EIG',IKPT,ISPIN,NB2,EIGEXCITE)
          CALL STATE$UNSELECT
          ! == ALLOCATE INDIVIDUAL AMPLITUDE ARRAYS (ONLY ON RESPONSIBLE TASK)
          DO ISPEC=1,NSPEC
            CALL RIXS$ISELECT(ISPEC)
            ! ONLY ALLOCATE IF SPECTRUM IS AT TWO KPTS
            IF(THIS%TKPTSHIFT) THEN
              ALLOCATE(THIS%TWOAMPL(IKPTTOT,ISPIN)%X(NB1-NOCC))
              ALLOCATE(THIS%TWOAMPL(IKPTTOT,ISPIN)%Y(NOCC))
              THIS%TWOAMPL(IKPTTOT,ISPIN)%X(:)=(0.D0,0.D0)
              THIS%TWOAMPL(IKPTTOT,ISPIN)%Y(:)=(0.D0,0.D0)
            END IF
            CALL RIXS$UNSELECT
          ENDDO ! END ISPEC

          ISPINOP=MOD(ISPIN,NSPIN)+1 ! GET OPPOSITE SPIN
          ! GET ADET FOR OPPOSITE SPIN
          CALL OVERLAP$SELECT(IKPT,ISPINOP)
          CALL OVERLAP$GETC8('ADET',ADETOP)
          CALL OVERLAP$UNSELECT

          CALL OVERLAP$SELECT(IKPT,ISPIN)
          CALL OVERLAP$GETC8('ADET',ADET)
          ALLOCATE(DIPOLE(3,NB2))
          CALL OVERLAP$GETC8A('DIPOLE',3*NB2,DIPOLE)
          ALLOCATE(MU(NB2-NOCC,NB1-NOCC))
          CALL OVERLAP$MU(NB1,NB2,NOCC,MU)
          ! == LOOP OVER EMPTY ORBITALS IN FINAL STATE X =======================
          DO IEMP=1,NB1-NOCC
            IEMPTOT=IEMP+NOCC
            AMPLTOT(:)=(0.D0,0.D0)
            ! == LOOP OVER EMPTY STATES IN INTERMEDIATE STATE ==================
            DO IELL=1,NB2-NOCC
              IELLTOT=IELL+NOCC
              DO ISPEC=1,NSPEC
                CALL RIXS$ISELECT(ISPEC)
                ! DO NOT CALCULATE SPECTRUM IF NOT AT TWO KPTS
                IF(.NOT.THIS%TKPTSHIFT) THEN
                  CALL RIXS$UNSELECT
                  CYCLE
                END IF
                ! CALCULATE DENOMINATOR
                DENOMINATOR=EEXCITE+EIGEXCITE(IELLTOT)-EGROUND
                DENOMINATOR=THIS%ELIGHT-DENOMINATOR+CI*THIS%GAMMA

                ! IRREDUCIBLE K-POINT
                IF(TIRR) THEN
                  ! EPSILON^Q * <PSI_IELL|R|S> (DOT_PRODUCT DOES CONJG)
                  CVAR=DOT_PRODUCT(CONJG(THIS%POLXYZI),ABSORB(IKPT,ISPIN)%AMPL(:,IELL))
                  ! MU(IELL,IEMP) * EPSILON^P * <PSI_IELL|R|S>
                  CVAR=MU(IELL,IEMP)*CVAR
                  ! TODO: CHECK IF WE NEED CONJG HERE
                  ! APPLY ADET
                  IF(TADET) THEN
                    CVAR=CVAR*ADET*ADETOP
                  END IF
                ! NON-IRREDUCIBLE K-POINT (REQUIRES CONJG)
                ELSE
                  CVAR=DOT_PRODUCT(CONJG(THIS%POLXYZI),CONJG(ABSORB(IKPT,ISPIN)%AMPL(:,IELL)))
                  CVAR=CONJG(MU(IELL,IEMP))*CVAR
                  ! APPLY ADET
                  IF(TADET) THEN
                    CVAR=CVAR*CONJG(ADET)*CONJG(ADETOP)
                  END IF
                END IF
                ! DENOMINATOR
                CVAR=CVAR/DENOMINATOR
                ! SAVE AMPLITUDE BY ADDING UP
                AMPLTOT(ISPEC)=AMPLTOT(ISPEC)+CVAR
                CALL RIXS$UNSELECT
              ENDDO ! END ISPEC
            ENDDO ! END IELL

            ! TODO: CHECK IF WE NEED WKPT HERE IN ANY FORM
            !       CURRENTLY TREATED IN PAW_RIXSCOMBINE

            ! == SAVE AMPLITUDE FOR EACH SPECTRUM ==============================
            DO ISPEC=1,NSPEC
              CALL RIXS$ISELECT(ISPEC)
              ! ONLY SELECT SPECTRUM IF AT TWO KPTS
              IF(THIS%TKPTSHIFT) THEN
                ! MULTIPLY BASIS WEIGHT FOR K POINT
                IF(TBASISWGHT) THEN
                  AMPLTOT(ISPEC)=AMPLTOT(ISPEC)/ADETPROD(IKPT,1)
                END IF
                ! NORMALIZE AMPLITUDE
                IF(TNORMALIZE) THEN
                  AMPLTOT(ISPEC)=AMPLTOT(ISPEC)/ADETSUM
                END IF
                ! SAVE AMPLITUDE FOR THIS SPECTRUM
                THIS%TWOAMPL(IKPTTOT,ISPIN)%X(IEMP)=AMPLTOT(ISPEC)
              END IF
              CALL RIXS$UNSELECT
            ENDDO ! END ISPEC
          ENDDO ! END IEMP

          ALLOCATE(AINV(NOCC,NOCC))
          CALL OVERLAP$GETC8A('AINV',NOCC*NOCC,AINV)

          ! == LOOP OVER OCCUPIED ORBITALS IN FINAL STATE Y ====================
          DO IOCC=1,NOCC
            AMPLTOT(:)=(0.D0,0.D0)
            AMPL(:)=(0.D0,0.D0)

            DO IELL=1,NOCC
              ! TODO: CHECK INDEX OF AINV
              ! TODO: CHECK IF DIPOLE/ADET IS CONJG
              AMPL(:)=AMPL(:)+CONJG(DIPOLE(:,IELL))*AINV(IOCC,IELL)
            ENDDO
            IF(TADET) THEN
              AMPL(:)=AMPL(:)*ADET*ADETOP
            END IF
            DO ISPEC=1,NSPEC
              CALL RIXS$ISELECT(ISPEC)
              ! DO NOT CALCULATE SPECTRUM IF NOT AT TWO KPTS
              IF(.NOT.THIS%TKPTSHIFT) THEN
                CALL RIXS$UNSELECT
                CYCLE
              END IF
              ! IRREDUCIBLE K-POINT
              IF(TIRR) THEN
                ! (EPSILON^P)^* * AMPL (DOT_PRODUCT DOES CONJG)
                CVAR=DOT_PRODUCT(THIS%POLXYZO,AMPL)
                IF(TADET) THEN
                  ! APPLY ADET
                  CVAR=CVAR*CONJG(ADET)*CONJG(ADETOP)
                END IF
              ! NON-IRREDUCIBLE K-POINT (REQUIRES CONJG)
              ELSE
                ! (EPSILON^P)^* * CONJG(AMPL) (DOT_PRODUCT DOES CONJG)
                CVAR=DOT_PRODUCT(THIS%POLXYZO,CONJG(AMPL))
                IF(TADET) THEN
                  ! APPLY ADET
                  CVAR=CVAR*ADET*ADETOP
                END IF
              END IF
              ! MULTIPLY BY BASIS WEIGHT FOR K POINT
              IF(TBASISWGHT) THEN
                CVAR=CVAR/ADETPROD(IKPT,1)
              END IF
              ! NORMALIZE AMPLITUDE
              IF(TNORMALIZE) THEN
                CVAR=CVAR/ADETSUM
              END IF
              ! SAVE AMPLITUDE
              THIS%TWOAMPL(IKPTTOT,ISPIN)%Y(IOCC)=CVAR
              CALL RIXS$UNSELECT
            ENDDO ! END ISPEC
          ENDDO ! END IOCC
          DEALLOCATE(EIGGROUND)
          DEALLOCATE(EIGEXCITE)
          DEALLOCATE(DIPOLE)
          DEALLOCATE(MU)
          DEALLOCATE(AINV)
          CALL OVERLAP$UNSELECT
        ENDDO ! END ISPIN
      ENDDO ! END IKPT
      DEALLOCATE(AMPLTOT)
      DEALLOCATE(TOIRRKPT)
      DEALLOCATE(TIRRKPT)
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE RIXS_TWOKPT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS_OUTPUTHEADER(NFIL)  ! MARK: RIXS_OUTPUTHEADER
!     **************************************************************************
!     ** OUTPUT HEADER FOR RIXS MODULE                                        **
!     ** REQUIRES RIXS SELECTED                                               **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: TINITIALIZE,SELECTED,THIS,EMIN,EMAX
      USE STRINGS_MODULE
      USE CLOCK_MODULE
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: NFIL
      INTEGER(4) :: NKPT,NSPIN,NKPTTOT
      INTEGER(4) :: IKPT,IKPTTOT
      INTEGER(4) :: NKDIV(3)
      INTEGER(4), ALLOCATABLE :: TOIRRKPT(:)
      LOGICAL(4), ALLOCATABLE :: TIRRKPT(:)
      INTEGER(4), ALLOCATABLE :: IARR(:)
      INTEGER(4) :: NAT
      REAL(8), ALLOCATABLE :: R(:,:)
      INTEGER(4) :: IATOM
      REAL(8) :: RHOLE(3)
      INTEGER(4) :: ILOGICAL
      CHARACTER(6) :: FLAG
      INTEGER(4) :: NTASKS,THISTASK,RTASK

      CHARACTER(32) :: DATETIME
      CHARACTER(512) :: RELEASE=''
      CHARACTER(512) :: REMOTE='UNKNOWN'
      CHARACTER(512) :: HASH='UNKNOWN'
      CHARACTER(512) :: BRANCH='UNKNOWN'
      CHARACTER(512) :: SHORTREVISIONNUMBER='UNKNOWN'
      CHARACTER(512) :: AUTHOR='UNKNOWN'
      CHARACTER(512) :: COMMITDATE='UNKNOWN'
      CHARACTER(512) :: COMPILEDATE='UNKNOWN'
      CHARACTER(512) :: COMPILEPERSON='UNKNOWN'
      INTEGER(4)     :: NUMCHANGES=0
      LOGICAL(4) :: TADET
      LOGICAL(4) :: TBASISWGHT
      LOGICAL(4) :: TNORMALIZE
      LOGICAL(4) :: TMOMENTUM
      INCLUDE 'CPPAW_VERSION.INFO' ! FILENAME MADE LOWERCASE BY F90PP.SED

      CALL MPE$QUERY('~',NTASKS,THISTASK)
      CALL KSMAP$READTASK(RTASK)
      IF(THISTASK.NE.RTASK) RETURN
                          CALL TRACE$PUSH('RIXS_OUTPUTHEADER')
      IF(.NOT.TINITIALIZE) THEN
        CALL ERROR$MSG('RIXS NOT INITIALIZED')
        CALL ERROR$STOP('RIXS_OUTPUTHEADER')
      END IF
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('RIXS SPECTRUM NOT SELECTED')
        CALL ERROR$STOP('RIXS_OUTPUTHEADER')
      END IF
      CALL XCNTL$GETL4('ADET',TADET)
      CALL XCNTL$GETL4('BASISWGHT',TBASISWGHT)
      CALL XCNTL$GETL4('NORMALIZE',TNORMALIZE)
      CALL XCNTL$GETL4('MOMENTUMTRANSFER',TMOMENTUM)
      ! == RUN INFORMATION =====================================================
      CALL CLOCK$NOW(DATETIME)
      ! DATETIME,HASH,BRANCH,REMOTE,NUMCHANGES
      WRITE(NFIL)DATETIME,HASH,BRANCH,REMOTE,NUMCHANGES

      ! == SIMULATION SETTINGS =================================================
      ! MOMENTUMTRANSFER
      ILOGICAL=0
      IF(TMOMENTUM) ILOGICAL=1
      WRITE(NFIL)ILOGICAL
      ! ADET
      ILOGICAL=0
      IF(TADET) ILOGICAL=1
      WRITE(NFIL)ILOGICAL
      ! NORMALIZE
      ILOGICAL=0
      IF(TNORMALIZE) ILOGICAL=1
      WRITE(NFIL)ILOGICAL
      ! BASISWGHT
      ILOGICAL=0
      IF(TBASISWGHT) ILOGICAL=1
      WRITE(NFIL)ILOGICAL

      CALL SIMULATION$SELECT('GROUND')
      CALL SIMULATION$GETI4('NKPT',NKPT)
      CALL SIMULATION$GETI4('NKPTTOT',NKPTTOT)
      ALLOCATE(TOIRRKPT(NKPTTOT))
      ALLOCATE(TIRRKPT(NKPTTOT))
      ALLOCATE(IARR(NKPTTOT))
      CALL SIMULATION$GETI4A('TOIRRKPT',NKPTTOT,TOIRRKPT)
      CALL SIMULATION$GETL4A('TIRRKPT',NKPTTOT,TIRRKPT)
      CALL SIMULATION$GETI4('NSPIN',NSPIN)
      CALL SIMULATION$GETI4('NAT',NAT)
      CALL SIMULATION$GETI4A('NKDIV',3,NKDIV)

      DO IKPTTOT=1,NKPTTOT
        IARR(IKPTTOT)=0
        IF(TIRRKPT(IKPTTOT)) IARR(IKPTTOT)=1
      ENDDO
      DEALLOCATE(TIRRKPT)
      ALLOCATE(R(3,NAT))
      CALL SIMULATION$GETR8A('R',3*NAT,R)
      CALL SETTINGS$GETI4('IATOM',IATOM)
      RHOLE(:)=R(:,IATOM)
      DEALLOCATE(R)
      CALL SIMULATION$UNSELECT

      ! NKPT,NKPTTOT,NSPIN,NKDIV,RHOLE
      WRITE(NFIL)NKPT,NKPTTOT,NSPIN,NKDIV,RHOLE
      ! TOIRRKPT,TIRRKPT(IINVARR),JOFIKPT
      WRITE(NFIL)TOIRRKPT,IARR,THIS%JOFIKPT
      DEALLOCATE(IARR)

      ! == RIXS SETTINGS =======================================================
      ! DETERMINE WHAT KIND OF RIXS AMPLITUDE FILE IS WRITTEN
      IF(THIS%TKPTSHIFT) THEN
        ILOGICAL=1
        FLAG=+'TWOKPT'
      ELSE
        ILOGICAL=0
        FLAG=+'ONEKPT'
      END IF
      ! WRITE FLAG,EMIN,EMAX,ELIGHT,NORMAL,KDIRI,POLI,POLXYZI,KI,XKI,KDIRO,POLO,POLXYZO
      !       KO,XKO,Q,XQ,QAPPROX,XQAPPROX,QERROR,TKPTSHIFT
      WRITE(NFIL)FLAG,EMIN,EMAX,THIS%ELIGHT,THIS%NORMAL, &
     &           THIS%KDIRI,THIS%POLI,THIS%POLXYZI,THIS%KI,THIS%XKI, &
     &           THIS%KDIRO,THIS%POLO,THIS%POLXYZO,THIS%KO,THIS%XKO, &
     &           THIS%Q,THIS%XQ,THIS%QAPPROX,THIS%XQAPPROX,THIS%QERROR,ILOGICAL
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE RIXS_OUTPUTHEADER
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS_OUTPUTDATA(NFIL)  ! MARK: RIXS_OUTPUTDATA
!     **************************************************************************
!     ** OUTPUT RIXS AMPLITUDES                                               **
!     ** REQUIRES RIXS INITIALIZED, SELECTED                                  **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: TINITIALIZE,SELECTED,THIS
      USE MPE_MODULE
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: NFIL
      INTEGER(4) :: NTASKS,THISTASK,WTASK,RTASK
      INTEGER(4) :: NKPT,NSPIN,NKPTTOT
      INTEGER(4) :: NKDIV(3)
      INTEGER(4) :: IKPT,ISPIN
      INTEGER(4) :: IKPTTOT
      LOGICAL(4) :: TNEGATIVEKPT
      INTEGER(4) :: NB1,NOCC
      INTEGER(4), ALLOCATABLE :: TOIRRKPT(:)
      LOGICAL(4), ALLOCATABLE :: TIRRKPT(:)
      INTEGER(4) :: TIRR
      REAL(8), ALLOCATABLE :: EIG(:)
      COMPLEX(8), ALLOCATABLE :: XY(:,:)
      COMPLEX(8), ALLOCATABLE :: X(:)
      COMPLEX(8), ALLOCATABLE :: Y(:)
      IF(.NOT.TINITIALIZE) THEN
        CALL ERROR$MSG('RIXS NOT INITIALIZED')
        CALL ERROR$STOP('RIXS_OUTPUTDATA')
      END IF
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('RIXS SPECTRUM NOT SELECTED')
        CALL ERROR$STOP('RIXS_OUTPUTDATA')
      END IF
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      CALL KSMAP$READTASK(RTASK)

      CALL SIMULATION$SELECT('GROUND')
      CALL SIMULATION$GETI4('NKPT',NKPT)
      CALL SIMULATION$GETI4('NSPIN',NSPIN)
      CALL SIMULATION$GETI4('NKPTTOT',NKPTTOT)
      ALLOCATE(TOIRRKPT(NKPTTOT))
      ALLOCATE(TIRRKPT(NKPTTOT))
      CALL SIMULATION$GETI4A('TOIRRKPT',NKPTTOT,TOIRRKPT)
      CALL SIMULATION$GETL4A('TIRRKPT',NKPTTOT,TIRRKPT)
      CALL SIMULATION$UNSELECT

      IF(THISTASK.EQ.RTASK) THEN
        ! NKPTTOT
        WRITE(NFIL)NKPTTOT
      END IF
      


      DO IKPTTOT=1,NKPTTOT
        ! GET K-POINT INDEX OF IRREDUCIBLE K-POINT
        IKPT=TOIRRKPT(IKPTTOT)
        ! CHECK IF K-POINT IS IRREDUCIBLE OR NOT
        TIRR=TIRRKPT(IKPTTOT)
        DO ISPIN=1,NSPIN
          CALL KSMAP$WORKTASK(IKPT,ISPIN,WTASK)
          IF(THISTASK.NE.WTASK.AND.THISTASK.NE.RTASK) CYCLE
          ! GET NB1,NOCC
          CALL STATE$SELECT('GROUND')
          CALL STATE$GETI4('NB',IKPT,ISPIN,NB1)
          CALL STATE$GETI4('NOCC',IKPT,ISPIN,NOCC)
          IF(THISTASK.EQ.RTASK) THEN
            ALLOCATE(EIG(NB1))
            CALL STATE$GETR8A('EIG',IKPT,ISPIN,NB1,EIG)
          END IF
          CALL STATE$UNSELECT

          IF(THISTASK.EQ.RTASK) THEN
            ! IKPTTOT,ISPIN,NB1,NOCC
            WRITE(NFIL)IKPTTOT,ISPIN,NB1,NOCC
            ! EIG(NB1)
            WRITE(NFIL)EIG
          END IF

          ! == OUTPUT AMPLITUDES FOR TWO KPT SPECTRUM ==========================
          IF(THIS%TKPTSHIFT) THEN
            ALLOCATE(X(NB1-NOCC))
            ALLOCATE(Y(NOCC))
            IF(THISTASK.EQ.WTASK) THEN
              X=THIS%TWOAMPL(IKPTTOT,ISPIN)%X
              Y=THIS%TWOAMPL(IKPTTOT,ISPIN)%Y
            END IF
            CALL MPE$SENDRECEIVE('~',WTASK,RTASK,X)
            CALL MPE$SENDRECEIVE('~',WTASK,RTASK,Y)
            IF(THISTASK.EQ.RTASK) THEN
              ! THIS%TWOAMPL(IKPTTOT,ISPIN)%X(NB1-NOCC)
              WRITE(NFIL) X
              ! THIS%TWOAMPL(IKPTTOT,ISPIN)%Y(NOCC)
              WRITE(NFIL) Y
            END IF
            DEALLOCATE(X)
            DEALLOCATE(Y)
          ELSE
            ! == OUTPUT AMPLITUDES FOR ONEKPT SPECTRUM =========================
            ALLOCATE(XY(NB1-NOCC,NOCC))
            IF(THISTASK.EQ.WTASK) XY=THIS%ONEAMPL(IKPTTOT,ISPIN)%XY
            CALL MPE$SENDRECEIVE('~',WTASK,RTASK,XY)
            IF(THISTASK.EQ.RTASK) THEN
              ! THIS%ONEAMPL(IKPTTOT,ISPIN)%XY(NB1-NOCC,NOCC)
              WRITE(NFIL) XY
            END IF
            DEALLOCATE(XY)
          END IF
          IF(THISTASK.EQ.RTASK) DEALLOCATE(EIG)
        ENDDO ! END ISPIN
      ENDDO ! END IKPT
      DEALLOCATE(TOIRRKPT)
      DEALLOCATE(TIRRKPT)
      RETURN
      END SUBROUTINE RIXS_OUTPUTDATA 
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS$ISELECT(ISPEC)  ! MARK: RIXS$ISELECT
!     **************************************************************************
!     ** SELECT SPECTRUM FOR RIXS MODULE                                      **
!     ** REQUIRES RIXS INITIALIZED                                            **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: TINITIALIZE,NSPEC,SELECTED,SPECTRA,THIS
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: ISPEC
      IF(.NOT.TINITIALIZE) THEN
        CALL ERROR$MSG('RIXS NOT INITIALIZED')
        CALL ERROR$STOP('RIXS$ISELECT')
      END IF
      IF(SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('RIXS SPECTRUM ALREADY SELECTED')
        CALL ERROR$STOP('RIXS$ISELECT')
      END IF
      IF(ISPEC.LE.0.OR.ISPEC.GT.NSPEC) THEN
        CALL ERROR$MSG('INVALID SPECTRUM INDEX')
        CALL ERROR$I4VAL('SPECTRUM INDEX: ',ISPEC)
        CALL ERROR$STOP('RIXS$ISELECT')
      END IF
      THIS=>SPECTRA(ISPEC)
      SELECTED=.TRUE.
      RETURN
      END SUBROUTINE RIXS$ISELECT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS$UNSELECT  ! MARK: RIXS$UNSELECT
!     **************************************************************************
!     ** UNSELECT SPECTRUM FOR RIXS MODULE                                    **
!     ** REQUIRES RIXS INITIALIZED AND SELECTED                               **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: TINITIALIZE,SELECTED,THIS
      IMPLICIT NONE
      IF(.NOT.TINITIALIZE) THEN
        CALL ERROR$MSG('RIXS NOT INITIALIZED')
        CALL ERROR$STOP('RIXS$UNSELECT')
      END IF
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('CANNOT UNSELECT SPECTRUM IF NONE SELECTED')
        CALL ERROR$STOP('RIXS$UNSELECT')
      END IF
      NULLIFY(THIS)
      SELECTED=.FALSE.
      RETURN
      END SUBROUTINE RIXS$UNSELECT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS$GETL4(ID,VAL)  ! MARK: RIXS$GETL4
!     **************************************************************************
!     ** GET LOGICAL FROM RIXS MODULE                                        **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: TACTIVE,TINITIALIZE,SELECTED,THIS
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      LOGICAL(4), INTENT(OUT) :: VAL
      IF(ID.EQ.'INITIALIZE') THEN
        VAL=TINITIALIZE
      ELSE IF(ID.EQ.'ACTIVE') THEN
        VAL=TACTIVE
      ELSE IF(ID.EQ.'TPOLXYZI') THEN
        IF(.NOT.TINITIALIZE) THEN
          CALL ERROR$MSG('XAS NOT INITIALIZED')
          CALL ERROR$STOP('XAS$GETL4')
        END IF
        IF(.NOT.SELECTED) THEN
          CALL ERROR$MSG('XAS SPECTRUM NOT SELECTED')
          CALL ERROR$STOP('XAS$GETL4')
        END IF
        VAL=THIS%TPOLXYZI
      ELSE IF(ID.EQ.'TPOLXYZO') THEN
        IF(.NOT.TINITIALIZE) THEN
          CALL ERROR$MSG('XAS NOT INITIALIZED')
          CALL ERROR$STOP('XAS$GETL4')
        END IF
        IF(.NOT.SELECTED) THEN
          CALL ERROR$MSG('XAS SPECTRUM NOT SELECTED')
          CALL ERROR$STOP('XAS$GETL4')
        END IF
        VAL=THIS%TPOLXYZO
      ELSE
        CALL ERROR$MSG('RIXS GETL4 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('RIXS$GETL4')
      END IF
      RETURN
      END SUBROUTINE RIXS$GETL4
! !
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS$SETL4(ID,VAL)  ! MARK: RIXS$SETL4
!     **************************************************************************
!     ** SET LOGICAL IN RIXS MODULE                                          **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: TACTIVE,TINITIALIZE,SELECTED,THIS
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      LOGICAL(4), INTENT(IN) :: VAL
      IF(ID.EQ.'ACTIVE') THEN
        TACTIVE=VAL
      ELSE IF(ID.EQ.'INITIALIZE') THEN
        TINITIALIZE=VAL
      ELSE IF(ID.EQ.'TPOLXYZI') THEN
        IF(.NOT.SELECTED) THEN
          CALL ERROR$MSG('RIXS SPECTRUM NOT SELECTED')
          CALL ERROR$STOP('RIXS$SETL4')
        END IF
        THIS%TPOLXYZI=VAL
      ELSE IF(ID.EQ.'TPOLXYZO') THEN
        IF(.NOT.SELECTED) THEN
          CALL ERROR$MSG('RIXS SPECTRUM NOT SELECTED')
          CALL ERROR$STOP('RIXS$SETL4')
        END IF
        THIS%TPOLXYZO=VAL
      ELSE
        CALL ERROR$MSG('RIXS SETL4 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('RIXS$SETL4')
      END IF
      RETURN
      END SUBROUTINE RIXS$SETL4
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS$GETI4(ID,VAL)  ! MARK: RIXS$GETI4
!     **************************************************************************
!     ** GET INTEGER FROM RIXS MODULE                                       **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: NSPEC,TINITIALIZE
      IMPLICIT NONE
      ! NE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(OUT) :: VAL
      IF(.NOT.TINITIALIZE) THEN
        CALL ERROR$MSG('RIXS NOT INITIALIZED')
        CALL ERROR$STOP('RIXS$GETI4')
      END IF
      IF(ID.EQ.'NSPEC') THEN
        VAL=NSPEC
      ELSE
        CALL ERROR$MSG('RIXS GETI4 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('RIXS$GETI4')
      END IF
      RETURN
      END SUBROUTINE RIXS$GETI4
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS$SETI4(ID,VAL)  ! MARK: RIXS$SETI4
!     **************************************************************************
!     ** SET INTEGER IN RIXS MODULE                                         **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: NSPEC,SPECTRA
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: VAL
      IF(ID.EQ.'NSPEC') THEN
        NSPEC=VAL
        IF(.NOT.ALLOCATED(SPECTRA)) THEN
          ALLOCATE(SPECTRA(NSPEC))
        ELSE
          CALL ERROR$MSG('RIXS SETI4 NSPEC ALREADY ALLOCATED')
          CALL ERROR$I4VAL('OLD NSPEC: ',SIZE(SPECTRA))
          CALL ERROR$I4VAL('NEW NSPEC: ',VAL)
          CALL ERROR$STOP('RIXS$SETI4')
        END IF
      ELSE
        CALL ERROR$MSG('RIXS SETI4 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('RIXS$SETI4')
      END IF
      RETURN
      END SUBROUTINE RIXS$SETI4
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS$GETR8(ID,VAL)  ! MARK: RIXS$GETR8
!     **************************************************************************
!     ** GET REAL FROM RIXS MODULE                                           **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: EMIN,EMAX,TINITIALIZE,SELECTED,THIS
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      REAL(8), INTENT(OUT) :: VAL
      IF(.NOT.TINITIALIZE) THEN
        CALL ERROR$MSG('RIXS NOT INITIALIZED')
        CALL ERROR$STOP('RIXS$GETR8')
      END IF
      IF(ID.EQ.'EMIN') THEN
        VAL=EMIN
      ELSE IF(ID.EQ.'EMAX') THEN
        VAL=EMAX
      ELSE IF(ID.EQ.'GAMMA') THEN
        IF(.NOT.SELECTED) THEN
          CALL ERROR$MSG('RIXS SPECTRUM NOT SELECTED')
          CALL ERROR$STOP('RIXS$GETR8')
        END IF
        VAL=THIS%GAMMA
      ELSE IF(ID.EQ.'ELIGHT') THEN
        IF(.NOT.SELECTED) THEN
          CALL ERROR$MSG('RIXS SPECTRUM NOT SELECTED')
          CALL ERROR$STOP('RIXS$GETR8')
        END IF
        VAL=THIS%ELIGHT
      ELSE
        CALL ERROR$MSG('RIXS GETR8 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('RIXS$GETR8')
      END IF
      RETURN
      END SUBROUTINE RIXS$GETR8
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS$SETR8(ID,VAL)  ! MARK: RIXS$SETR8
!     **************************************************************************
!     ** SET REAL IN RIXS MODULE                                              **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: EMIN,EMAX,SELECTED,THIS
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      REAL(8), INTENT(IN) :: VAL
      IF(ID.EQ.'EMIN') THEN
        EMIN=VAL
      ELSE IF(ID.EQ.'EMAX') THEN
        EMAX=VAL
      ELSE IF(ID.EQ.'ELIGHT') THEN
        IF(.NOT.SELECTED) THEN
          CALL ERROR$MSG('RIXS SPECTRUM NOT SELECTED')
          CALL ERROR$STOP('RIXS$SETR8')
        END IF
        THIS%ELIGHT=VAL
      ELSE IF(ID.EQ.'GAMMA') THEN
        IF(.NOT.SELECTED) THEN
          CALL ERROR$MSG('RIXS SPECTRUM NOT SELECTED')
          CALL ERROR$STOP('RIXS$SETR8')
        END IF
        THIS%GAMMA=VAL
      ELSE
        CALL ERROR$MSG('RIXS SETR8 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('RIXS$SETR8')
      END IF
      RETURN
      END SUBROUTINE RIXS$SETR8
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS$GETCH(ID,VAL)  ! MARK: RIXS$GETCH
!     **************************************************************************
!     ** GET CHARACTER FROM RIXS MODULE                                       **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: TINITIALIZE,SELECTED,THIS
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      CHARACTER(*), INTENT(OUT) :: VAL
      IF(.NOT.TINITIALIZE) THEN
        CALL ERROR$MSG('RIXS NOT INITIALIZED')
        CALL ERROR$STOP('RIXS$GETCH')
      END IF
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('RIXS SPECTRUM NOT SELECTED')
        CALL ERROR$STOP('RIXS$GETCH')
      END IF
      IF(ID.EQ.'FILE') THEN
        VAL=THIS%FILE
      ELSE
        CALL ERROR$MSG('RIXS GETCH ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('RIXS$GETCH')
      END IF
      RETURN
      END SUBROUTINE RIXS$GETCH
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS$SETCH(ID,VAL)  ! MARK: RIXS$SETCH
!     **************************************************************************
!     ** SET CHARACTER IN RIXS MODULE                                         **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: SELECTED,THIS
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      CHARACTER(*), INTENT(IN) :: VAL
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('RIXS SPECTRUM NOT SELECTED')
        CALL ERROR$STOP('RIXS$SETCH')
      END IF
      IF(ID.EQ.'FILE') THEN
        THIS%FILE=VAL
      ELSE
        CALL ERROR$MSG('RIXS SETCH ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('RIXS$SETCH')
      END IF
      RETURN
      END SUBROUTINE RIXS$SETCH
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS$GETR8A(ID,LEN,VAL)  ! MARK: RIXS$GETR8A
!     **************************************************************************
!     ** GET REAL ARRAY FROM RIXS MODULE                                      **
!     ** REQUIRES RIXS INITIALIZED AND SELECTED                               **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: SELECTED,THIS,TINITIALIZE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: LEN
      REAL(8), INTENT(OUT) :: VAL(LEN)
      IF(.NOT.TINITIALIZE) THEN
        CALL ERROR$MSG('RIXS NOT INITIALIZED')
        CALL ERROR$STOP('RIXS$GETR8A')
      END IF
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('RIXS SPECTRUM NOT SELECTED')
        CALL ERROR$STOP('RIXS$GETR8A')
      END IF
      IF(ID.EQ.'NORMAL') THEN
        IF(LEN.NE.3) THEN
          CALL ERROR$MSG('RIXS GETR8A NORMAL LEN NOT 3')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$STOP('RIXS$GETR8A')
        END IF
        VAL(:)=THIS%NORMAL(:)
      ELSE IF(ID.EQ.'KDIRI') THEN
        IF(LEN.NE.3) THEN
          CALL ERROR$MSG('RIXS GETR8A KDIRI LEN NOT 3')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$STOP('RIXS$GETR8A')
        END IF
        VAL(:)=THIS%KDIRI(:)
      ELSE IF(ID.EQ.'KDIRO') THEN
        IF(LEN.NE.3) THEN
          CALL ERROR$MSG('RIXS GETR8A KDIRO LEN NOT 3')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$STOP('RIXS$GETR8A')
        END IF
        VAL(:)=THIS%KDIRO(:)
      ELSE IF(ID.EQ.'KI') THEN
        IF(LEN.NE.3) THEN
          CALL ERROR$MSG('RIXS GETR8A KI LEN NOT 3')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$STOP('RIXS$GETR8A')
        END IF
        VAL(:)=THIS%KI(:)
      ELSE IF(ID.EQ.'KO') THEN
        IF(LEN.NE.3) THEN
          CALL ERROR$MSG('RIXS GETR8A KO LEN NOT 3')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$STOP('RIXS$GETR8A')
        END IF
        VAL(:)=THIS%KO(:)
      ELSE IF(ID.EQ.'Q') THEN
        IF(LEN.NE.3) THEN
          CALL ERROR$MSG('RIXS GETR8A Q LEN NOT 3')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$STOP('RIXS$GETR8A')
        END IF
        VAL(:)=THIS%Q(:)
      ELSE IF(ID.EQ.'XKI') THEN
        IF(LEN.NE.3) THEN
          CALL ERROR$MSG('RIXS GETR8A XKI LEN NOT 3')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$STOP('RIXS$GETR8A')
        END IF
        VAL(:)=THIS%XKI(:)
      ELSE IF(ID.EQ.'XKO') THEN
        IF(LEN.NE.3) THEN
          CALL ERROR$MSG('RIXS GETR8A XKO LEN NOT 3')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$STOP('RIXS$GETR8A')
        END IF
        VAL(:)=THIS%XKO(:)
      ELSE IF(ID.EQ.'XQ') THEN
        IF(LEN.NE.3) THEN
          CALL ERROR$MSG('RIXS GETR8A XQ LEN NOT 3')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$STOP('RIXS$GETR8A')
        END IF
        VAL(:)=THIS%XQ(:)
      ELSE IF(ID.EQ.'QAPPROX') THEN
        IF(LEN.NE.3) THEN
          CALL ERROR$MSG('RIXS GETR8A QAPPROX LEN NOT 3')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$STOP('RIXS$GETR8A')
        END IF
        VAL(:)=THIS%QAPPROX(:)
      ELSE IF(ID.EQ.'XQAPPROX') THEN
        IF(LEN.NE.3) THEN
          CALL ERROR$MSG('RIXS GETR8A XQAPPROX LEN NOT 3')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$STOP('RIXS$GETR8A')
        END IF
        VAL(:)=THIS%XQAPPROX(:)
      ELSE
        CALL ERROR$MSG('RIXS GETR8A ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('RIXS$GETR8A')
      END IF
      RETURN
      END SUBROUTINE RIXS$GETR8A
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS$SETR8A(ID,LEN,VAL)  ! MARK: RIXS$SETR8A
!     **************************************************************************
!     ** SET REAL ARRAY IN RIXS MODULE                                        **
!     ** REQUIRES RIXS INITIALIZED AND SELECTED                               **
!     **************************************************************************
! TODO: CHECK WHICH ONES ACTUALLY NEED TO BE SET
      USE RIXS_MODULE, ONLY: SELECTED,THIS,TINITIALIZE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: LEN
      REAL(8), INTENT(IN) :: VAL(LEN)
      IF(.NOT.TINITIALIZE) THEN
        CALL ERROR$MSG('RIXS NOT INITIALIZED')
        CALL ERROR$STOP('RIXS$SETR8A')
      END IF
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('RIXS SPECTRUM NOT SELECTED')
        CALL ERROR$STOP('RIXS$SETR8A')
      END IF
      IF(ID.EQ.'NORMAL') THEN
        IF(LEN.NE.3) THEN
          CALL ERROR$MSG('RIXS SETR8A NORMAL LEN NOT 3')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$STOP('RIXS$SETR8A')
        END IF
        THIS%NORMAL(:)=VAL(:)
      ELSE IF(ID.EQ.'KDIRI') THEN
        IF(LEN.NE.3) THEN
          CALL ERROR$MSG('RIXS SETR8A KDIRI LEN NOT 3')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$STOP('RIXS$SETR8A')
        END IF
        THIS%KDIRI(:)=VAL(:)
      ELSE IF(ID.EQ.'KDIRO') THEN
        IF(LEN.NE.3) THEN
          CALL ERROR$MSG('RIXS SETR8A KDIRO LEN NOT 3')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$STOP('RIXS$SETR8A')
        END IF
        THIS%KDIRO(:)=VAL(:)
      ELSE IF(ID.EQ.'KI') THEN
        IF(LEN.NE.3) THEN
          CALL ERROR$MSG('RIXS SETR8A KI LEN NOT 3')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$STOP('RIXS$SETR8A')
        END IF
        THIS%KI(:)=VAL(:)
      ELSE IF(ID.EQ.'KO') THEN
        IF(LEN.NE.3) THEN
          CALL ERROR$MSG('RIXS SETR8A KO LEN NOT 3')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$STOP('RIXS$SETR8A')
        END IF
        THIS%KO(:)=VAL(:)
      ELSE IF(ID.EQ.'Q') THEN
        IF(LEN.NE.3) THEN
          CALL ERROR$MSG('RIXS SETR8A Q LEN NOT 3')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$STOP('RIXS$SETR8A')
        END IF
        THIS%Q(:)=VAL(:)
      ELSE IF(ID.EQ.'XKI') THEN
        IF(LEN.NE.3) THEN
          CALL ERROR$MSG('RIXS SETR8A XKI LEN NOT 3')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$STOP('RIXS$SETR8A')
        END IF
        THIS%XKI(:)=VAL(:)
      ELSE IF(ID.EQ.'XKO') THEN
        IF(LEN.NE.3) THEN
          CALL ERROR$MSG('RIXS SETR8A XKO LEN NOT 3')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$STOP('RIXS$SETR8A')
        END IF
        THIS%XKO(:)=VAL(:)
      ELSE IF(ID.EQ.'XQ') THEN
        IF(LEN.NE.3) THEN
          CALL ERROR$MSG('RIXS SETR8A XQ LEN NOT 3')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$STOP('RIXS$SETR8A')
        END IF
        THIS%XQ(:)=VAL(:)
      ELSE IF(ID.EQ.'QAPPROX') THEN
        IF(LEN.NE.3) THEN
          CALL ERROR$MSG('RIXS SETR8A QAPPROX LEN NOT 3')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$STOP('RIXS$SETR8A')
        END IF
        THIS%QAPPROX(:)=VAL(:)
      ELSE IF(ID.EQ.'XQAPPROX') THEN
        IF(LEN.NE.3) THEN
          CALL ERROR$MSG('RIXS SETR8A XQAPPROX LEN NOT 3')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$STOP('RIXS$SETR8A')
        END IF
        THIS%XQAPPROX(:)=VAL(:)
      ELSE
        CALL ERROR$MSG('RIXS SETR8A ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('RIXS$SETR8A')
      END IF
      RETURN
      END SUBROUTINE RIXS$SETR8A
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS$GETC8A(ID,LEN,VAL)  ! MARK: RIXS$GETC8A
!     **************************************************************************
!     ** GET COMPLEX ARRAY FROM RIXS MODULE                                   **
!     ** REQUIRES RIXS INITIALIZED AND SELECTED                               **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: SELECTED,THIS,TINITIALIZE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: LEN
      COMPLEX(8), INTENT(OUT) :: VAL(LEN)
      IF(.NOT.TINITIALIZE) THEN
        CALL ERROR$MSG('RIXS NOT INITIALIZED')
        CALL ERROR$STOP('RIXS$GETC8A')
      END IF
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('RIXS SPECTRUM NOT SELECTED')
        CALL ERROR$STOP('RIXS$GETC8A')
      END IF
      IF(ID.EQ.'POLI') THEN
        IF(LEN.NE.2) THEN
          CALL ERROR$MSG('RIXS GETC8A POLI SIZE NOT 2')
          CALL ERROR$I4VAL('SIZE: ',SIZE(VAL))
          CALL ERROR$STOP('RIXS$GETC8A')
        END IF
        VAL(:)=THIS%POLI(:)
      ELSE IF(ID.EQ.'POLXYZI') THEN
        IF(LEN.NE.3) THEN
          CALL ERROR$MSG('RIXS GETC8A POLXYZI SIZE NOT 3')
          CALL ERROR$I4VAL('SIZE: ',SIZE(VAL))
          CALL ERROR$STOP('RIXS$GETC8A')
        END IF
        IF(.NOT.THIS%TPOLXYZI) THEN
          CALL POLARISATION_CONVERT(THIS%KDIRI,THIS%NORMAL,THIS%POLI,THIS%POLXYZI)
          THIS%TPOLXYZI=.TRUE.
        END IF
        VAL(:)=THIS%POLXYZI(:)
      ELSE IF(ID.EQ.'POLO') THEN
        IF(LEN.NE.2) THEN
          CALL ERROR$MSG('RIXS GETC8A POLO SIZE NOT 2')
          CALL ERROR$I4VAL('SIZE: ',SIZE(VAL))
          CALL ERROR$STOP('RIXS$GETC8A')
        END IF
        VAL(:)=THIS%POLO(:)
      ELSE IF(ID.EQ.'POLXYZO') THEN
        IF(LEN.NE.3) THEN
          CALL ERROR$MSG('RIXS GETC8A POLXYZO SIZE NOT 3')
          CALL ERROR$I4VAL('SIZE: ',SIZE(VAL))
          CALL ERROR$STOP('RIXS$GETC8A')
        END IF
        IF(.NOT.THIS%TPOLXYZO) THEN
          CALL POLARISATION_CONVERT(THIS%KDIRO,THIS%NORMAL,THIS%POLO,THIS%POLXYZO)
          THIS%TPOLXYZO=.TRUE.
        END IF
        VAL(:)=THIS%POLXYZO(:)
      ELSE
        CALL ERROR$MSG('RIXS GETC8A ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('RIXS$GETC8A')
      END IF
      RETURN
      END SUBROUTINE RIXS$GETC8A
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS$SETC8A(ID,LEN,VAL)  ! MARK: RIXS$SETC8A
!     **************************************************************************
!     ** SET COMPLEX ARRAY IN RIXS MODULE                                     **
!     ** REQUIRES RIXS INITIALIZED AND SELECTED                               **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: SELECTED,THIS,TINITIALIZE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: LEN
      COMPLEX(8), INTENT(IN) :: VAL(LEN)
      IF(.NOT.TINITIALIZE) THEN
        CALL ERROR$MSG('RIXS NOT INITIALIZED')
        CALL ERROR$STOP('RIXS$SETC8A')
      END IF
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('RIXS SPECTRUM NOT SELECTED')
        CALL ERROR$STOP('RIXS$SETC8A')
      END IF
      IF(ID.EQ.'POLI') THEN
        IF(LEN.NE.2) THEN
          CALL ERROR$MSG('RIXS SETC8A POLI SIZE NOT 2')
          CALL ERROR$I4VAL('SIZE: ',SIZE(VAL))
          CALL ERROR$STOP('RIXS$SETC8A')
        END IF
        THIS%POLI(:)=VAL(:)
      ! ELSE IF(ID.EQ.'POLXYZI') THEN
      !   IF(LEN.NE.3) THEN
      !     CALL ERROR$MSG('RIXS SETC8A POLXYZI SIZE NOT 3')
      !     CALL ERROR$I4VAL('SIZE: ',SIZE(VAL))
      !     CALL ERROR$STOP('RIXS$SETC8A')
      !   END IF
      !   THIS%POLXYZI(:)=VAL(:)
      ELSE IF(ID.EQ.'POLO') THEN
        IF(LEN.NE.2) THEN
          CALL ERROR$MSG('RIXS SETC8A POLO SIZE NOT 2')
          CALL ERROR$I4VAL('SIZE: ',SIZE(VAL))
          CALL ERROR$STOP('RIXS$SETC8A')
        END IF
        THIS%POLO(:)=VAL(:)
      ! ELSE IF(ID.EQ.'POLXYZO') THEN
      !   IF(LEN.NE.3) THEN
      !     CALL ERROR$MSG('RIXS SETC8A POLXYZO SIZE NOT 3')
      !     CALL ERROR$I4VAL('SIZE: ',SIZE(VAL))
      !     CALL ERROR$STOP('RIXS$SETC8A')
      !   END IF
      !   THIS%POLXYZO(:)=VAL(:)
      ELSE
        CALL ERROR$MSG('RIXS SETC8A ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('RIXS$SETC8A')
      END IF
      RETURN
      END SUBROUTINE RIXS$SETC8A
!
!     ==========================================================================
!     ==========================================================================
!     ==                    STATE MODULE FUNCTIONS                            ==
!     ==========================================================================
!     ==========================================================================
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE STATE$INIT(NKPT_,NSPIN_,NDIM_,NPRO_)  ! MARK: STATE$INIT
!     **************************************************************************
!     ** INITIALIZE STATE MODULE                                              **
!     **************************************************************************
!     TODO: NPRO IS ENFORCED TO BE THE SAME FOR BOTH SIMULATIONS
      USE STATE_MODULE
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: NKPT_
      INTEGER(4), INTENT(IN) :: NSPIN_
      INTEGER(4), INTENT(IN) :: NDIM_
      INTEGER(4), INTENT(IN) :: NPRO_
                          CALL TRACE$PUSH('STATE$INIT')
      IF(INITIALIZED) THEN
        ! IF ALREADY INITIALIZED, CHECK IF SAME VALUES
        IF(NKPT_.NE.NKPTG.OR.NSPIN_.NE.NSPING.OR.NDIM_.NE.NDIM.OR.NPRO_.NE.NPRO) THEN
          CALL ERROR$MSG('STATE ALREADY INITIALIZED WITH DIFFERENT VALUES')
          CALL ERROR$I4VAL('OLD NKPTG: ',NKPTG)
          CALL ERROR$I4VAL('OLD NSPING: ',NSPING)
          CALL ERROR$I4VAL('OLD NDIM: ',NDIM)
          CALL ERROR$I4VAL('OLD NPRO: ',NPRO)
          CALL ERROR$I4VAL('NEW NKPTG: ',NKPT_)
          CALL ERROR$I4VAL('NEW NSPING: ',NSPIN_)
          CALL ERROR$I4VAL('NEW NDIM: ',NDIM_)
          CALL ERROR$I4VAL('NEW NPRO: ',NPRO_)
          CALL ERROR$STOP('STATE$INIT')
        END IF
        CALL TRACE$POP
        RETURN
      END IF
      NKPTG=NKPT_
      NSPING=NSPIN_
      NDIM=NDIM_
      NPRO=NPRO_
      ALLOCATE(GROUND(NKPTG,NSPING))
      ALLOCATE(EXCITE(NKPTG,NSPING))
      INITIALIZED=.TRUE.
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE STATE$INIT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE STATE$REPORT(NFIL)  ! MARK: STATE$REPORT
!     **************************************************************************
!     ** REPORT STATE MODULE                                                  **
!     ** REQUIRES STATE INITIALIZED AND SELECTED                              **
!     **************************************************************************
      USE STATE_MODULE, ONLY: INITIALIZED,THIS,NKPTG,NSPING,SELECTED
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: NFIL
      INTEGER(4) :: IKPT,ISPIN
      INTEGER(4) :: NTASKS,THISTASK,RTASK
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      CALL KSMAP$READTASK(RTASK)
      IF(THISTASK.NE.RTASK) RETURN
                          CALL TRACE$PUSH('STATE$REPORT')
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('CANNOT REPORT STATE WHEN STATE ARRAY NOT SELECTED')
        CALL ERROR$STOP('STATE$REPORT')
      END IF
      IF(.NOT.INITIALIZED) THEN
        CALL ERROR$MSG('STATE NOT INITIALIZED')
        CALL ERROR$STOP('STATE$REPORT')
      END IF
      WRITE(NFIL,FMT='(A)')'STATE REPORT'
      WRITE(NFIL,FMT='(4A10)')'IKPT','ISPIN','NB','NOCC'
      DO IKPT=1,NKPTG
        DO ISPIN=1,NSPING
          WRITE(NFIL,'(4I10)')IKPT,ISPIN,THIS(IKPT,ISPIN)%NB,THIS(IKPT,ISPIN)%NOCC
        ENDDO
      ENDDO
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE STATE$REPORT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE STATE$ENERGYWRITE(NFIL)  ! MARK: STATE$ENERGYWRITE
!     **************************************************************************
!     ** WRITE STATE ENERGIES TO FILE                                        **
!     ** REQUIRES STATE INITIALIZED AND SELECTED                              **
!     **************************************************************************
      USE STATE_MODULE, ONLY: INITIALIZED,THIS,NKPTG,NSPING,SELECTED
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: NFIL
      INTEGER(4) :: IKPT,ISPIN
      INTEGER(4) :: NTASKS,THISTASK,RTASK
      REAL(8) :: EV
      CHARACTER(32) :: FMTEIG
      CHARACTER(32) :: FMTOCC
      INTEGER(4) :: ITEN,I1,I2
      INTEGER(4) :: IB
      REAL(8), ALLOCATABLE :: WKPT(:)


      CALL MPE$QUERY('~',NTASKS,THISTASK)
      CALL KSMAP$READTASK(RTASK)
      IF(THISTASK.NE.RTASK) RETURN
                          CALL TRACE$PUSH('STATE$ENERGYWRITE')
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('CANNOT WRITE STATE ENERGIES WHEN STATE ARRAY NOT SELECTED')
        CALL ERROR$STOP('STATE$ENERGYWRITE')
      END IF
      IF(.NOT.INITIALIZED) THEN
        CALL ERROR$MSG('STATE NOT INITIALIZED')
        CALL ERROR$STOP('STATE$ENERGYWRITE')
      END IF
      CALL CONSTANTS('EV',EV)
      ALLOCATE(WKPT(NKPTG))
      CALL SIMULATION$SELECT('GROUND')
      CALL SIMULATION$GETR8A('WKPT',NKPTG,WKPT)
      CALL SIMULATION$UNSELECT
      FMTEIG='("EIG",I3,":",10F8.3)'
      FMTOCC='("OCC",I3,":",10F8.3)'
      DO IKPT=1,NKPTG
        DO ISPIN=1,NSPING
          WRITE(NFIL,FMT='(A5,I6,A6,I2)')'IKPT=',IKPT,' SPIN=',ISPIN
          ITEN=0
          DO WHILE(THIS(IKPT,ISPIN)%NB.GT.ITEN)
            I1=ITEN+1
            I2=MIN(ITEN+10,THIS(IKPT,ISPIN)%NB)
            WRITE(NFIL,FMT=FMTEIG)ITEN,(THIS(IKPT,ISPIN)%EIG(IB)/EV,IB=I1,I2)
            ITEN=ITEN+10
          ENDDO
          ITEN=0
          DO WHILE(THIS(IKPT,ISPIN)%NB.GT.ITEN)
            I1=ITEN+1
            I2=MIN(ITEN+10,THIS(IKPT,ISPIN)%NB)
            WRITE(NFIL,FMT=FMTOCC)ITEN,(THIS(IKPT,ISPIN)%OCC(IB)/WKPT(IKPT),IB=I1,I2)
            ITEN=ITEN+10
          ENDDO
        ENDDO
      ENDDO
      DEALLOCATE(WKPT)
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE STATE$ENERGYWRITE
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE STATE$DEALLOCATEPROJ  ! MARK: STATE$DEALLOCATEPROJ
!     **************************************************************************
!     ** DEALLOCATE PROJECTION ARRAYS IN STATE MODULE                         **
!     ** REQUIRES STATE INITIALIZED AND UNSELECTED                            **
!     **************************************************************************
      USE STATE_MODULE, ONLY: INITIALIZED,THIS,NKPTG,NSPING
      IMPLICIT NONE
      INTEGER(4), PARAMETER :: NSIM=2
      INTEGER(4) :: ISIM
      INTEGER(4) :: IKPT,ISPIN
                          CALL TRACE$PUSH('STATE$DEALLOCATEPROJ')
      IF(.NOT.INITIALIZED) THEN
        CALL ERROR$MSG('STATE NOT INITIALIZED')
        CALL ERROR$STOP('STATE$DEALLOCATEPROJ')
      END IF
      DO ISIM=1,NSIM
        CALL STATE$ISELECT(ISIM)
        DO IKPT=1,NKPTG
          DO ISPIN=1,NSPING
            IF(ALLOCATED(THIS(IKPT,ISPIN)%PROJ)) DEALLOCATE(THIS(IKPT,ISPIN)%PROJ)
          ENDDO
        ENDDO
        CALL STATE$UNSELECT
      ENDDO
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE STATE$DEALLOCATEPROJ
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE STATE_OCCUPATION  ! MARK: STATE_OCCUPATION
!     **************************************************************************
!     ** CALCULATE OCCUPATION NUMBER FOR ALL STATES                           **
!     ** REQUIRES NO STATE ARRAY SELECTED                                     **
!     **************************************************************************
! TODO: NOT PROTECTED AGAINST ALLOCATED BUT EMPTY EIG AND OCC ARRAYS
! ERROR: CHOOSE BETTER METHOD OF DETECTING OCCUPATION NUMBER
! TODO: IMPLEMENT FERMI LEVEL DETECTION
      USE STATE_MODULE, ONLY: THIS,SELECTED,INITIALIZED,NKPTG,NSPING, &
     &                        OCCPERCENT
      IMPLICIT NONE
      INTEGER(4), PARAMETER :: NSIM=2
      INTEGER(4) :: ISIM
      INTEGER(4) :: IKPT
      INTEGER(4) :: ISPIN
      REAL(8) :: OCCLIMIT
      INTEGER(4) :: NB
      INTEGER(4) :: NOCC
      INTEGER(4) :: IB
      INTEGER(4) :: NTASKS,THISTASK,WTASK,RTASK
      REAL(8), ALLOCATABLE :: WKPT(:)
                          CALL TRACE$PUSH('STATE_OCCUPATION')
      IF(.NOT.INITIALIZED) THEN
        CALL ERROR$MSG('STATE NOT INITIALIZED')
        CALL ERROR$STOP('STATE$OCCUPATION')
      END IF
      IF(SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('CANNOT CALCULATE OCCUPATION NUMBER WHEN STATE ARRAY SELECTED')
        CALL ERROR$STOP('STATE$OCCUPATION')
      END IF
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      CALL KSMAP$READTASK(RTASK)
      ! COUNT NUMBER OF OCCUPIED STATES BASED ON OCCUPATION 
      ! (INTEGRATION WEIGHTS)
      OCCLIMIT=OCCPERCENT*(MOD(NSPING,2)+1)
      ALLOCATE(WKPT(NKPTG))
      
      DO ISIM=1,NSIM
        CALL STATE$ISELECT(ISIM)
        CALL SIMULATION$ISELECT(ISIM)
        CALL SIMULATION$GETR8A('WKPT',NKPTG,WKPT)
        CALL SIMULATION$UNSELECT
        DO IKPT=1,NKPTG
          DO ISPIN=1,NSPING
            CALL KSMAP$WORKTASK(IKPT,ISPIN,WTASK)
            IF(THISTASK.NE.WTASK.AND.THISTASK.NE.RTASK) CYCLE
            NOCC=THIS(IKPT,ISPIN)%NOCC
            IF(NOCC.NE.-HUGE(1)) THEN
              CALL ERROR$MSG('OCCUPATION NUMBER ALREADY SET')
              CALL ERROR$I4VAL('IKPT: ',IKPT)
              CALL ERROR$I4VAL('ISPIN: ',ISPIN)
              CALL ERROR$I4VAL('NOCC: ',NOCC)
              CALL ERROR$STOP('STATE$OCCUPATION')
            END IF
            NB=THIS(IKPT,ISPIN)%NB
            NOCC=-1
            DO IB=1,NB
              IF(THIS(IKPT,ISPIN)%OCC(IB)/WKPT(IKPT).LT.OCCLIMIT) THEN
                NOCC=IB-1
                EXIT
              END IF
            ENDDO
            IF(NOCC.EQ.-1) THEN
              ! ALL STATES OCCUPIED
              NOCC=NB
            END IF
            THIS(IKPT,ISPIN)%NOCC=NOCC
            CALL OVERLAP$SELECT(IKPT,ISPIN)
            CALL OVERLAP$SETI4('NOCC',NOCC)
            CALL OVERLAP$UNSELECT()
          ENDDO
        ENDDO
        CALL STATE$UNSELECT()
      ENDDO
      DEALLOCATE(WKPT)
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE STATE_OCCUPATION
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE STATE$SELECT(ID)  ! MARK: STATE$SELECT
!     **************************************************************************
!     ** SELECT STATE ARRAY                                                   **
!     **************************************************************************
      USE STATE_MODULE, ONLY: GROUND,EXCITE,THIS,SELECTED
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      IF(SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('CANNOT SELECT STATE ARRAY WHEN ALREADY SELECTED')
        CALL ERROR$STOP('STATE$SELECT')
      END IF
      IF(ID.EQ.'GROUND') THEN
        ! IF(.NOT.ALLOCATED(GROUND)) THEN
        !   CALL ERROR$MSG('GROUND STATE ARRAY NOT ALLOCATED')
        !   CALL ERROR$STOP('STATE$SELECT')
        ! END IF
        THIS=>GROUND
      ELSE IF(ID.EQ.'EXCITE') THEN
        ! IF(.NOT.ALLOCATED(EXCITE)) THEN
        !   CALL ERROR$MSG('EXCITE STATE ARRAY NOT ALLOCATED')
        !   CALL ERROR$STOP('STATE$SELECT')
        ! END IF
        THIS=>EXCITE
      ELSE
        CALL ERROR$MSG('STATE SELECT ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('STATE$SELECT')
      END IF
      SELECTED=.TRUE.
      RETURN
      END SUBROUTINE STATE$SELECT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE STATE$UNSELECT()  ! MARK: STATE$UNSELECT
!     **************************************************************************
!     ** UNSELECT STATE ARRAY                                                 **
!     **************************************************************************
      USE STATE_MODULE, ONLY: THIS,SELECTED
      IMPLICIT NONE
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('CANNOT UNSELECT STATE ARRAY WHEN NOT SELECTED')
        CALL ERROR$STOP('STATE$UNSELECT')
      END IF
      SELECTED=.FALSE.
      NULLIFY(THIS)
      RETURN
      END SUBROUTINE STATE$UNSELECT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE STATE$ISELECT(I)  ! MARK: STATE$ISELECT
!     **************************************************************************
!     ** SELECT STATE ARRAY BY INDEX                                          **
!     **************************************************************************
      USE STATE_MODULE, ONLY: GROUND,EXCITE,THIS,SELECTED
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: I
      IF(SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('CANNOT SELECT STATE ARRAY WHEN ALREADY SELECTED')
        CALL ERROR$STOP('STATE$ISELECT')
      END IF
      IF(I.EQ.1) THEN
        ! IF(.NOT.ALLOCATED(GROUND)) THEN
        !   CALL ERROR$MSG('GROUND STATE ARRAY NOT ALLOCATED')
        !   CALL ERROR$STOP('STATE$ISELECT')
        ! END IF
        THIS=>GROUND
      ELSE IF(I.EQ.2) THEN
        ! IF(.NOT.ALLOCATED(EXCITE)) THEN
        !   CALL ERROR$MSG('EXCITE STATE ARRAY NOT ALLOCATED')
        !   CALL ERROR$STOP('STATE$ISELECT')
        ! END IF
        THIS=>EXCITE
      ELSE
        CALL ERROR$MSG('STATE ISELECT INDEX NOT RECOGNIZED')
        CALL ERROR$I4VAL('INDEX: ',I)
        CALL ERROR$STOP('STATE$ISELECT')
      END IF
      SELECTED=.TRUE.
      RETURN
      END SUBROUTINE STATE$ISELECT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE STATE$NEW(IKPT,ISPIN,NB)  ! MARK: STATE$NEW
!     **************************************************************************
!     ** CREATE NEW STATE IN ARRAY                                            **
!     ** REQUIRES SELECTED STATE ARRAY                                        **
!     **************************************************************************
      USE STATE_MODULE, ONLY: THIS,SELECTED,NKPTG,NSPING
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: IKPT
      INTEGER(4), INTENT(IN) :: ISPIN
      INTEGER(4), INTENT(IN) :: NB
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO STATE ARRAY SELECTED')
        CALL ERROR$STOP('STATE$NEW')
      END IF
      IF(IKPT.LE.0.OR.IKPT.GT.NKPTG) THEN
        CALL ERROR$MSG('INVALID KPOINT INDEX')
        CALL ERROR$I4VAL('KPOINT INDEX: ',IKPT)
        CALL ERROR$STOP('STATE$NEW')
      END IF
      IF(ISPIN.LE.0.OR.ISPIN.GT.NSPING) THEN
        CALL ERROR$MSG('INVALID SPIN INDEX')
        CALL ERROR$I4VAL('SPIN INDEX: ',ISPIN)
        CALL ERROR$STOP('STATE$NEW')
      END IF
      IF(NB.LE.0) THEN
        CALL ERROR$MSG('NUMBER OF BANDS MUST BE POSITIVE')
        CALL ERROR$I4VAL('NUMBER OF BANDS: ',NB)
        CALL ERROR$STOP('STATE$NEW')
      END IF
      IF(THIS(IKPT,ISPIN)%NB.NE.(-HUGE(1))) THEN
        CALL ERROR$MSG('STATE ALREADY EXISTS')
        CALL ERROR$I4VAL('KPOINT INDEX: ',IKPT)
        CALL ERROR$I4VAL('SPIN INDEX: ',ISPIN)
        CALL ERROR$STOP('STATE$NEW')
      END IF
      ! INITIALIZE STATE
      THIS(IKPT,ISPIN)%NB=NB
      ALLOCATE(THIS(IKPT,ISPIN)%EIG(NB))
      ALLOCATE(THIS(IKPT,ISPIN)%OCC(NB))
      ! PROJ IS NOT ALLOCATED HERE AS IT IS NOT USED WHEN STARTING FROM OVERLAP
      RETURN
      END SUBROUTINE STATE$NEW
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE STATE$GETI4(ID,IKPT,ISPIN,VAL)  ! MARK: STATE$GETI4
!     **************************************************************************
!     ** GET INTEGER VALUE FROM SELECTED STATE                                **
!     ** REQUIRES SELECTED STATE ARRAY                                        **
!     **************************************************************************
      USE STATE_MODULE, ONLY: THIS,SELECTED,NKPTG,NSPING,NPRO,NDIM
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: IKPT
      INTEGER(4), INTENT(IN) :: ISPIN
      INTEGER(4), INTENT(OUT) :: VAL
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO STATE ARRAY SELECTED')
        CALL ERROR$STOP('STATE$GETI4')
      END IF
      IF(IKPT.LE.0.OR.IKPT.GT.NKPTG) THEN
        CALL ERROR$MSG('INVALID KPOINT INDEX')
        CALL ERROR$I4VAL('KPOINT INDEX: ',IKPT)
        CALL ERROR$STOP('STATE$GETI4')
      END IF
      IF(ISPIN.LE.0.OR.ISPIN.GT.NSPING) THEN
        CALL ERROR$MSG('INVALID SPIN INDEX')
        CALL ERROR$I4VAL('SPIN INDEX: ',ISPIN)
        CALL ERROR$STOP('STATE$GETI4')
      END IF
      IF(ID.EQ.'NB') THEN
        VAL=THIS(IKPT,ISPIN)%NB
      ELSE IF(ID.EQ.'NOCC') THEN
        VAL=THIS(IKPT,ISPIN)%NOCC
      ELSE IF(ID.EQ.'NPRO') THEN
        VAL=NPRO
      ELSE IF(ID.EQ.'NDIM') THEN
        VAL=NDIM
      ELSE
        CALL ERROR$MSG('STATE GETI4 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('STATE$GETI4')
      END IF
      RETURN
      END SUBROUTINE STATE$GETI4
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE STATE$SETR8A(ID,IKPT,ISPIN,LEN,VAL)  ! MARK: STATE$SETR8A
!     **************************************************************************
!     ** SET REAL VALUE ARRAY IN SELECTED STATE                               **
!     ** REQUIRES SELECTED STATE ARRAY                                        **
!     **************************************************************************
      USE STATE_MODULE, ONLY: THIS,SELECTED,NKPTG,NSPING
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: IKPT
      INTEGER(4), INTENT(IN) :: ISPIN
      INTEGER(4), INTENT(IN) :: LEN
      REAL(8), INTENT(IN) :: VAL(LEN)
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO STATE ARRAY SELECTED')
        CALL ERROR$STOP('STATE$SETR8A')
      END IF
      IF(IKPT.LE.0.OR.IKPT.GT.NKPTG) THEN
        CALL ERROR$MSG('INVALID KPOINT INDEX')
        CALL ERROR$I4VAL('KPOINT INDEX: ',IKPT)
        CALL ERROR$STOP('STATE$SETR8A')
      END IF
      IF(ISPIN.LE.0.OR.ISPIN.GT.NSPING) THEN
        CALL ERROR$MSG('INVALID SPIN INDEX')
        CALL ERROR$I4VAL('SPIN INDEX: ',ISPIN)
        CALL ERROR$STOP('STATE$SETR8A')
      END IF
      IF(ID.EQ.'EIG') THEN
        IF(LEN.NE.THIS(IKPT,ISPIN)%NB) THEN
          CALL ERROR$MSG('LEN MUST BE EQUAL TO NUMBER OF BANDS')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$I4VAL('NB: ',THIS(IKPT,ISPIN)%NB)
          CALL ERROR$CHVAL('ID: ',ID)
          CALL ERROR$STOP('STATE$SETR8A')
        END IF
        THIS(IKPT,ISPIN)%EIG(:)=VAL(:)
      ELSE IF(ID.EQ.'OCC') THEN
        IF(LEN.NE.THIS(IKPT,ISPIN)%NB) THEN
          CALL ERROR$MSG('LENGTH MUST BE EQUAL TO NUMBER OF BANDS')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$I4VAL('NB: ',THIS(IKPT,ISPIN)%NB)
          CALL ERROR$CHVAL('ID: ',ID)
          CALL ERROR$STOP('STATE$SETR8A')
        END IF
        THIS(IKPT,ISPIN)%OCC=VAL(:)
      ELSE
        CALL ERROR$MSG('STATE SETR8A ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('STATE$SETR8A')
      END IF
      RETURN
      END SUBROUTINE STATE$SETR8A
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE STATE$GETR8A(ID,IKPT,ISPIN,LEN,VAL)  ! MARK: STATE$GETR8A
!     **************************************************************************
!     ** GET REAL VALUE ARRAY FROM SELECTED STATE                             **
!     ** REQUIRES SELECTED STATE ARRAY                                        **
!     **************************************************************************
      USE STATE_MODULE, ONLY: THIS,SELECTED,NKPTG,NSPING
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: IKPT
      INTEGER(4), INTENT(IN) :: ISPIN
      INTEGER(4), INTENT(IN) :: LEN
      REAL(8), INTENT(OUT) :: VAL(LEN)
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO STATE ARRAY SELECTED')
        CALL ERROR$STOP('STATE$GETR8A')
      END IF
      IF(IKPT.LE.0.OR.IKPT.GT.NKPTG) THEN
        CALL ERROR$MSG('INVALID KPOINT INDEX')
        CALL ERROR$I4VAL('KPOINT INDEX: ',IKPT)
        CALL ERROR$STOP('STATE$GETR8A')
      END IF
      IF(ISPIN.LE.0.OR.ISPIN.GT.NSPING) THEN
        CALL ERROR$MSG('INVALID SPIN INDEX')
        CALL ERROR$I4VAL('SPIN INDEX: ',ISPIN)
        CALL ERROR$STOP('STATE$GETR8A')
      END IF
      IF(ID.EQ.'EIG') THEN
        IF(LEN.NE.THIS(IKPT,ISPIN)%NB) THEN
          CALL ERROR$MSG('LEN MUST BE EQUAL TO NUMBER OF BANDS')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$I4VAL('NB: ',THIS(IKPT,ISPIN)%NB)
          CALL ERROR$CHVAL('ID: ',ID)
          CALL ERROR$STOP('STATE$GETR8A')
        END IF
        VAL(:)=THIS(IKPT,ISPIN)%EIG(:)
      ELSE IF(ID.EQ.'OCC') THEN
        IF(LEN.NE.THIS(IKPT,ISPIN)%NB) THEN
          CALL ERROR$MSG('LENGTH MUST BE EQUAL TO NUMBER OF BANDS')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$I4VAL('NB: ',THIS(IKPT,ISPIN)%NB)
          CALL ERROR$CHVAL('ID: ',ID)
          CALL ERROR$STOP('STATE$GETR8A')
        END IF
        VAL(:)=THIS(IKPT,ISPIN)%OCC(:)
      ELSE
        CALL ERROR$MSG('STATE GETR8A ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('STATE$GETR8A')
      END IF
      RETURN
      END SUBROUTINE STATE$GETR8A
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE STATE$SETC8A(ID,IKPT,ISPIN,LEN,VAL)  ! MARK: STATE$SETC8A
!     **************************************************************************
!     ** SET COMPLEX VALUE ARRAY IN SELECTED STATE                            **
!     ** REQUIRES SELECTED STATE ARRAY                                        **
!     **************************************************************************
      USE STATE_MODULE, ONLY: THIS,SELECTED,NKPTG,NSPING,NDIM,NPRO
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: IKPT
      INTEGER(4), INTENT(IN) :: ISPIN
      INTEGER(4), INTENT(IN) :: LEN
      COMPLEX(8), INTENT(IN) :: VAL(LEN)
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO STATE ARRAY SELECTED')
        CALL ERROR$STOP('STATE$SETC8A')
      END IF
      IF(IKPT.LE.0.OR.IKPT.GT.NKPTG) THEN
        CALL ERROR$MSG('INVALID KPOINT INDEX')
        CALL ERROR$I4VAL('KPOINT INDEX: ',IKPT)
        CALL ERROR$STOP('STATE$SETC8A')
      END IF
      IF(ISPIN.LE.0.OR.ISPIN.GT.NSPING) THEN
        CALL ERROR$MSG('INVALID SPIN INDEX')
        CALL ERROR$I4VAL('SPIN INDEX: ',ISPIN)
        CALL ERROR$STOP('STATE$SETC8A')
      END IF
      IF(ID.EQ.'PROJ') THEN
        IF(LEN.NE.NDIM*THIS(IKPT,ISPIN)%NB*NPRO) THEN
          CALL ERROR$MSG('LEN MUST BE EQUAL TO NDIM*NB*NPRO')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$I4VAL('NDIM*NB*NPRO: ',NDIM*THIS(IKPT,ISPIN)%NB*NPRO)
          CALL ERROR$CHVAL('ID: ',ID)
          CALL ERROR$STOP('STATE$SETC8A')
        END IF
        IF(.NOT.ALLOCATED(THIS(IKPT,ISPIN)%PROJ)) THEN
          ALLOCATE(THIS(IKPT,ISPIN)%PROJ(NDIM,THIS(IKPT,ISPIN)%NB,NPRO))
        END IF
        THIS(IKPT,ISPIN)%PROJ=RESHAPE(VAL,(/NDIM,THIS(IKPT,ISPIN)%NB,NPRO/))
      ELSE
        CALL ERROR$MSG('STATE SETC8A ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('STATE$SETC8A')
      END IF
      RETURN
      END SUBROUTINE STATE$SETC8A
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE STATE$GETC8A(ID,IKPT,ISPIN,LEN,VAL)  ! MARK: STATE$GETC8A
!     **************************************************************************
!     ** GET COMPLEX VALUE ARRAY FROM SELECTED STATE                          **
!     ** REQUIRES SELECTED STATE ARRAY                                        **
!     **************************************************************************
      USE STATE_MODULE, ONLY: THIS,SELECTED,NKPTG,NSPING,NDIM,NPRO
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: IKPT
      INTEGER(4), INTENT(IN) :: ISPIN
      INTEGER(4), INTENT(IN) :: LEN
      COMPLEX(8), INTENT(OUT) :: VAL(LEN)
      LOGICAL(4) :: TOVERLAP
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO STATE ARRAY SELECTED')
        CALL ERROR$STOP('STATE$GETC8A')
      END IF
      IF(IKPT.LE.0.OR.IKPT.GT.NKPTG) THEN
        CALL ERROR$MSG('INVALID KPOINT INDEX')
        CALL ERROR$I4VAL('KPOINT INDEX: ',IKPT)
        CALL ERROR$STOP('STATE$GETC8A')
      END IF
      IF(ISPIN.LE.0.OR.ISPIN.GT.NSPING) THEN
        CALL ERROR$MSG('INVALID SPIN INDEX')
        CALL ERROR$I4VAL('SPIN INDEX: ',ISPIN)
        CALL ERROR$STOP('STATE$GETC8A')
      END IF
      IF(ID.EQ.'PROJ') THEN
        ! NOT AVAILABLE IF START FROM OVERLAP FILE
        CALL XCNTL$GETL4('TOVERLAP',TOVERLAP)
        IF(TOVERLAP) THEN
          CALL ERROR$MSG('TOVERLAP IS TRUE, CANNOT GET PROJ')
          CALL ERROR$STOP('STATE$GETC8A')
        END IF
        IF(LEN.NE.NDIM*THIS(IKPT,ISPIN)%NB*NPRO) THEN
          CALL ERROR$MSG('LEN MUST BE EQUAL TO NDIM*NB*NPRO')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$I4VAL('NDIM*NB*NPRO: ',NDIM*THIS(IKPT,ISPIN)%NB*NPRO)
          CALL ERROR$CHVAL('ID: ',ID)
          CALL ERROR$STOP('STATE$GETC8A')
        END IF
        IF(.NOT.ALLOCATED(THIS(IKPT,ISPIN)%PROJ)) THEN
          CALL ERROR$MSG('PROJ NOT ALLOCATED')
          CALL ERROR$I4VAL('IKPT: ',IKPT)
          CALL ERROR$I4VAL('ISPIN: ',ISPIN)
          CALL ERROR$STOP('STATE$GETC8A')
        END IF
        VAL(:)=RESHAPE(THIS(IKPT,ISPIN)%PROJ,(/NDIM*THIS(IKPT,ISPIN)%NB*NPRO/))
      ELSE
        CALL ERROR$MSG('STATE GETC8A ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('STATE$GETC8A')
      END IF
      RETURN
      END SUBROUTINE STATE$GETC8A
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE STATE_WRITEOVERLAP(NFIL)  ! MARK: STATE_WRITEOVERLAP
!     **************************************************************************
!     ** WRITE OVERLAP_MODULE TO OVERLAP FILE WHICH SERVES AS A RESTART FILE  **
!     ** FOR THE SIMULATION                                                   **
!     ** REQUIRES NOT SELECTED STATE                                          **
!     **************************************************************************
      USE STATE_MODULE, ONLY: THIS,SELECTED,INITIALIZED,NKPTG, &
     &                        NSPING,NDIM,NPRO
      USE STRINGS_MODULE
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: NFIL
      INTEGER(4), PARAMETER :: NSIM=2
      INTEGER(4) :: NTASKS,THISTASK,RTASK
      INTEGER(4) :: IKPT,ISPIN
      INTEGER(4) :: ISIM
      CHARACTER(5) :: KEY
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      CALL KSMAP$READTASK(RTASK)
      ! EIG AND OCC ARE AVAILABLE ON RTASK AND CORRESPONDING WORKTASK
      IF(THISTASK.NE.RTASK) RETURN
                          CALL TRACE$PUSH('STATE_WRITEOVERLAP')
      IF(.NOT.INITIALIZED) THEN
        CALL ERROR$MSG('STATE NOT INITIALIZED')
        CALL ERROR$STOP('STATE_WRITEOVERLAP')
      END IF
      IF(SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('CANNOT WRITE OVERLAP WHEN STATE ARRAY SELECTED')
        CALL ERROR$STOP('STATE_WRITEOVERLAP')
      END IF

      KEY=+'STATE'
      WRITE(NFIL) KEY
      ! NKPTG,NSPING,NDIM,NPRO
      WRITE(NFIL) NKPTG,NSPING,NDIM,NPRO

      DO ISIM=1,NSIM
        CALL STATE$ISELECT(ISIM)
        DO IKPT=1,NKPTG
          DO ISPIN=1,NSPING
            ! NB
            WRITE(NFIL) THIS(IKPT,ISPIN)%NB
            ! EIG,OCC
            WRITE(NFIL) THIS(IKPT,ISPIN)%EIG,THIS(IKPT,ISPIN)%OCC
          ENDDO ! END ISPIN
        ENDDO ! END IKPT
        CALL STATE$UNSELECT
      ENDDO ! END ISIM
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE STATE_WRITEOVERLAP
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE STATE_READOVERLAP(NFIL)  ! MARK: STATE_READOVERLAP
!     **************************************************************************
!     ** READ OVERLAP_MODULE FROM OVERLAP FILE WHICH SERVES AS A RESTART FILE **
!     ** FOR THE SIMULATION                                                   **
!     ** REQUIRES NOT SELECTED STATE                                          **
!     **************************************************************************
      USE STATE_MODULE, ONLY: THIS,SELECTED,INITIALIZED
      USE MPE_MODULE
      USE STRINGS_MODULE
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: NFIL
      INTEGER(4), PARAMETER :: NSIM=2
      INTEGER(4) :: NTASKS,THISTASK,RTASK,WTASK
      INTEGER(4) :: NKPT,NSPIN,NDIM,NPRO
      INTEGER(4) :: ISIM
      INTEGER(4) :: IKPT,ISPIN
      INTEGER(4) :: NB,NOCC
      REAL(8), ALLOCATABLE :: EIG(:)
      REAL(8), ALLOCATABLE :: OCC(:)
      CHARACTER(5) :: KEY
                          CALL TRACE$PUSH('STATE_READOVERLAP')
      IF(INITIALIZED) THEN
        CALL ERROR$MSG('STATE ALREADY INITIALIZED')
        CALL ERROR$STOP('STATE_READOVERLAP')
      END IF
      IF(SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('CANNOT READ OVERLAP WHEN STATE ARRAY SELECTED')
        CALL ERROR$STOP('STATE_READOVERLAP')
      END IF
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      CALL KSMAP$READTASK(RTASK)
      IF(THISTASK.EQ.RTASK) THEN
        ! READ KEY
        READ(NFIL) KEY
        IF(KEY.NE.+'STATE') THEN
          CALL ERROR$MSG('OVERLAP FILE CORRUPTED')
          CALL ERROR$CHVAL('KEY: ',KEY)
          CALL ERROR$STOP('STATE_READOVERLAP')
        END IF
      END IF
      ! READ NKPTG,NSPING,NDIM,NPRO
      IF(THISTASK.EQ.RTASK) READ(NFIL) NKPT,NSPIN,NDIM,NPRO
      CALL MPE$BROADCAST('~',RTASK,NKPT)
      CALL MPE$BROADCAST('~',RTASK,NSPIN)
      CALL MPE$BROADCAST('~',RTASK,NDIM)
      CALL MPE$BROADCAST('~',RTASK,NPRO)
      CALL STATE$INIT(NKPT,NSPIN,NDIM,NPRO)

      DO ISIM=1,NSIM
        CALL STATE$ISELECT(ISIM)
        DO IKPT=1,NKPT
          DO ISPIN=1,NSPIN
            CALL KSMAP$WORKTASK(IKPT,ISPIN,WTASK)
            IF(THISTASK.NE.WTASK.AND.THISTASK.NE.RTASK) CYCLE
            ! READ NB
            IF(THISTASK.EQ.RTASK) READ(NFIL) NB
            CALL MPE$SENDRECEIVE('~',RTASK,WTASK,NB)
            CALL STATE$NEW(IKPT,ISPIN,NB)

            ALLOCATE(EIG(NB))
            ALLOCATE(OCC(NB))
            ! EIG,OCC
            IF(THISTASK.EQ.RTASK) READ(NFIL) EIG,OCC
            CALL MPE$SENDRECEIVE('~',RTASK,WTASK,EIG)
            CALL MPE$SENDRECEIVE('~',RTASK,WTASK,OCC)
            CALL STATE$SETR8A('EIG',IKPT,ISPIN,NB,EIG)
            CALL STATE$SETR8A('OCC',IKPT,ISPIN,NB,OCC)
            DEALLOCATE(EIG)
            DEALLOCATE(OCC)
          ENDDO
        ENDDO
        CALL STATE$UNSELECT
      ENDDO ! END ISIM
      CALL STATE_OCCUPATION
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE STATE_READOVERLAP
!
!     ==========================================================================
!     ==========================================================================
!     ==                    OVERLAP MODULE FUNCTIONS                          ==
!     ==========================================================================
!     ==========================================================================
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE OVERLAP$INIT(NKPT_,NSPIN_)  ! MARK: OVERLAP$INIT
!     **************************************************************************
!     ** INITIALIZE OVERLAP MODULE                                            **
!     **************************************************************************
      USE OVERLAP_MODULE, ONLY: NKPTG,NSPING,OVLARR,INITIALIZED
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: NKPT_
      INTEGER(4), INTENT(IN) :: NSPIN_
                          CALL TRACE$PUSH('OVERLAP$INIT')
      IF(INITIALIZED) THEN
        CALL ERROR$MSG('OVERLAP ALREADY INITIALIZED')
        CALL ERROR$STOP('OVERLAP$INIT')
      END IF
      NKPTG=NKPT_
      NSPING=NSPIN_
      ALLOCATE(OVLARR(NKPTG,NSPING))
      INITIALIZED=.TRUE.
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE OVERLAP$INIT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE OVERLAP$REPORT(NFIL)  ! MARK: OVERLAP$REPORT
!     **************************************************************************
!     ** REPORT OVERLAP MODULE                                                **
!     ** REQUIRES NO SELECTED OVERLAP                                         **
!     **************************************************************************
      USE OVERLAP_MODULE, ONLY: THIS,NKPTG,NSPING,INITIALIZED,THIS,ADETSUM
      USE MPE_MODULE
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: NFIL
      INTEGER(4) :: NTASKS,THISTASK,RTASK,WTASK
      INTEGER(4) :: IKPT,ISPIN
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      CALL KSMAP$READTASK(RTASK)
      IF(THISTASK.NE.RTASK) RETURN
                          CALL TRACE$PUSH('OVERLAP$REPORT')
      IF(.NOT.INITIALIZED) THEN
        CALL ERROR$MSG('OVERLAP NOT INITIALIZED')
        CALL ERROR$STOP('OVERLAP$REPORT')
      END IF
      WRITE(NFIL,'(A)') ''
      WRITE(NFIL,'(80("#"))')
      WRITE(NFIL,FMT='(A)') 'OVERLAP REPORT'
      WRITE(NFIL,'(80("#"))')
      WRITE(NFIL,'(A12,F14.7)') 'SUM|ADET|^2:',ADETSUM
      WRITE(NFIL,'(A4,X,A5,X,A21,X,A10)') 'IKPT','ISPIN','ADET','|ADET|^2'
      DO IKPT=1,NKPTG
        DO ISPIN=1,NSPING
          CALL OVERLAP$SELECT(IKPT,ISPIN)
          WRITE(NFIL,FMT='(I5,I5,X,(F10.7,SP,F10.7,"I ",S),X,F10.7)') &
     &                                       IKPT,ISPIN,THIS%ADET,ABS(THIS%ADET)**2
          CALL OVERLAP$UNSELECT
        ENDDO
      ENDDO
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE OVERLAP$REPORT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE OVERLAP$K(NB2NOCC,NOCC,KMAT)  ! MARK: OVERLAP$K
!     **************************************************************************
!     ** GET OVERLAP K-MATRIX                                                **
!     ** REQUIRES SELECTED OVERLAP                                           **
!     **************************************************************************
      USE OVERLAP_MODULE, ONLY: THIS,SELECTED
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: NB2NOCC ! NB2-NOCC
      INTEGER(4), INTENT(IN) :: NOCC    ! NOCC
      COMPLEX(8), INTENT(OUT) :: KMAT(NB2NOCC,NOCC)
      COMPLEX(8), ALLOCATABLE :: WORK(:,:)
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO OVERLAP SELECTED')
        CALL ERROR$STOP('OVERLAP$K')
      END IF
      IF(NB2NOCC.NE.THIS%NB2-THIS%NOCC) THEN
        CALL ERROR$MSG('NB2-NOCC MISMATCH')
        CALL ERROR$I4VAL('EXPECTED NB2-NOCC: ',THIS%NB2-THIS%NOCC)
        CALL ERROR$I4VAL('GIVEN NB2-NOCC: ',NB2NOCC)
        CALL ERROR$STOP('OVERLAP$K')
      END IF
      IF(NOCC.NE.THIS%NOCC) THEN
        CALL ERROR$MSG('NOCC MISMATCH')
        CALL ERROR$I4VAL('EXPECTED NOCC: ',THIS%NOCC)
        CALL ERROR$I4VAL('GIVEN NOCC: ',NOCC)
        CALL ERROR$STOP('OVERLAP$K')
      END IF
      IF(.NOT.ALLOCATED(THIS%AINV)) THEN
        ALLOCATE(WORK(NOCC,NOCC))
        CALL OVERLAP$GETC8A('AINV',NOCC*NOCC,WORK)
        DEALLOCATE(WORK)
      END IF
      IF(.NOT.ALLOCATED(THIS%C)) THEN
        ALLOCATE(WORK(NB2NOCC,NOCC))
        CALL OVERLAP$GETC8A('C',NB2NOCC*NOCC,WORK)
        DEALLOCATE(WORK)
      END IF
      ! KMAT=C*AINV (TEST WHAT IS FASTER)
      ! CALL LIB$MATMULC8(NB2NOCC,NOCC,NOCC,THIS%C,THIS%AINV,KMAT)
      KMAT=MATMUL(THIS%C,THIS%AINV)
      RETURN
      END SUBROUTINE OVERLAP$K
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE OVERLAP$L(NB2,NOCC,IOCC,IEMP,L)  ! MARK: OVERLAP$L
!     **************************************************************************
!     ** GET OVERLAP L-MATRIX                                                **
!     ** REQUIRES SELECTED OVERLAP                                           **
!     **************************************************************************
      USE OVERLAP_MODULE, ONLY: THIS,SELECTED
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: NB2
      INTEGER(4), INTENT(IN) :: NOCC
      INTEGER(4), INTENT(IN) :: IOCC
      INTEGER(4), INTENT(IN) :: IEMP
      COMPLEX(8), INTENT(OUT) :: L(NB2-NOCC,NOCC)
      COMPLEX(8), ALLOCATABLE :: U(:)
      COMPLEX(8), ALLOCATABLE :: ASWITCHINV(:,:)
      COMPLEX(8), ALLOCATABLE :: CSWITCH(:,:)
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO OVERLAP SELECTED')
        CALL ERROR$STOP('OVERLAP$L')
      END IF
      ALLOCATE(U(NOCC))
      ALLOCATE(ASWITCHINV(NOCC,NOCC))
      ALLOCATE(CSWITCH(NB2-NOCC,NOCC))
      ! ASWITCH=A WITH ONE COLUMN REPLACED BY ONE IN B
      ! ASWITCH=A+U*B_IEMP
      U=THIS%B(:,IEMP)-THIS%A(:,IOCC)
      ! INVERSE OF ASWITCH USING SHERMAN-MORRISON FORMULA
      CALL LIB$SMFASTINVERTC8('V',NOCC,THIS%AINV,U,IOCC,ASWITCHINV)
      ! CSWITCH=C WITH ONE COLUMN REPLACED BY ONE IN D
      CSWITCH(:,:)=THIS%C(:,:)
      CSWITCH(:,IOCC)=THIS%D(:,IEMP)
      ! L=CSWITCH*ASWITCHINV (TEST WHAT IS FASTER)
      ! CALL LIB$MATMULC8(NB2-NOCC,NOCC,NOCC,CSWITCH,ASWITCHINV,L)
      L=MATMUL(CSWITCH,ASWITCHINV)
      DEALLOCATE(ASWITCHINV)
      DEALLOCATE(CSWITCH)
      RETURN
      END SUBROUTINE OVERLAP$L
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE OVERLAP$H(NB1,NOCC,H)  ! MARK: OVERLAP$H
!     **************************************************************************
!     ** GET OVERLAP H-MATRIX                                                 **
!     ** REQUIRES SELECTED OVERLAP                                            **
!     ** H=AINV*B                                                             **
!     **************************************************************************
      USE OVERLAP_MODULE, ONLY: THIS,SELECTED
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: NB1
      INTEGER(4), INTENT(IN) :: NOCC
      COMPLEX(8), INTENT(OUT) :: H(NOCC,NB1-NOCC)
      COMPLEX(8), ALLOCATABLE :: AINV(:,:)
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO OVERLAP SELECTED')
        CALL ERROR$STOP('OVERLAP$H')
      END IF
      ALLOCATE(AINV(NOCC,NOCC))
      ! SAFEGUARD TO GET AINV
      CALL OVERLAP$GETC8A('AINV',NOCC*NOCC,AINV)
      ! H=AINV*B (TEST WHAT IS FASTER)
      ! CALL LIB$MATMULC8(NOCC,NOCC,NB1-NOCC,AINV,THIS%B,H)
      H=MATMUL(AINV,THIS%B)
      DEALLOCATE(AINV)
      RETURN
      END SUBROUTINE OVERLAP$H
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE OVERLAP$MU(NB1,NB2,NOCC,MU)  ! MARK: OVERLAP$MU
!     **************************************************************************
!     ** GET OVERLAP MU-MATRIX                                                **
!     ** REQUIRES SELECTED OVERLAP                                            **
!     ** MU=D-C*AINV*B                                                        **
!     **************************************************************************
      USE OVERLAP_MODULE, ONLY: THIS,SELECTED
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: NB1
      INTEGER(4), INTENT(IN) :: NB2
      INTEGER(4), INTENT(IN) :: NOCC
      COMPLEX(8), INTENT(OUT) :: MU(NB2-NOCC,NB1-NOCC)
      COMPLEX(8), ALLOCATABLE :: AINV(:,:)
      COMPLEX(8), ALLOCATABLE :: WORK(:,:)
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO OVERLAP SELECTED')
        CALL ERROR$STOP('OVERLAP$MU')
      END IF
      ALLOCATE(AINV(NOCC,NOCC))
      ! SAFEGUARD TO GET AINV
      CALL OVERLAP$GETC8A('AINV',NOCC*NOCC,AINV)
      ! MU=D-C*AINV*B
      MU=MATMUL(THIS%C,MATMUL(AINV,THIS%B))
      MU=THIS%D-MU
      DEALLOCATE(AINV)
      RETURN
      END SUBROUTINE OVERLAP$MU
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE OVERLAP$SELECT(IKPT,ISPIN)  ! MARK: OVERLAP$SELECT
!     **************************************************************************
!     ** SELECT OVERLAP FOR KPOINT AND SPIN                                   **
!     **************************************************************************
      USE OVERLAP_MODULE, ONLY: OVLARR,THIS,SELECTED,NKPTG,NSPING
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: IKPT
      INTEGER(4), INTENT(IN) :: ISPIN
      IF(SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('CANNOT SELECT OVERLAP WHEN ALREADY SELECTED')
        CALL ERROR$STOP('OVERLAP$SELECT')
      END IF
      IF(IKPT.LE.0.OR.IKPT.GT.NKPTG) THEN
        CALL ERROR$MSG('INVALID KPOINT INDEX')
        CALL ERROR$I4VAL('KPOINT INDEX: ',IKPT)
        CALL ERROR$STOP('OVERLAP$SELECT')
      END IF
      IF(ISPIN.LE.0.OR.ISPIN.GT.NSPING) THEN
        CALL ERROR$MSG('INVALID SPIN INDEX')
        CALL ERROR$I4VAL('SPIN INDEX: ',ISPIN)
        CALL ERROR$STOP('OVERLAP$SELECT')
      END IF
      THIS=>OVLARR(IKPT,ISPIN)
      SELECTED=.TRUE.
      RETURN
      END SUBROUTINE OVERLAP$SELECT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE OVERLAP$UNSELECT()  ! MARK: OVERLAP$UNSELECT
!     **************************************************************************
!     ** UNSELECT OVERLAP                                                    **
!     **************************************************************************
      USE OVERLAP_MODULE, ONLY: THIS,SELECTED
      IMPLICIT NONE
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('CANNOT UNSELECT OVERLAP WHEN NOT SELECTED')
        CALL ERROR$STOP('OVERLAP$UNSELECT')
      END IF
      SELECTED=.FALSE.
      NULLIFY(THIS)
      RETURN
      END SUBROUTINE OVERLAP$UNSELECT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE OVERLAP$GETI4(ID,VAL)  ! MARK: OVERLAP$GETI4
!     **************************************************************************
!     ** GET INTEGER VALUE FROM SELECTED OVERLAP                             **
!     ** REQUIRES SELECTED OVERLAP                                           **
!     **************************************************************************
      USE OVERLAP_MODULE, ONLY: THIS,SELECTED,NKPTG,NSPING
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(OUT) :: VAL
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO OVERLAP SELECTED')
        CALL ERROR$STOP('OVERLAP$GETI4')
      END IF
      IF(ID.EQ.'NB1') THEN
        VAL=THIS%NB1
      ELSE IF(ID.EQ.'NB2') THEN
        VAL=THIS%NB2
      ELSE IF(ID.EQ.'NOCC') THEN
        VAL=THIS%NOCC
      ELSE IF(ID.EQ.'NKPT') THEN
        VAL=NKPTG
      ELSE IF(ID.EQ.'NSPIN') THEN
        VAL=NSPING
      ELSE
        CALL ERROR$MSG('OVERLAP GETI4 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('OVERLAP$GETI4')
      END IF
      RETURN
      END SUBROUTINE OVERLAP$GETI4
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE OVERLAP$SETI4(ID,VAL)  ! MARK: OVERLAP$SETI4
!     **************************************************************************
!     ** SET INTEGER VALUE IN SELECTED OVERLAP                               **
!     ** REQUIRES SELECTED OVERLAP                                           **
!     **************************************************************************
      USE OVERLAP_MODULE, ONLY: THIS,SELECTED,NKPTG,NSPING
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: VAL
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO OVERLAP SELECTED')
        CALL ERROR$STOP('OVERLAP$SETI4')
      END IF
      IF(ID.EQ.'NB1') THEN
        IF(THIS%NB1.NE.-1) THEN
          CALL ERROR$MSG('NB1 VALUE CANNOT BE CHANGED')
          CALL ERROR$I4VAL('OLD NB1: ',THIS%NB1)
          CALL ERROR$I4VAL('NEW NB1: ',VAL)
          CALL ERROR$STOP('OVERLAP$SETI4')
        END IF
        THIS%NB1=VAL
      ELSE IF(ID.EQ.'NB2') THEN
        IF(THIS%NB2.NE.-1) THEN
          CALL ERROR$MSG('NB2 VALUE CANNOT BE CHANGED')
          CALL ERROR$I4VAL('OLD NB2: ',THIS%NB2)
          CALL ERROR$I4VAL('NEW NB2: ',VAL)
          CALL ERROR$STOP('OVERLAP$SETI4')
        END IF
        THIS%NB2=VAL
      ELSE IF(ID.EQ.'NOCC') THEN
        IF(THIS%NOCC.NE.-1) THEN
          IF(VAL.NE.THIS%NOCC) THEN
            CALL ERROR$MSG('NOCC VALUE CANNOT BE CHANGED')
            CALL ERROR$I4VAL('OLD NOCC: ',THIS%NOCC)
            CALL ERROR$I4VAL('NEW NOCC: ',VAL)
! ERROR: HACK TO ALLOW NOCC FOR EXCITE TO BE DIFFERENT FROM GROUND
!        JUST USES VALUE DETERMINED FOR GROUND
            RETURN
          END IF
        END IF
        THIS%NOCC=VAL
      ELSE
        CALL ERROR$MSG('OVERLAP SETI4 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('OVERLAP$SETI4')
      END IF
      RETURN
      END SUBROUTINE OVERLAP$SETI4
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE OVERLAP$SETL4(ID,VAL)  ! MARK: OVERLAP$SETL4
!     **************************************************************************
!     ** SET LOGICAL VALUE IN SELECTED OVERLAP                                **
!     ** REQUIRES SELECTED OVERLAP                                           **
!     **************************************************************************
      USE OVERLAP_MODULE, ONLY: THIS,SELECTED
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      LOGICAL(4), INTENT(IN) :: VAL
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO OVERLAP SELECTED')
        CALL ERROR$STOP('OVERLAP$SETL4')
      END IF
      IF(ID.EQ.'TOVERLAP') THEN
        IF(VAL.EQV..FALSE..AND.THIS%TOVERLAP) THEN
          CALL ERROR$MSG('TOVERLAP CANNOT BE SET TO FALSE ONCE TRUE')
          CALL ERROR$L4VAL('TOVERLAP: ',THIS%TOVERLAP)
          CALL ERROR$L4VAL('NEW TOVERLAP: ',VAL)
          CALL ERROR$STOP('OVERLAP$SETL4')
        END IF
        ! SET TOVERLAP
        THIS%TOVERLAP=VAL
      ELSE
        CALL ERROR$MSG('OVERLAP SETL4 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('OVERLAP$SETL4')
      END IF
      RETURN
      END SUBROUTINE OVERLAP$SETL4
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE OVERLAP$GETR8(ID,VAL)  ! MARK: OVERLAP$GETR8
!     **************************************************************************
!     ** GET REAL VALUE FROM SELECTED OVERLAP                                 **
!     **************************************************************************
      USE OVERLAP_MODULE, ONLY: ADETSUM
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      REAL(8), INTENT(OUT) :: VAL
      IF(ID.EQ.'ADETSUM') THEN
        VAL=ADETSUM
      ELSE
        CALL ERROR$MSG('OVERLAP GETR8 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('OVERLAP$GETR8')
      END IF
      RETURN
      END SUBROUTINE OVERLAP$GETR8
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE OVERLAP$SETR8(ID,VAL)  ! MARK: OVERLAP$SETR8
!     **************************************************************************
!     ** SET REAL VALUE IN SELECTED OVERLAP                                   **
!     **************************************************************************
      USE OVERLAP_MODULE, ONLY: ADETSUM
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      REAL(8), INTENT(IN) :: VAL
      IF(ID.EQ.'ADETSUM') THEN
        ADETSUM=VAL
      ELSE
        CALL ERROR$MSG('OVERLAP SETR8 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('OVERLAP$SETR8')
      END IF
      RETURN
      END SUBROUTINE OVERLAP$SETR8
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE OVERLAP$GETR8A(ID,LEN,VAL)  ! MARK: OVERLAP$GETR8A
!     **************************************************************************
!     ** GET REAL VALUE ARRAY FROM SELECTED OVERLAP                           **
!     ** WARNING: WRAPPER LEADS TO SIMULATION$GETR8A FOR ID='S'               **
!     **          AS S IS EASIER TO STORE IN SIMULATION MODULE                **
!     **          REQUIRES NO SIMULATION SELECTED                             **
!     **************************************************************************
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: LEN
      REAL(8), INTENT(OUT) :: VAL(LEN)
      IF(ID.EQ.'S') THEN
        CALL SIMULATION$GETR8A(ID,LEN,VAL)
      ELSE
        CALL ERROR$MSG('OVERLAP GETR8A ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('OVERLAP$GETR8A')
      END IF
      RETURN
      END SUBROUTINE OVERLAP$GETR8A
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE OVERLAP$SETR8A(ID,LEN,VAL)  ! MARK: OVERLAP$SETR8A
!     **************************************************************************
!     ** SET REAL VALUE ARRAY IN SELECTED OVERLAP                             **
!     ** WARNING: WRAPPER LEADS TO SIMULATION$SETR8A FOR ID='S'               **
!     **          AS S IS EASIER TO STORE IN SIMULATION MODULE                **
!     **          REQUIRES NO SIMULATION SELECTED                             **
!     **************************************************************************
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: LEN
      REAL(8), INTENT(IN) :: VAL(LEN)
      IF(ID.EQ.'S') THEN
        CALL SIMULATION$SETR8A(ID,LEN,VAL)
      ELSE
        CALL ERROR$MSG('OVERLAP SETR8A ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('OVERLAP$SETR8A')
      END IF
      RETURN
      END SUBROUTINE OVERLAP$SETR8A
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE OVERLAP$GETC8(ID,VAL)  ! MARK: OVERLAP$GETC8
!     **************************************************************************
!     ** GET COMPLEX VALUE FROM SELECTED OVERLAP                              **
!     ** REQUIRES SELECTED OVERLAP                                            **
!     **************************************************************************
      USE OVERLAP_MODULE, ONLY: THIS,SELECTED
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      COMPLEX(8), INTENT(OUT) :: VAL
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO OVERLAP SELECTED')
        CALL ERROR$STOP('OVERLAP$GETC8')
      END IF
      IF(ID.EQ.'ADET') THEN
        VAL=THIS%ADET
      ELSE
        CALL ERROR$MSG('OVERLAP GETC8 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('OVERLAP$GETC8')
      END IF
      RETURN
      END SUBROUTINE OVERLAP$GETC8
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE OVERLAP$SETC8(ID,VAL)  ! MARK: OVERLAP$SETC8
!     **************************************************************************
!     ** SET COMPLEX VALUE IN SELECTED OVERLAP                                **
!     ** REQUIRES SELECTED OVERLAP                                           **
!     **************************************************************************
      USE OVERLAP_MODULE, ONLY: THIS,SELECTED
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      COMPLEX(8), INTENT(IN) :: VAL
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO OVERLAP SELECTED')
        CALL ERROR$STOP('OVERLAP$SETC8')
      END IF
      IF(ID.EQ.'ADET') THEN
        THIS%ADET=VAL
      ELSE
        CALL ERROR$MSG('OVERLAP SETC8 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('OVERLAP$SETC8')
      END IF
      RETURN
      END SUBROUTINE OVERLAP$SETC8
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE OVERLAP$GETC8A(ID,LEN,VAL)  ! MARK: OVERLAP$GETC8A
!     **************************************************************************
!     ** GET COMPLEX VALUE ARRAY FROM SELECTED OVERLAP                        **
!     ** REQUIRES SELECTED OVERLAP                                            **
!     **************************************************************************
      USE OVERLAP_MODULE, ONLY: THIS,SELECTED
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: LEN
      COMPLEX(8), INTENT(OUT) :: VAL(LEN)
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO OVERLAP SELECTED')
        CALL ERROR$STOP('OVERLAP$GETC8A')
      END IF
      IF(THIS%NB1.EQ.-1.OR.THIS%NB2.EQ.-1) THEN
        CALL ERROR$MSG('OVERLAP DIMENSIONS NOT SET')
        CALL ERROR$I4VAL('NB1: ',THIS%NB1)
        CALL ERROR$I4VAL('NB2: ',THIS%NB2)
        CALL ERROR$STOP('OVERLAP$GETC8A')
      END IF
      IF(ID.EQ.'PW') THEN
        IF(.NOT.ALLOCATED(THIS%PW)) THEN
          CALL ERROR$MSG('PW NOT ALLOCATED')
          CALL ERROR$STOP('OVERLAP$GETC8A')
        END IF
        IF(LEN.NE.THIS%NB1*THIS%NB2) THEN
          CALL ERROR$MSG('LEN MUST BE EQUAL TO NB1*NB2')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$I4VAL('NB1: ',THIS%NB1)
          CALL ERROR$I4VAL('NB2: ',THIS%NB2)
          CALL ERROR$CHVAL('ID: ',ID)
          CALL ERROR$STOP('OVERLAP$GETC8A')
        END IF
        VAL(:)=RESHAPE(THIS%PW,(/THIS%NB2*THIS%NB1/))
      ELSE IF(ID.EQ.'AUG') THEN
        IF(.NOT.ALLOCATED(THIS%AUG)) THEN
          CALL ERROR$MSG('AUG NOT ALLOCATED')
          CALL ERROR$STOP('OVERLAP$GETC8A')
        END IF
        IF(LEN.NE.THIS%NB2*THIS%NB1) THEN
          CALL ERROR$MSG('LEN MUST BE EQUAL TO NB1*NB2')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$I4VAL('NB1: ',THIS%NB1)
          CALL ERROR$I4VAL('NB2: ',THIS%NB2)
          CALL ERROR$CHVAL('ID: ',ID)
          CALL ERROR$STOP('OVERLAP$GETC8A')
        END IF
        VAL(:)=RESHAPE(THIS%AUG,(/THIS%NB2*THIS%NB1/))
      ELSE IF(ID.EQ.'A') THEN
        CALL CHECKNOCC
        IF(.NOT.ALLOCATED(THIS%A)) THEN
          IF(THIS%TOVERLAP) THEN
            ALLOCATE(THIS%A(THIS%NOCC,THIS%NOCC))
            ! CALCULATE A FROM PW AND AUG
            THIS%A(:,:)=THIS%PW(1:THIS%NOCC,1:THIS%NOCC) &
     &                  +THIS%AUG(1:THIS%NOCC,1:THIS%NOCC)
          ELSE
            CALL ERROR$MSG('A NOT ALLOCATED, OVERLAP NOT CALCULATED YET')
            CALL ERROR$STOP('OVERLAP$GETC8A')
          END IF
        END IF
        IF(LEN.NE.THIS%NOCC*THIS%NOCC) THEN
          CALL ERROR$MSG('LEN MUST BE EQUAL TO NOCC*NOCC')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$I4VAL('NOCC: ',THIS%NOCC)
          CALL ERROR$CHVAL('ID: ',ID)
          CALL ERROR$STOP('OVERLAP$GETC8A')
        END IF
        VAL(:)=RESHAPE(THIS%A,(/THIS%NOCC*THIS%NOCC/))
      ELSE IF(ID.EQ.'B') THEN
        CALL CHECKNOCC
        IF(.NOT.ALLOCATED(THIS%B)) THEN
          IF(THIS%TOVERLAP) THEN
            ALLOCATE(THIS%B(THIS%NOCC,THIS%NB1-THIS%NOCC))
            ! CALCULATE B FROM PW AND AUG
            THIS%B(:,:)=THIS%PW(1:THIS%NOCC,THIS%NOCC+1:THIS%NB1) &
     &                 +THIS%AUG(1:THIS%NOCC,THIS%NOCC+1:THIS%NB1)
          ELSE
            CALL ERROR$MSG('B NOT ALLOCATED, OVERLAP NOT CALCULATED YET')
            CALL ERROR$STOP('OVERLAP$GETC8A')
          END IF
        END IF
        IF(LEN.NE.THIS%NOCC*(THIS%NB1-THIS%NOCC)) THEN
          CALL ERROR$MSG('LEN MUST BE EQUAL TO NOCC*(NB1-NOCC)')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$I4VAL('NOCC: ',THIS%NOCC)
          CALL ERROR$I4VAL('NB1: ',THIS%NB1)
          CALL ERROR$CHVAL('ID: ',ID)
          CALL ERROR$STOP('OVERLAP$GETC8A')
        END IF
        VAL(:)=RESHAPE(THIS%B,(/THIS%NOCC*(THIS%NB1-THIS%NOCC)/))
      ELSE IF(ID.EQ.'C') THEN
        CALL CHECKNOCC
        IF(.NOT.ALLOCATED(THIS%C)) THEN
          IF(THIS%TOVERLAP) THEN
            ALLOCATE(THIS%C(THIS%NB2-THIS%NOCC,THIS%NOCC))
            ! CALCULATE C FROM PW AND AUG
            THIS%C(:,:)=THIS%PW(THIS%NOCC+1:THIS%NB2,1:THIS%NOCC) &
     &                 +THIS%AUG(THIS%NOCC+1:THIS%NB2,1:THIS%NOCC)
          ELSE
            CALL ERROR$MSG('C NOT ALLOCATED, OVERLAP NOT CALCULATED YET')
            CALL ERROR$STOP('OVERLAP$GETC8A')
          END IF
        END IF
        IF(LEN.NE.(THIS%NB2-THIS%NOCC)*THIS%NOCC) THEN
          CALL ERROR$MSG('LEN MUST BE EQUAL TO (NB2-NOCC)*NOCC')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$I4VAL('NB2: ',THIS%NB2)
          CALL ERROR$I4VAL('NOCC: ',THIS%NOCC)
          CALL ERROR$CHVAL('ID: ',ID)
          CALL ERROR$STOP('OVERLAP$GETC8A')
        END IF
        VAL(:)=RESHAPE(THIS%C,(/(THIS%NB2-THIS%NOCC)*THIS%NOCC/))
      ELSE IF(ID.EQ.'D') THEN
        CALL CHECKNOCC
        IF(.NOT.ALLOCATED(THIS%D)) THEN
          IF(THIS%TOVERLAP) THEN
            ALLOCATE(THIS%D(THIS%NB2-THIS%NOCC,THIS%NB1-THIS%NOCC))
            ! CALCULATE D FROM PW AND AUG
            THIS%D(:,:)=THIS%PW(THIS%NOCC+1:THIS%NB2,THIS%NOCC+1:THIS%NB1) &
     &                 +THIS%AUG(THIS%NOCC+1:THIS%NB2,THIS%NOCC+1:THIS%NB1)
          ELSE
            CALL ERROR$MSG('D NOT ALLOCATED, OVERLAP NOT CALCULATED YET')
            CALL ERROR$STOP('OVERLAP$GETC8A')
          END IF
        END IF
        IF(LEN.NE.(THIS%NB2-THIS%NOCC)*(THIS%NB1-THIS%NOCC)) THEN
          CALL ERROR$MSG('LEN MUST BE EQUAL TO (NB2-NOCC)*(NB1-NOCC)')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$I4VAL('NB2: ',THIS%NB2)
          CALL ERROR$I4VAL('NB1: ',THIS%NB1)
          CALL ERROR$I4VAL('NOCC: ',THIS%NOCC)
          CALL ERROR$CHVAL('ID: ',ID)
          CALL ERROR$STOP('OVERLAP$GETC8A')
        END IF
        VAL(:)=RESHAPE(THIS%D,(/(THIS%NB2-THIS%NOCC)*(THIS%NB1-THIS%NOCC)/))
      ELSE IF(ID.EQ.'AINV') THEN
        CALL CHECKNOCC
        IF(.NOT.ALLOCATED(THIS%AINV)) THEN
          IF(.NOT.ALLOCATED(THIS%A)) THEN
            IF(THIS%TOVERLAP) THEN
              ALLOCATE(THIS%A(THIS%NOCC,THIS%NOCC))
              ! CALCULATE A FROM PW AND AUG
              THIS%A(:,:)=THIS%PW(1:THIS%NOCC,1:THIS%NOCC) &
     &                    +THIS%AUG(1:THIS%NOCC,1:THIS%NOCC)
            ELSE
              CALL ERROR$MSG('A NOT ALLOCATED, OVERLAP NOT CALCULATED YET')
              CALL ERROR$MSG('CANNOT CALCULATE AINV')
              CALL ERROR$STOP('OVERLAP$GETC8A')
            END IF
          END IF
          ALLOCATE(THIS%AINV(THIS%NOCC,THIS%NOCC))
          ! CALCULATE AINV FROM A
          CALL LIB$INVERTC8(THIS%NOCC,THIS%A,THIS%AINV)
        END IF
        IF(LEN.NE.THIS%NOCC*THIS%NOCC) THEN
          CALL ERROR$MSG('LEN MUST BE EQUAL TO NOCC*NOCC')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$I4VAL('NOCC: ',THIS%NOCC)
          CALL ERROR$CHVAL('ID: ',ID)
          CALL ERROR$STOP('OVERLAP$GETC8A')
        END IF
        VAL(:)=RESHAPE(THIS%AINV,(/THIS%NOCC*THIS%NOCC/))
      ELSE IF(ID.EQ.'DIPOLE') THEN
        IF(.NOT.ALLOCATED(THIS%DIPOLE)) THEN
          CALL ERROR$MSG('DIPOLE NOT ALLOCATED')
          CALL ERROR$STOP('OVERLAP$GETC8A')
        END IF
        IF(LEN.NE.3*THIS%NB2) THEN
          CALL ERROR$MSG('LEN MUST BE EQUAL TO 3*NB2')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$I4VAL('NB2: ',THIS%NB2)
          CALL ERROR$CHVAL('ID: ',ID)
          CALL ERROR$STOP('OVERLAP$GETC8A')
        END IF
        VAL(:)=RESHAPE(THIS%DIPOLE,(/3*THIS%NB2/))
      ELSE
        CALL ERROR$MSG('OVERLAP GETC8A ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('OVERLAP$GETC8A')
      END IF
      CONTAINS
        SUBROUTINE CHECKNOCC
        IF(THIS%NOCC.EQ.-1) THEN
          CALL ERROR$MSG('NOCC NOT SET')
          CALL ERROR$STOP('OVERLAP$GETC8A')
        END IF
        RETURN
        END SUBROUTINE CHECKNOCC
      END SUBROUTINE OVERLAP$GETC8A
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE OVERLAP$SETC8A(ID,LEN,VAL)  ! MARK: OVERLAP$SETC8A
!     **************************************************************************
!     ** SET COMPLEX VALUE ARRAY IN SELECTED OVERLAP                          **
!     ** REQUIRES SELECTED OVERLAP                                           **
!     **************************************************************************
      USE OVERLAP_MODULE, ONLY: THIS,SELECTED
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: LEN
      COMPLEX(8), INTENT(IN) :: VAL(LEN)
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO OVERLAP SELECTED')
        CALL ERROR$STOP('OVERLAP$SETC8A')
      END IF
      IF(THIS%NB1.EQ.-1.OR.THIS%NB2.EQ.-1) THEN
        CALL ERROR$MSG('OVERLAP DIMENSIONS NOT SET')
        CALL ERROR$I4VAL('NB1: ',THIS%NB1)
        CALL ERROR$I4VAL('NB2: ',THIS%NB2)
        CALL ERROR$STOP('OVERLAP$SETC8A')
      END IF
      IF(ID.EQ.'PW') THEN
        IF(.NOT.ALLOCATED(THIS%PW)) THEN
          ALLOCATE(THIS%PW(THIS%NB2,THIS%NB1))
        END IF
        IF(LEN.NE.THIS%NB1*THIS%NB2) THEN
          CALL ERROR$MSG('LEN MUST BE EQUAL TO NB1*NB2')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$I4VAL('NB1: ',THIS%NB1)
          CALL ERROR$I4VAL('NB2: ',THIS%NB2)
          CALL ERROR$CHVAL('ID: ',ID)
          CALL ERROR$STOP('OVERLAP$SETC8A')
        END IF
        THIS%PW=RESHAPE(VAL,(/THIS%NB2,THIS%NB1/))
      ELSE IF(ID.EQ.'AUG') THEN
        IF(.NOT.ALLOCATED(THIS%AUG)) THEN
          ALLOCATE(THIS%AUG(THIS%NB2,THIS%NB1))
        END IF
        IF(LEN.NE.THIS%NB2*THIS%NB1) THEN
          CALL ERROR$MSG('LEN MUST BE EQUAL TO NB1*NB2')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$I4VAL('NB1: ',THIS%NB1)
          CALL ERROR$I4VAL('NB2: ',THIS%NB2)
          CALL ERROR$CHVAL('ID: ',ID)
          CALL ERROR$STOP('OVERLAP$SETC8A')
        END IF
        THIS%AUG=RESHAPE(VAL,(/THIS%NB2,THIS%NB1/))
      ELSE IF(ID.EQ.'DIPOLE') THEN
        IF(THIS%NB2.EQ.-1) THEN
          CALL ERROR$MSG('NB2 NOT SET')
          CALL ERROR$STOP('OVERLAP$SETC8A')
        END IF
        IF(.NOT.ALLOCATED(THIS%DIPOLE)) THEN
          ALLOCATE(THIS%DIPOLE(3,THIS%NB2))
        END IF
        IF(LEN.NE.3*THIS%NB2) THEN
          CALL ERROR$MSG('LEN MUST BE EQUAL TO 3*NB2')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$I4VAL('NB2: ',THIS%NB2)
          CALL ERROR$CHVAL('ID: ',ID)
          CALL ERROR$STOP('OVERLAP$SETC8A')
        END IF
        THIS%DIPOLE(:,:)=RESHAPE(VAL,(/3,THIS%NB2/))
      ELSE
        CALL ERROR$MSG('OVERLAP SETC8A ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('OVERLAP$SETC8A')
      END IF
      RETURN
      END SUBROUTINE OVERLAP$SETC8A
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE OVERLAP_WRITEOVERLAP(NFIL)  ! MARK: OVERLAP_WRITEOVERLAP
!     **************************************************************************
!     ** WRITE OVERLAP MODULE TO OVERLAP FILE WHICH SERVES AS A RESTART       **
!     ** FILE FOR THE SIMULATION                                              **
!     ** REQUIRES NO SELECTED OVERLAP                                         **
!     **************************************************************************
      USE OVERLAP_MODULE, ONLY: INITIALIZED,SELECTED,THIS,NKPTG,NSPING
      USE MPE_MODULE
      USE STRINGS_MODULE
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: NFIL
      INTEGER(4) :: NTASKS,THISTASK,RTASK,WTASK
      COMPLEX(8), ALLOCATABLE :: PW(:,:)
      COMPLEX(8), ALLOCATABLE :: AUG(:,:)
      COMPLEX(8), ALLOCATABLE :: DIPOLE(:,:)
      INTEGER(4) :: NB1,NB2,NOCC
      INTEGER(4) :: IKPT,ISPIN
      CHARACTER(7) :: KEY
                          CALL TRACE$PUSH('OVERLAP_WRITEOVERLAP')
      IF(.NOT.INITIALIZED) THEN
        CALL ERROR$MSG('OVERLAP NOT INITIALIZED')
        CALL ERROR$STOP('OVERLAP_WRITEOVERLAP')
      END IF
      IF(SELECTED) THEN
        CALL ERROR$MSG('OVERLAP WRITEOVERLAP CANNOT BE CALLED WHEN OVERLAP IS SELECTED')
        CALL ERROR$STOP('OVERLAP_WRITEOVERLAP')
      END IF
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      CALL KSMAP$READTASK(RTASK)

      KEY=+'OVERLAP'
      IF(THISTASK.EQ.RTASK) WRITE(NFIL) KEY

      ! NKPTG,NSPING
      IF(THISTASK.EQ.RTASK) WRITE(NFIL) NKPTG,NSPING

      DO IKPT=1,NKPTG
        DO ISPIN=1,NSPING
          CALL KSMAP$WORKTASK(IKPT,ISPIN,WTASK)
          ! ONLY LET TASK WITH DATA AND READ TASK CONTINUE ON
          IF(THISTASK.NE.RTASK.AND.THISTASK.NE.WTASK) CYCLE
          CALL OVERLAP$SELECT(IKPT,ISPIN)
          ! GET INTEGER DATA ON WORK TASK
          IF(THISTASK.EQ.WTASK) THEN
            IF(THIS%TOVERLAP.EQV..FALSE.) THEN
              CALL ERROR$MSG('OVERLAP NOT CALCULATED YET')
              CALL ERROR$I4VAL('IKPT: ',IKPT)
              CALL ERROR$I4VAL('ISPIN: ',ISPIN)
              CALL ERROR$STOP('OVERLAP_WRITEOVERLAP')
            END IF
            NB1=THIS%NB1
            NB2=THIS%NB2
            NOCC=THIS%NOCC
          END IF
          ! SEND INTEGER DATA TO READ TASK
          CALL MPE$SENDRECEIVE('~',WTASK,RTASK,NB1)
          CALL MPE$SENDRECEIVE('~',WTASK,RTASK,NB2)
          CALL MPE$SENDRECEIVE('~',WTASK,RTASK,NOCC)
          ALLOCATE(PW(NB2,NB1))
          ALLOCATE(AUG(NB2,NB1))
          ALLOCATE(DIPOLE(3,NB2))
          ! GET MATRIX DATA ON WORK TASK
          IF(THISTASK.EQ.WTASK) THEN
            PW(:,:)=THIS%PW(:,:)
            AUG(:,:)=THIS%AUG(:,:)
            DIPOLE(:,:)=THIS%DIPOLE(:,:)
          END IF
          ! SEND MATRIX DATA TO READ TASK
          CALL MPE$SENDRECEIVE('~',WTASK,RTASK,PW)
          CALL MPE$SENDRECEIVE('~',WTASK,RTASK,AUG)
          CALL MPE$SENDRECEIVE('~',WTASK,RTASK,DIPOLE)
          IF(THISTASK.EQ.RTASK) THEN
            ! NB1,NB2,NOCC
            WRITE(NFIL)NB1,NB2,NOCC
            ! PW,AUG,DIPOLE
            WRITE(NFIL)PW,AUG,DIPOLE
          END IF
          DEALLOCATE(PW)
          DEALLOCATE(AUG)
          DEALLOCATE(DIPOLE)
          CALL OVERLAP$UNSELECT
        ENDDO
      ENDDO
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE OVERLAP_WRITEOVERLAP
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE OVERLAP_READOVERLAP(NFIL)  ! MARK: OVERLAP_READOVERLAP
!     **************************************************************************
!     ** READ OVERLAP MODULE FROM OVERLAP FILE WHICH SERVES AS A RESTART      **
!     ** FILE FOR THE SIMULATION                                              **
!     ** REQUIRES NO SELECTED OVERLAP                                         **
!     **************************************************************************
      USE OVERLAP_MODULE, ONLY: SELECTED,INITIALIZED
      USE MPE_MODULE
      USE STRINGS_MODULE
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: NFIL
      INTEGER(4) :: NTASKS,THISTASK,RTASK,WTASK
      INTEGER(4) :: NKPT,NSPIN
      INTEGER(4) :: IKPT,ISPIN
      INTEGER(4) :: NB1,NB2,NOCC
      COMPLEX(8), ALLOCATABLE :: PW(:,:)
      COMPLEX(8), ALLOCATABLE :: AUG(:,:)
      COMPLEX(8), ALLOCATABLE :: DIPOLE(:,:)
      CHARACTER(7) :: KEY
                          CALL TRACE$PUSH('OVERLAP_READOVERLAP')
      IF(INITIALIZED) THEN
        CALL ERROR$MSG('OVERLAP ALREADY INITIALIZED')
        CALL ERROR$STOP('OVERLAP_READOVERLAP')
      END IF
      IF(SELECTED) THEN
        CALL ERROR$MSG('OVERLAP READOVERLAP CANNOT BE CALLED WHEN OVERLAP IS SELECTED')
        CALL ERROR$STOP('OVERLAP_READOVERLAP')
      END IF
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      CALL KSMAP$READTASK(RTASK)
      IF(THISTASK.EQ.RTASK) THEN
        READ(NFIL) KEY
        IF(KEY.NE.+'OVERLAP') THEN
          CALL ERROR$MSG('OVERLAP FILE CORRUPTED')
          CALL ERROR$CHVAL('KEY: ',KEY)
          CALL ERROR$STOP('OVERLAP_READOVERLAP')
        END IF
      END IF
      ! NKPT,NSPIN
      IF(THISTASK.EQ.RTASK) READ(NFIL) NKPT,NSPIN
      CALL MPE$BROADCAST('~',RTASK,NKPT)
      CALL MPE$BROADCAST('~',RTASK,NSPIN)
      CALL OVERLAP$INIT(NKPT,NSPIN)

      DO IKPT=1,NKPT
        DO ISPIN=1,NSPIN
          CALL KSMAP$WORKTASK(IKPT,ISPIN,WTASK)
          ! ONLY LET WORKTASK WITH DATA AND READ TASK CONTINUE ON
          IF(THISTASK.NE.RTASK.AND.THISTASK.NE.WTASK) CYCLE
          IF(THISTASK.EQ.RTASK) THEN
            READ(NFIL) NB1,NB2,NOCC
          END IF
          CALL MPE$SENDRECEIVE('~',RTASK,WTASK,NB1)
          CALL MPE$SENDRECEIVE('~',RTASK,WTASK,NB2)
          CALL MPE$SENDRECEIVE('~',RTASK,WTASK,NOCC)
          CALL OVERLAP$SELECT(IKPT,ISPIN)
          CALL OVERLAP$SETI4('NB1',NB1)
          CALL OVERLAP$SETI4('NB2',NB2)
          CALL OVERLAP$SETI4('NOCC',NOCC)
          ALLOCATE(PW(NB2,NB1))
          ALLOCATE(AUG(NB2,NB1))
          ALLOCATE(DIPOLE(3,NB2))
          IF(THISTASK.EQ.RTASK) THEN
            READ(NFIL) PW,AUG,DIPOLE
          END IF
          CALL MPE$SENDRECEIVE('~',RTASK,WTASK,PW)
          CALL MPE$SENDRECEIVE('~',RTASK,WTASK,AUG)
          CALL MPE$SENDRECEIVE('~',RTASK,WTASK,DIPOLE)
          IF(THISTASK.EQ.WTASK) THEN
            ! SET PW,AUG,DIPOLE
            CALL OVERLAP$SETC8A('PW',NB2*NB1,PW)
            CALL OVERLAP$SETC8A('AUG',NB2*NB1,AUG)
            CALL OVERLAP$SETC8A('DIPOLE',3*NB2,DIPOLE)
            ! SET OVERLAP CALCULATED
            CALL OVERLAP$SETL4('TOVERLAP',.TRUE.)
          END IF
          DEALLOCATE(PW)
          DEALLOCATE(AUG)
          DEALLOCATE(DIPOLE)
          CALL OVERLAP$UNSELECT
        ENDDO
      ENDDO
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE OVERLAP_READOVERLAP
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XRAY$READSIMULATIONS  ! MARK: XRAY$READSIMULATIONS
!     **************************************************************************
!     ** READ SIMULATION FILES IN PARALLEL AND CALCULATE PLANE WAVE OVERLAP   **
!     ** ON THE FLY.                                                          **
!     **************************************************************************
      USE MPE_MODULE
      IMPLICIT NONE
      ! CHANGING THIS WILL LIKELY BREAK THINGS
      INTEGER(4), PARAMETER :: NSIM=2
      LOGICAL(4), PARAMETER :: TPR=.TRUE.
      LOGICAL(4) :: TOVERLAP
      INTEGER(4) :: NFIL(2)
      CHARACTER(6) :: ID
      INTEGER(4) :: NAT,NSP,NKPT,NSPIN,NDIM,LNXX
      INTEGER(4) :: NPRO(NSIM)
      CHARACTER(6) :: FLAG
      INTEGER(4), ALLOCATABLE :: LNX(:)  ! (NSP)
      INTEGER(4), ALLOCATABLE :: LOX(:,:)  ! (LNXX,NSP)
      INTEGER(4) :: NKDIV(3)
      INTEGER(4) :: ISHIFT(3)
      REAL(8) :: RNTOT
      REAL(8) :: NEL
      REAL(8) :: EDFT
      INTEGER(4) :: ILOGICAL
      LOGICAL(4) :: TINV
      INTEGER(4) :: SPACEGROUP
      LOGICAL(4) :: TSHIFT
      REAL(8), ALLOCATABLE :: R(:,:)  ! (3,NAT)
      CHARACTER(16), ALLOCATABLE :: ATOMID(:)  ! (NAT)
      INTEGER(4), ALLOCATABLE :: ISPECIES(:)  ! (NAT)
      REAL(8) :: RBAS(3,3)
      REAL(8) :: VCELL
      INTEGER(4) :: GID
      CHARACTER(8) :: GRIDTYPE
      INTEGER(4) :: NR
      REAL(8) :: DEX
      REAL(8) :: R1
      REAL(8) :: ECORE
      REAL(8), ALLOCATABLE :: PSPHI(:,:)  ! (NR,LNX)
      REAL(8), ALLOCATABLE :: AEPHI(:,:)  ! (NR,LNX)
      INTEGER(4) :: NBATOM
      INTEGER(4), ALLOCATABLE :: LATOM(:)  ! (NBATOM)
      REAL(8), ALLOCATABLE :: AEPSI(:,:)  ! (NR,NBATOM)
      INTEGER(4) :: NBX
      INTEGER(4) :: NKPT_
      INTEGER(4) :: NSPIN_
      REAL(8), ALLOCATABLE :: OCC(:,:,:)  ! (NMX,NKPT_,NSPIN_)
      REAL(8), ALLOCATABLE :: XK(:,:)  ! (3,NKPT_)
      REAL(8), ALLOCATABLE :: WKPT(:)  ! (NKPT_)
      CHARACTER(8) :: KEY(NSIM)
      INTEGER(4) :: NGG(NSIM)
      INTEGER(4) :: NDIM_(NSIM)
      INTEGER(4) :: NB(NSIM)
      LOGICAL(4) :: TSUPER(NSIM)

      INTEGER(4), ALLOCATABLE :: IGVEC(:,:,:) ! (NSIM,3,NGG)
      REAL(8) :: XK_(NSIM,3)
      COMPLEX(8), ALLOCATABLE :: PSIK1(:,:,:) ! (NGG,NDIM,NB)
      COMPLEX(8), ALLOCATABLE :: PSIK2(:,:,:) ! (NGG,NDIM,NB)
      COMPLEX(8), ALLOCATABLE :: PROJ1(:,:,:) ! (NDIM,NB,NPRO)
      COMPLEX(8), ALLOCATABLE :: PROJ2(:,:,:) ! (NDIM,NB,NPRO)
      REAL(8), ALLOCATABLE :: EIG1(:) ! (NB)
      REAL(8), ALLOCATABLE :: EIG2(:) ! (NB)

      COMPLEX(8), ALLOCATABLE :: PW(:,:) ! (NB2,NB1)

      INTEGER(4) :: ISIM
      INTEGER(4) :: ISP
      INTEGER(4) :: IKPT
      INTEGER(4) :: ISPIN
      INTEGER(4) :: IB1
      INTEGER(4) :: IB2
      INTEGER(4) :: NTASKS,THISTASK,RTASK,WTASK
      INTEGER(4), ALLOCATABLE :: WTASKSKPT(:) ! (NSPING)
      CALL XCNTL$GETL4('TOVERLAP',TOVERLAP)
      IF(TOVERLAP) RETURN
                          CALL TRACE$PUSH('XRAY$READSIMULATIONS')
                          CALL TIMING$CLOCKON('XRAY$READSIMULATIONS')
      CALL MPE$QUERY('~',NTASKS,THISTASK)

      DO ISIM=1,NSIM
        CALL SIMULATION$ISELECT(ISIM)
        ! ID AND FILE MUST HAVE BEEN SET BEFORE
        CALL SIMULATION$GETCH('ID',ID)
        IF(THISTASK.EQ.1) THEN
          IF(TPR) CALL TRACE$PASS('READING GENERAL QUANTITIES')
          CALL FILEHANDLER$UNIT(ID,NFIL(ISIM))
          REWIND(NFIL(ISIM))
          ! ======================================================================
          ! == READ GENERAL QUANTATIES                                          ==
          ! ======================================================================
          ! NAT,NSP,NKPT,NSPIN,NDIM,NPRO,LNXX,FLAG
          READ(NFIL(ISIM))NAT,NSP,NKPT,NSPIN,NDIM,NPRO(ISIM),LNXX,FLAG
        END IF
        CALL MPE$BROADCAST('~',1,NAT)
        CALL MPE$BROADCAST('~',1,NSP)
        CALL MPE$BROADCAST('~',1,NKPT)
        CALL MPE$BROADCAST('~',1,NSPIN)
        CALL MPE$BROADCAST('~',1,NDIM)
        CALL MPE$BROADCAST('~',1,NPRO(ISIM))
        CALL MPE$BROADCAST('~',1,LNXX)
        CALL MPE$BROADCAST('~',1,FLAG)
        CALL SIMULATION$INIT(NAT,NSP,NKPT,NSPIN,NDIM,NPRO(ISIM),LNXX,FLAG)
        ! DISTRIBUTE WORKLOAD FOR K-POINT AND SPIN LOOPS WHILE READING
        CALL KSMAP$INIT(NKPT,NSPIN)
        CALL KSMAP$READTASK(RTASK)

        ALLOCATE(LNX(NSP))
        ALLOCATE(LOX(LNXX,NSP))
        IF(THISTASK.EQ.RTASK) THEN
          ! LNX(NSP),LOX(LNXX,NSP)
          READ(NFIL(ISIM))LNX,LOX
          ! NKDIV(3),ISHIFT(3),RNTOT,NEL,EDFT,ILOGICAL
          READ(NFIL(ISIM))NKDIV,ISHIFT,RNTOT,NEL,EDFT,ILOGICAL
          TINV=.FALSE.
          IF(ILOGICAL.EQ.1) TINV=.TRUE.
          ! SPACEGROUP,TSHIFT
          READ(NFIL(ISIM))SPACEGROUP,ILOGICAL
          TSHIFT=.FALSE.
          IF(ILOGICAL.EQ.1) TSHIFT=.TRUE.
        END IF
        CALL MPE$BROADCAST('~',RTASK,LNX)
        CALL MPE$BROADCAST('~',RTASK,LOX)
        CALL MPE$BROADCAST('~',RTASK,NKDIV)
        CALL MPE$BROADCAST('~',RTASK,ISHIFT)
        CALL MPE$BROADCAST('~',RTASK,RNTOT)
        CALL MPE$BROADCAST('~',RTASK,NEL)
        CALL MPE$BROADCAST('~',RTASK,EDFT)
        CALL MPE$BROADCAST('~',RTASK,TINV)
        CALL MPE$BROADCAST('~',RTASK,SPACEGROUP)
        CALL MPE$BROADCAST('~',RTASK,TSHIFT)
        CALL SIMULATION$SETI4A('LNX',NSP,LNX)
        CALL SIMULATION$SETI4A('LOX',LNXX*NSP,LOX)
        CALL SIMULATION$SETI4A('NKDIV',3,NKDIV)
        CALL SIMULATION$SETI4A('ISHIFT',3,ISHIFT)
        CALL SIMULATION$SETR8('RNTOT',RNTOT)
        CALL SIMULATION$SETR8('NEL',NEL)
        CALL SIMULATION$SETR8('EDFT',EDFT)
        CALL SIMULATION$SETL4('TINV',TINV)
        CALL SIMULATION$SETI4('SPACEGROUP',SPACEGROUP)
        CALL SIMULATION$SETL4('TSHIFT',TSHIFT)
        ! ======================================================================
        ! ==  READ ATOMIC STRUCTURE                                           ==
        ! ======================================================================
        ALLOCATE(R(3,NAT))
        ALLOCATE(ATOMID(NAT))
        ALLOCATE(ISPECIES(NAT))
        IF(THISTASK.EQ.RTASK) THEN
          IF(TPR) CALL TRACE$PASS('READING ATOMIC STRUCTURE')
          ! RBAS(3,3),R(3,NAT),ATOMID(NAT),ISPECIES(NAT)
          READ(NFIL(ISIM))RBAS,R,ATOMID,ISPECIES
        END IF
        CALL MPE$BROADCAST('~',RTASK,RBAS)
        CALL MPE$BROADCAST('~',RTASK,R)
        CALL MPE$BROADCAST('~',RTASK,ATOMID)
        CALL MPE$BROADCAST('~',RTASK,ISPECIES)
        CALL SIMULATION$SETR8A('RBAS',9,RBAS)
        CALL SIMULATION$SETR8A('R',3*NAT,R)
        CALL SIMULATION$SETCHA('ATOMID',NAT,ATOMID)
        CALL SIMULATION$SETI4A('ISPECIES',NAT,ISPECIES)
        CALL SIMULATION$GETR8('VCELL',VCELL)
        ! ======================================================================
        ! ==  ELEMENT SPECIFIC QUANTITIES                                     ==
        ! ======================================================================
        CALL XSETUP$INIT(ISIM,NSP)
        CALL XSETUP$ISELECT(ISIM)
        DO ISP=1,NSP
          IF(THISTASK.EQ.RTASK) THEN
            IF(TPR) CALL TRACE$PASS('READING ELEMENT SPECIFIC QUANTITIES')
            ! GRIDTYPE,NR,DEX,R1
            READ(NFIL(ISIM))GRIDTYPE,NR,DEX,R1
            ! ECORE
            READ(NFIL(ISIM))ECORE
          END IF
          CALL MPE$BROADCAST('~',RTASK,GRIDTYPE)
          CALL MPE$BROADCAST('~',RTASK,NR)
          CALL MPE$BROADCAST('~',RTASK,DEX)
          CALL MPE$BROADCAST('~',RTASK,R1)
          CALL MPE$BROADCAST('~',RTASK,ECORE)
          CALL RADIAL$NEW(GRIDTYPE,GID)
          CALL RADIAL$SETI4(GID,'NR',NR)
          CALL RADIAL$SETR8(GID,'DEX',DEX)
          CALL RADIAL$SETR8(GID,'R1',R1)
          ALLOCATE(PSPHI(NR,LNX(ISP)))
          ALLOCATE(AEPHI(NR,LNX(ISP)))
          IF(THISTASK.EQ.RTASK) THEN
            ! PSPHI(NR,LNX(ISP))
            READ(NFIL(ISIM))PSPHI
            ! AEPHI(NR,LNX(ISP))
            READ(NFIL(ISIM))AEPHI
            ! NBATOM
            READ(NFIL(ISIM))NBATOM
          END IF
          CALL MPE$BROADCAST('~',RTASK,PSPHI)
          CALL MPE$BROADCAST('~',RTASK,AEPHI)
          CALL MPE$BROADCAST('~',RTASK,NBATOM)
          ALLOCATE(LATOM(NBATOM))
          ALLOCATE(AEPSI(NR,NBATOM))
          IF(THISTASK.EQ.RTASK) THEN
            ! LATOM(NBATOM)
            READ(NFIL(ISIM))LATOM
            ! AEPSI(NR,NBATOM)
            READ(NFIL(ISIM))AEPSI
          END IF
          CALL MPE$BROADCAST('~',RTASK,LATOM)
          CALL MPE$BROADCAST('~',RTASK,AEPSI)
          CALL XSETUP$NEW(ISP,GID,ECORE,LNXX,LNX(ISP),LOX(:,ISP),NBATOM)
          CALL XSETUP$SETR8A('PSPHI',ISP,NR*LNX(ISP),PSPHI)
          CALL XSETUP$SETR8A('AEPHI',ISP,NR*LNX(ISP),AEPHI)
          CALL XSETUP$SETI4A('LATOM',ISP,NBATOM,LATOM)
          CALL XSETUP$SETR8A('AEPSI',ISP,NR*NBATOM,AEPSI)
          DEALLOCATE(PSPHI)
          DEALLOCATE(AEPHI)
          DEALLOCATE(LATOM)
          DEALLOCATE(AEPSI)
        ENDDO ! END ISP
        ! ======================================================================
        ! ==  POPULATE BRILLOUIN MODULE                                       ==
        ! ======================================================================
        CALL BRILLOUIN$MSHNOSYM(TINV,RBAS,NKDIV,ISHIFT)
        ! ======================================================================
        ! ==  OCCUPATIONS AND K-POINTS AND THEIR WEIGHTS                      ==
        ! ======================================================================
        IF(THISTASK.EQ.RTASK) THEN
          IF(TPR) CALL TRACE$PASS('READING K-POINTS AND OCCUPATIONS')
          ! NBX,NKPT_,NSPIN_
          READ(NFIL(ISIM))NBX,NKPT_,NSPIN_
          IF(NKPT_.NE.NKPT.OR.NSPIN_.NE.NSPIN) THEN
            CALL ERROR$MSG('NKPT OR NSPIN NOT CONSISTENT WITH INITIALIZATION')
            CALL ERROR$I4VAL('NKPT: ',NKPT_)
            CALL ERROR$I4VAL('NSPIN: ',NSPIN_)
            CALL ERROR$I4VAL('INITIALIZED NKPT: ',NKPT)
            CALL ERROR$I4VAL('INITIALIZED NSPIN: ',NSPIN)
            CALL ERROR$STOP('XRAY$READSIMULATIONS')
          END IF
        END IF
        CALL MPE$BROADCAST('~',RTASK,NBX)
        CALL MPE$BROADCAST('~',RTASK,NKPT)
        CALL MPE$BROADCAST('~',RTASK,NSPIN)

        ALLOCATE(OCC(NBX,NKPT,NSPIN))
        ALLOCATE(XK(3,NKPT))
        ALLOCATE(WKPT(NKPT))
        ! OCC(NBX,NKPT,NSPIN), XK(3,NKPT),WKPT(NKPT)
        IF(THISTASK.EQ.RTASK) THEN
          READ(NFIL(ISIM))OCC,XK,WKPT
        END IF
        CALL MPE$BROADCAST('~',RTASK,OCC)
        CALL MPE$BROADCAST('~',RTASK,XK)
        CALL MPE$BROADCAST('~',RTASK,WKPT)
        CALL SIMULATION$SETR8A('XK',3*NKPT,XK)
        CALL SIMULATION$SETR8A('WKPT',NKPT,WKPT)
        DEALLOCATE(XK)
        DEALLOCATE(WKPT)
        CALL SIMULATION$CHECKINVERSION
        CALL SIMULATION$KPTMAP

        CALL STATE$INIT(NKPT,NSPIN,NDIM,NPRO(ISIM))
        CALL STATE$ISELECT(ISIM)
        DO IKPT=1,NKPT
          DO ISPIN=1,NSPIN
            CALL KSMAP$WORKTASK(IKPT,ISPIN,WTASK)
            IF(THISTASK.NE.WTASK.AND.THISTASK.NE.RTASK) CYCLE
            CALL STATE$NEW(IKPT,ISPIN,NBX)
            CALL STATE$SETR8A('OCC',IKPT,ISPIN,NBX,OCC(:,IKPT,ISPIN))
          ENDDO ! END ISPIN
        ENDDO ! END IKPT
        DEALLOCATE(OCC)
        DEALLOCATE(LNX)
        DEALLOCATE(LOX)
        DEALLOCATE(R)
        DEALLOCATE(ATOMID)
        DEALLOCATE(ISPECIES)
        CALL XSETUP$UNSELECT
        CALL SIMULATION$UNSELECT
        CALL STATE$UNSELECT
      ENDDO ! END ISIM

      ! CREATE MAPPING BETWEEN ATOMS IN THE SIMULATION GROUND TO EXCITE
      CALL SIMULATION_ATOMMAP
      ! FIND INDEX OF COREHOLE ATOM IN SIMULATION GROUND
      CALL SETTINGS_IATOM

      ! ========================================================================
      ! ==  WAVE FUNCTIONS AND PROJECTIONS                                    ==
      ! ========================================================================
      CALL OVERLAP$INIT(NKPT,NSPIN)
      ALLOCATE(WTASKSKPT(NSPIN))
      DO IKPT=1,NKPT
        CALL KSMAP$WORKTASKSKPT(IKPT,WTASKSKPT)
        ! CYCLE EARLY IF THIS TASK IS NOT WORKING ON THIS KPOINT
        IF(ALL(THISTASK.NE.WTASKSKPT(:)).AND.THISTASK.NE.RTASK) CYCLE

        IF(THISTASK.EQ.RTASK) THEN
          IF(TPR) CALL TRACE$I4VAL(' READ/SEND IKPT: ',IKPT)
          ! READ GENERAL INFORMATION ABOUT K POINT
          DO ISIM=1,NSIM
            ! KEY,NGG,NDIM,NB,TSUPER
            READ(NFIL(ISIM))KEY(ISIM),NGG(ISIM),NDIM_(ISIM),NB(ISIM),ILOGICAL
            TSUPER(ISIM)=.FALSE.
            IF(ILOGICAL.EQ.1) TSUPER(ISIM)=.TRUE.
            IF(KEY(ISIM).NE.'PSI') THEN
              CALL ERROR$MSG('KEY NOT "PSI"')
              CALL ERROR$MSG('FILE IS CORRUPTED') 
              CALL ERROR$CHVAL('KEY: ',KEY(ISIM))
              CALL ERROR$I4VAL('IKPT: ',IKPT)
              CALL ERROR$STOP('XRAY$READSIMULATIONS')
            END IF
          ENDDO ! END ISIM
          ! TODO: CHECK IF NGG IS THE SAME? IS THAT REQUIRED?
          ! READ K POINT AND G VECTORS 
          ALLOCATE(IGVEC(NSIM,3,NGG(1)))
          DO ISIM=1,NSIM
            ! XK_(3),IGVEC(ISIM,3,NGG)
            READ(NFIL(ISIM))XK_(ISIM,:),IGVEC(ISIM,:,:)
          ENDDO ! END ISIM
          CALL TESTKPT!(NSIM,KEY,NGG,NDIM_,TSUPER,XK_,IGVEC)
          DEALLOCATE(IGVEC)
        END IF
        DO ISPIN=1,NSPIN
          CALL KSMAP$WORKTASK(IKPT,ISPIN,WTASK)
          CALL MPE$SENDRECEIVE('~',RTASK,WTASK,NGG)
          CALL MPE$SENDRECEIVE('~',RTASK,WTASK,NDIM_)
          CALL MPE$SENDRECEIVE('~',RTASK,WTASK,NB)
        ENDDO ! END ISPIN
        ! WARNING: REQUIRES SUPER WAVE FUNCTIONS TO BE UNRAVELLED
        ALLOCATE(PSIK1(NGG(1),NDIM_(1),NB(1)))
        ALLOCATE(PSIK2(NGG(2),NDIM_(2),NB(2)))
        ALLOCATE(PROJ1(NDIM_(1),NB(1),NPRO(1)))
        ALLOCATE(PROJ2(NDIM_(2),NB(2),NPRO(2)))
        ALLOCATE(EIG1(NB(1)))
        ALLOCATE(EIG2(NB(2)))
        ALLOCATE(PW(NB(2),NB(1)))

        DO ISPIN=1,NSPIN
          CALL KSMAP$WORKTASK(IKPT,ISPIN,WTASK)
          IF(THISTASK.NE.WTASK.AND.THISTASK.NE.RTASK) CYCLE

          IF(THISTASK.EQ.RTASK) THEN
            ! READ PLANE WAVE BASIS
            READ(NFIL(1))PSIK1
            READ(NFIL(2))PSIK2
            ! READ PROJECTIONS
            READ(NFIL(1))PROJ1
            READ(NFIL(2))PROJ2
            ! READ EIGENVALUES
            READ(NFIL(1))EIG1
            READ(NFIL(2))EIG2
          END IF
          CALL MPE$SENDRECEIVE('~',RTASK,WTASK,PSIK1)
          CALL MPE$SENDRECEIVE('~',RTASK,WTASK,PSIK2)
          CALL MPE$SENDRECEIVE('~',RTASK,WTASK,PROJ1)
          CALL MPE$SENDRECEIVE('~',RTASK,WTASK,PROJ2)
          CALL MPE$SENDRECEIVE('~',RTASK,WTASK,EIG1)
          CALL MPE$SENDRECEIVE('~',RTASK,WTASK,EIG2)
          
          ! TODO: BREAKS IF NBX != NB(1) OR NB(2)
          CALL STATE$ISELECT(1)
          CALL STATE$SETR8A('EIG',IKPT,ISPIN,NB(1),EIG1)
          CALL STATE$SETC8A('PROJ',IKPT,ISPIN,NDIM_(1)*NB(1)*NPRO(1),PROJ1)
          CALL STATE$UNSELECT
          CALL STATE$ISELECT(2)
          CALL STATE$SETR8A('EIG',IKPT,ISPIN,NB(2),EIG2)
          CALL STATE$SETC8A('PROJ',IKPT,ISPIN,NDIM_(2)*NB(2)*NPRO(2),PROJ2)
          CALL STATE$UNSELECT

          CALL OVERLAP$SELECT(IKPT,ISPIN)
          CALL OVERLAP$SETI4('NB1',NB(1))
          CALL OVERLAP$SETI4('NB2',NB(2))

          CALL TIMING$CLOCKON('XRAY$READSIMULATIONS_SCALARPRODUCT')
          IF(THISTASK.EQ.WTASK) THEN
            CALL TRACE$I4VAL(' CALCULATING IKPT: ',IKPT)
            DO IB2=1,NB(2)
              DO IB1=1,NB(1)
                ! NO DIM LOOP AS NDIM=1
                ! SCALARPRODUCT (SUM OVER G VECTORS)
                ! PW(I,J)=<PSI1(J)|PSI2(I)>
                ! WARNING: CHECK IF SCALARPRODUCT IS CORRECT ALSO WITH CONJG
                !          SHOULD BE THE CASE AS CALL OF ZGEMM IS DONE WITH 'C' OPTION
                ! WARNING: CHECK WILL NOT WORK IF ONLY USING REAL WAVE FUNCTIONS AT GAMMA POINT
                CALL LIB$SCALARPRODUCTC8(.FALSE.,NGG(1),1,PSIK1(:,1,IB1),1,PSIK2(:,1,IB2),PW(IB2,IB1))
              ENDDO ! END IB1
            ENDDO ! END IB2
            PW=PW*VCELL
            CALL OVERLAP$SETC8A('PW',NB(2)*NB(1),PW)
          END IF
          CALL OVERLAP$UNSELECT
          CALL TIMING$CLOCKOFF('XRAY$READSIMULATIONS_SCALARPRODUCT')
          ! MISSING: DETECTION OF OCCUPIED BANDS BASED ON FERMI ENERGY
        ENDDO ! END ISPIN
        DEALLOCATE(PW)
        DEALLOCATE(PSIK1)
        DEALLOCATE(PSIK2)
        DEALLOCATE(PROJ1)
        DEALLOCATE(PROJ2)
        DEALLOCATE(EIG1)
        DEALLOCATE(EIG2)
      ENDDO ! END IKPT
      ! DETERMINE NUMBER OF OCCUPIED BANDS FOR EVERY STATE
      CALL STATE_OCCUPATION
                          CALL TIMING$CLOCKOFF('XRAY$READSIMULATIONS')
                          CALL TRACE$POP
      RETURN

      CONTAINS 
        SUBROUTINE TESTKPT!(NSIM,KEY,NGG,NDIM,TSUPER,XK,IGVEC)
        ! INTEGER(4), INTENT(IN) :: NSIM
        ! CHARACTER(8), INTENT(IN) :: KEY(NSIM)
        ! INTEGER(4), INTENT(IN) :: NGG(NSIM)
        ! INTEGER(4), INTENT(IN) :: NDIM(NSIM)
        ! LOGICAL(4), INTENT(IN) :: TSUPER(NSIM)
        ! REAL(8), INTENT(IN) :: XK(NSIM,3)
        ! INTEGER(4), INTENT(IN) :: IGVEC(NSIM,3,NGG(1))
        IMPLICIT NONE
        REAL(8),PARAMETER :: TOL=1.D-8
        IF(KEY(1).NE.KEY(2)) THEN
          CALL ERROR$MSG('KEYS NOT THE SAME IN BOTH SIMULATIONS')
          CALL ERROR$I4VAL('IKPT',IKPT)
          CALL ERROR$CHVAL('KEY1',KEY(1))
          CALL ERROR$CHVAL('KEY2',KEY(2))
          CALL ERROR$STOP('RIXS$READ')
        END IF
        IF(NGG(1).NE.NGG(2)) THEN
          CALL ERROR$MSG('NGG NOT THE SAME IN BOTH SIMULATIONS')
          CALL ERROR$I4VAL('IKPT',IKPT)
          CALL ERROR$I4VAL('NGG1',NGG(1))
          CALL ERROR$I4VAL('NGG2',NGG(2))
          CALL ERROR$STOP('RIXS$READ')
        END IF
        IF(NDIM_(1).NE.NDIM_(2)) THEN
          CALL ERROR$MSG('NDIM NOT THE SAME IN BOTH SIMULATIONS')
          CALL ERROR$I4VAL('IKPT',IKPT)
          CALL ERROR$I4VAL('NDIM1',NDIM_(1))
          CALL ERROR$I4VAL('NDIM2',NDIM_(2))
          CALL ERROR$STOP('RIXS$READ')
        END IF
        ! TODO: CHECK NDIM AGAINST PREVIOUSLY READ ONE
        IF(TSUPER(1).NEQV.TSUPER(2)) THEN
          CALL ERROR$MSG('TSUPER NOT THE SAME IN BOTH SIMULATIONS')
          CALL ERROR$I4VAL('IKPT',IKPT)
          CALL ERROR$L4VAL('TSUPER1',TSUPER(1))
          CALL ERROR$L4VAL('TSUPER2',TSUPER(2))
          CALL ERROR$STOP('RIXS$READ')
        END IF
        ! CHECK IF XK SAME IN BOTH SIMULATIONS
        IF(SUM(ABS(XK_(1,:)-XK_(2,:)))>TOL) THEN
          CALL ERROR$MSG('XK NOT THE SAME IN BOTH SIMULATIONS')
          CALL ERROR$I4VAL('IKPT',IKPT)
          CALL ERROR$R8VAL('XK1',XK(1,:))
          CALL ERROR$R8VAL('XK2',XK(2,:))
          CALL ERROR$STOP('RIXS$READ')
        END IF
        ! CHECK IF IGVEC SAME IN BOTH SIMULATIONS
        IF(ANY(IGVEC(1,:,:).NE.IGVEC(2,:,:))) THEN
          CALL ERROR$MSG('IGVEC NOT THE SAME IN BOTH SIMULATIONS')
          CALL ERROR$I4VAL('IKPT',IKPT)
          CALL ERROR$STOP('RIXS$READ')
        END IF
        END SUBROUTINE TESTKPT
      END SUBROUTINE XRAY$READSIMULATIONS

      ! TODO: DATACONSISTENCY
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XRAY$WRITEOVERLAP  ! MARK: XRAY$WRITEOVERLAP
!     **************************************************************************
!     ** WRITE OVERLAP FILES FOR XRAY SIMULATION                              **
!     ** SERVES AS A RESTART FILE TO AVOID RE-CALCULATING OVERLAP             **
!     ** CERTAIN VALUES ARE NOT WRITTEN TO THE FILE, AS THEY ARE NOT REQUIRED **
!     ** THIS MIGHT LEAD TO SOME VALUES NOT BEING AVAILABLE WHEN STARTING     **
!     ** FROM THE OVERLAP FILE                                                **
!     **************************************************************************
      USE STRINGS_MODULE
      IMPLICIT NONE
      LOGICAL(4) :: TOVERLAP
      INTEGER(4) :: NFIL
      CHARACTER(256) :: FILENAME
      INTEGER(4) :: NTASKS,THISTASK,RTASK

      ! DO NOT WRITE OVERLAP IF OVERLAP FILE IS READ
      CALL XCNTL$GETL4('TOVERLAP',TOVERLAP)
      IF(TOVERLAP) RETURN
                          CALL TRACE$PUSH('XRAY$WRITEOVERLAP')
                          CALL TIMING$CLOCKON('XRAY$WRITEOVERLAP')
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      CALL KSMAP$READTASK(RTASK)
      IF(THISTASK.EQ.RTASK) THEN
        ! OPEN FILE FOR WRITING
        CALL FILEHANDLER$SETFILE('OVERLAP',.TRUE.,-'.OVERLAP')
        CALL FILEHANDLER$SETSPECIFICATION('OVERLAP','STATUS','REPLACE')
        CALL FILEHANDLER$SETSPECIFICATION('OVERLAP','POSITION','REWIND')
        CALL FILEHANDLER$SETSPECIFICATION('OVERLAP','ACTION','WRITE')
        CALL FILEHANDLER$SETSPECIFICATION('OVERLAP','FORM','UNFORMATTED')
        CALL FILEHANDLER$UNIT('OVERLAP',NFIL)
      END IF

      CALL SIMULATION_WRITEOVERLAP(NFIL)
      
      CALL OVERLAP_WRITEOVERLAP(NFIL)
      
      CALL STATE_WRITEOVERLAP(NFIL)

      CALL SETTINGS_WRITEOVERLAP(NFIL)

      IF(THISTASK.EQ.RTASK) THEN
        FLUSH(NFIL)
        CALL FILEHANDLER$CLOSE('OVERLAP')
      END IF

                          CALL TIMING$CLOCKOFF('XRAY$WRITEOVERLAP')
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE XRAY$WRITEOVERLAP
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XRAY$READOVERLAP
!     **************************************************************************
!     ** READ OVERLAP FILE FOR XRAY SIMULATION                               **
!     ** SERVES AS A RESTART FILE TO AVOID RE-CALCULATING OVERLAP             **
!     ** CERTAIN VALUES ARE NOT WRITTEN TO THE FILE, AS THEY ARE NOT REQUIRED **
!     ** THIS MIGHT LEAD TO SOME VALUES NOT BEING AVAILABLE WHEN STARTING     **
!     ** FROM THE OVERLAP FILE                                                **
!     ** FROM THE OVERLAP FILE                                                **
!     **************************************************************************
      LOGICAL(4) :: TOVERLAP
      INTEGER(4) :: NFIL
      CHARACTER(256) :: FILENAME
      INTEGER(4) :: NTASKS,THISTASK

      ! DO NOT READ OVERLAP IF OVERLAP IS NOT ACTIVE
      CALL XCNTL$GETL4('TOVERLAP',TOVERLAP)
      IF(.NOT.TOVERLAP) RETURN
                          CALL TRACE$PUSH('XRAY$READOVERLAP')
                          CALL TIMING$CLOCKON('XRAY$READOVERLAP')
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      CALL XCNTL$GETCH('OVERLAPFILE',FILENAME)
      IF(THISTASK.EQ.1) THEN
        ! OPEN FILE FOR WRITING
        CALL FILEHANDLER$SETFILE('OVERLAP',.FALSE.,TRIM(ADJUSTL(FILENAME)))
        CALL FILEHANDLER$SETSPECIFICATION('OVERLAP','STATUS','OLD')
        CALL FILEHANDLER$SETSPECIFICATION('OVERLAP','POSITION','REWIND')
        CALL FILEHANDLER$SETSPECIFICATION('OVERLAP','ACTION','READ')
        CALL FILEHANDLER$SETSPECIFICATION('OVERLAP','FORM','UNFORMATTED')
        CALL FILEHANDLER$UNIT('OVERLAP',NFIL)
      END IF

      CALL SIMULATION_READOVERLAP(NFIL)

      CALL OVERLAP_READOVERLAP(NFIL)
      
      CALL STATE_READOVERLAP(NFIL)

      CALL SETTINGS_READOVERLAP(NFIL)

      IF(THISTASK.EQ.1) CALL FILEHANDLER$CLOSE('OVERLAP')

                          CALL TIMING$CLOCKOFF('XRAY$READOVERLAP')
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE XRAY$READOVERLAP
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XRAY$OVERLAP  ! MARK: XRAY$OVERLAP
!     **************************************************************************
!     ** CALCULATE DIPOLE MATRIX, ATOM MATRIX, AND AUGMENTATION OVERLAP       **
!     **************************************************************************
      USE MPE_MODULE
      IMPLICIT NONE
      LOGICAL(4) :: TOVERLAP
      COMPLEX(8), ALLOCATABLE :: DUMMY(:,:)
      INTEGER(4) :: NB1,NB2,NOCC
      INTEGER(4) :: NKPT,NSPIN
      INTEGER(4) :: IKPT,ISPIN
      INTEGER(4) :: NTASKS,THISTASK,WTASK
      COMPLEX(8), ALLOCATABLE :: ADET(:,:)
      REAL(8) :: ADETSUM
      REAL(8) :: SVAR
      LOGICAL(4) :: TNORMALIZE

                          CALL TRACE$PUSH('XRAY$OVERLAP')
                          CALL TIMING$CLOCKON('XRAY$OVERLAP')
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      ! OVERLAP CALCULATION UNNECESSARY IF STARTING FROM OVERLAP FILE
      CALL XCNTL$GETL4('TOVERLAP',TOVERLAP)
      IF(.NOT.TOVERLAP) THEN
        CALL XRAY_DIPOLEMATRIX
        CALL XRAY_ATOMMATRIX
        CALL XRAY_AUGMENTATION
      END IF
      ! GET NORMALIZATION
      CALL XCNTL$GETL4('NORMALIZE',TNORMALIZE)
      ! SAFEGUARD GET MATRICES A, B, C, D ONCE
      ! TO AVOID ERRORS WHEN INTERNALLY ACCESSING THEM IN OVERLAP_MODULE
      CALL SIMULATION$SELECT('GROUND')
      CALL SIMULATION$GETI4('NKPT',NKPT)
      CALL SIMULATION$GETI4('NSPIN',NSPIN)
      ALLOCATE(ADET(NKPT,NSPIN))
      ADET=(0.D0,0.D0)
      CALL SIMULATION$UNSELECT
      DO IKPT=1,NKPT
        DO ISPIN=1,NSPIN
          CALL KSMAP$WORKTASK(IKPT,ISPIN,WTASK)
          IF(THISTASK.NE.WTASK) CYCLE
          CALL OVERLAP$SELECT(IKPT,ISPIN)
          CALL STATE$SELECT('GROUND')
          CALL STATE$GETI4('NB',IKPT,ISPIN,NB1)
          CALL STATE$GETI4('NOCC',IKPT,ISPIN,NOCC)
          CALL STATE$UNSELECT
          CALL STATE$SELECT('EXCITE')
          CALL STATE$GETI4('NB',IKPT,ISPIN,NB2)
          CALL STATE$UNSELECT
          ALLOCATE(DUMMY(NOCC,NOCC))
          CALL OVERLAP$GETC8A('A',NOCC*NOCC,DUMMY)
          CALL LIB$DETC8(NOCC,DUMMY,ADET(IKPT,ISPIN))
          DEALLOCATE(DUMMY)
          ALLOCATE(DUMMY(NOCC,NB1-NOCC))
          CALL OVERLAP$GETC8A('B',NOCC*(NB1-NOCC),DUMMY)
          DEALLOCATE(DUMMY)
          ALLOCATE(DUMMY(NB2-NOCC,NOCC))
          CALL OVERLAP$GETC8A('C',(NB2-NOCC)*NOCC,DUMMY)
          DEALLOCATE(DUMMY)
          ALLOCATE(DUMMY(NB2-NOCC,NB1-NOCC))
          CALL OVERLAP$GETC8A('D',(NB2-NOCC)*(NB1-NOCC),DUMMY)
          DEALLOCATE(DUMMY)
          CALL OVERLAP$UNSELECT
        ENDDO
      ENDDO
      CALL MPE$COMBINE('~','+',ADET)
      ! GET SUM_K |ADETUP|^2*|ADETDOWN|^2
      ADETSUM=0.D0
      DO IKPT=1,NKPT
        SVAR=1.D0
        DO ISPIN=1,NSPIN
          SVAR=SVAR*ABS(ADET(IKPT,ISPIN))**2
        ENDDO
        ! TODO: CHECK CONSISTENCY WITH USAGE OF ADET IN XAS/RIXS
        ! GET SECOND SPIN DIRECTION IF ONLY ONE IS PROVIDED
        IF(NSPIN.EQ.1) SVAR=SVAR*SVAR
        ADETSUM=ADETSUM+SVAR
      ENDDO
      CALL OVERLAP$SETR8('ADETSUM',ADETSUM)
      DO IKPT=1,NKPT
        DO ISPIN=1,NSPIN
          CALL OVERLAP$SELECT(IKPT,ISPIN)
          CALL OVERLAP$SETC8('ADET',ADET(IKPT,ISPIN))
          CALL OVERLAP$UNSELECT
        ENDDO ! END ISPIN
      ENDDO ! END IKPT
      DEALLOCATE(ADET)
                          CALL TIMING$CLOCKOFF('XRAY$OVERLAP')
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE XRAY$OVERLAP
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XRAY_DIPOLEMATRIX  ! MARK: XRAY_DIPOLEMATRIX
!     **************************************************************************
!     ** CALCULATE DIPOLE MATRIX ELEMENTS FOR SIMULATION EXCITE               **
!     **************************************************************************
      IMPLICIT NONE
      LOGICAL(4), PARAMETER :: TPR=.FALSE.
      REAL(8), PARAMETER :: PI=4.D0*ATAN(1.D0)
      LOGICAL(4) :: TOVERLAP
      INTEGER(4) :: NFIL
      INTEGER(4) :: NTASKS,THISTASK,WTASK
      INTEGER(4) :: IATOM ! ATOM INDEX OF COREHOLE
      INTEGER(4) :: ISP ! SPECIES OF COREHOLE ATOM
      INTEGER(4) :: NAT
      INTEGER(4) :: NBATOM
      INTEGER(4), ALLOCATABLE :: ATOMMAP(:)  ! (NAT)
      INTEGER(4), ALLOCATABLE :: ISPECIES(:)  ! (NAT)
      INTEGER(4) :: GID
      INTEGER(4) :: NR
      REAL(8), ALLOCATABLE :: AEPSI(:,:)  ! (NR,NBATOM)
      REAL(8), ALLOCATABLE :: AEPHI(:,:)  ! (NR,LNX(ISP))
      REAL(8), ALLOCATABLE :: R(:) ! (NR)
      REAL(8), ALLOCATABLE :: WORK(:)
      INTEGER(4) :: N
      INTEGER(4) :: IBCORE
      INTEGER(4) :: IB
      INTEGER(4), ALLOCATABLE :: LATOM(:)
      INTEGER(4) :: NCORE
      INTEGER(4) :: LCORE
      INTEGER(4) :: LLCORE
      REAL(8), ALLOCATABLE :: RADINT(:)
      INTEGER(4) :: NSP
      INTEGER(4) :: LNXX
      INTEGER(4), ALLOCATABLE :: LNX(:)  ! (NSP)
      INTEGER(4), ALLOCATABLE :: LOX(:,:) ! (LNXX,NSP) 
      INTEGER(4) :: LN
      INTEGER(4) :: L
      INTEGER(4) :: M
      INTEGER(4), ALLOCATABLE :: MAP(:,:) ! (NAT,LNXX)
      INTEGER(4) :: IKPT
      INTEGER(4) :: ISPIN
      INTEGER(4) :: NKPT
      INTEGER(4) :: NSPIN
      INTEGER(4) :: NB
      COMPLEX(8), ALLOCATABLE :: DIPOLE(:,:) ! (3,NB)
      COMPLEX(8) :: CVAR(3)
      INTEGER(4) :: IPRO
      INTEGER(4) :: NPRO
      INTEGER(4) :: NDIM
      INTEGER(4) :: LLVAL
      REAL(8) :: GAUNT(3)
      COMPLEX(8), ALLOCATABLE :: PROJ(:,:,:) ! (NDIM,NB,NPRO)
                          CALL TRACE$PUSH('XRAY_DIPOLEMATRIX')
                          CALL TIMING$CLOCKON('XRAY_DIPOLEMATRIX')
      CALL XCNTL$GETL4('TOVERLAP',TOVERLAP)
      IF(TOVERLAP) THEN
        CALL ERROR$MSG('SAFEGUARD: DIPOLE MATRIX CALCULATION NOT ALLOWED')
        CALL ERROR$STOP('XRAY_DIPOLEMATRIX')
      END IF
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      IF(TPR) THEN
        CALL FILEHANDLER$UNIT('PROT',NFIL)
        WRITE(NFIL,'(80("#"))')
        WRITE(NFIL,FMT='(A)')'DIPOLE MATRIX CALCULATION'
        WRITE(NFIL,'(80("#"))')
      END IF
      CALL SIMULATION$SELECT('EXCITE')
      CALL XSETUP$SELECT('EXCITE')
      CALL STATE$SELECT('EXCITE')
      CALL SIMULATION$GETI4('NKPT',NKPT)
      CALL SIMULATION$GETI4('NSPIN',NSPIN)
      CALL SIMULATION$GETI4('NAT',NAT)
      ALLOCATE(ATOMMAP(NAT))
      ALLOCATE(ISPECIES(NAT))
      CALL SIMULATION$GETI4A('ATOMMAP',NAT,ATOMMAP)
      CALL SIMULATION$GETI4A('ISPECIES',NAT,ISPECIES)
      CALL SIMULATION$GETI4('NSP',NSP)
      CALL SIMULATION$GETI4('LNXX',LNXX)
      ALLOCATE(LNX(NSP))
      ALLOCATE(LOX(LNXX,NSP))
      ALLOCATE(MAP(NAT,LNXX))
      CALL SIMULATION$GETI4A('LNX',NSP,LNX)
      CALL SIMULATION$GETI4A('LOX',LNXX*NSP,LOX)
      CALL SIMULATION$GETI4A('MAP',NAT*LNXX,MAP)
      ! GET ATOM INDEX OF COREHOLE FOR SIMULATION GROUND
      CALL SETTINGS$GETI4('IATOM',IATOM)
      CALL SETTINGS$GETI4('NCORE',NCORE)
      CALL SETTINGS$GETI4('LCORE',LCORE)
      ! CONVERT TO INDEX IN SIMULATION EXCITE
      IATOM=ATOMMAP(IATOM)
      ISP=ISPECIES(IATOM)
      CALL XSETUP$GETI4('GID',ISP,GID)
      CALL XSETUP$GETI4('NBATOM',ISP,NBATOM)
      CALL RADIAL$GETI4(GID,'NR',NR)
      ALLOCATE(AEPSI(NR,NBATOM))
      ALLOCATE(AEPHI(NR,LNX(ISP)))
      ALLOCATE(R(NR))
      ALLOCATE(WORK(NR))
      ALLOCATE(LATOM(NBATOM))
      CALL XSETUP$GETI4A('LATOM',ISP,NBATOM,LATOM)
      CALL XSETUP$GETR8A('AEPSI',ISP,NR*NBATOM,AEPSI)
      CALL XSETUP$GETR8A('AEPHI',ISP,NR*LNX(ISP),AEPHI)
      CALL RADIAL$R(GID,NR,R)
      ! ========================================================================
      ! == SELECT CORRECT RADIAL PART FOR CORE ORBITAL                        ==
      ! == NOTE: THIS ASSUME THE FOLLOWING STRUCTURE                          ==
      ! ==       |IB | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |10 |                ==
      ! ==       |---|---|---|---|---|---|---|---|---|---|---|                ==
      ! ==       | N | 1 | 2 | 2 | 3 | 3 | 3 | 4 | 4 | 4 | 4 |                ==
      ! ==       | L | 0 | 0 | 1 | 0 | 1 | 2 | 0 | 1 | 2 | 3 |                ==
      ! ========================================================================
      N=0
      DO IB=1,NBATOM
        IF(LATOM(IB).EQ.0) N=N+1
        IF(N.EQ.NCORE.AND.LATOM(IB).EQ.LCORE) THEN
          ! FOUND CORE ORBITAL
          IBCORE=IB
          IF(TPR) WRITE(NFIL,FMT='(A10,I10)')'INDEX RAD:',IBCORE
          EXIT
        END IF
      ENDDO ! END IB
      ! WARING: THIS ASSUMES THAT THE CORE ORBITAL IS AN S ORBITAL
      ! TODO: GENERALISE TO ARBITRARY ORBITALS
      ! ERROR: DOES IT REQUIRE A PHASE ON THE CORE ORBITAL?
      CALL LLOFLM(LCORE,0,LLCORE)
      IF(TPR) WRITE(NFIL,FMT='(A10,I10)')'LLCORE:',LLCORE
      ! PRE-CALCULATE RADIAL INTEGRALS
      ALLOCATE(RADINT(LNX(ISP)))
      DO LN=1,LNX(ISP)
        WORK=AEPHI(:,LN)*R**3*AEPSI(:,IBCORE)
        CALL RADIAL$INTEGRAL(GID,NR,WORK,RADINT(LN))
      ENDDO ! END LN
      ! LOOP OVER K POINTS
      DO IKPT=1,NKPT
        ! LOOP OVER SPIN
        DO ISPIN=1,NSPIN
          CALL KSMAP$WORKTASK(IKPT,ISPIN,WTASK)
          IF(THISTASK.NE.WTASK) CYCLE
          CALL OVERLAP$SELECT(IKPT,ISPIN)
          CALL STATE$GETI4('NB',IKPT,ISPIN,NB)
          CALL STATE$GETI4('NDIM',IKPT,ISPIN,NDIM)
          CALL STATE$GETI4('NPRO',IKPT,ISPIN,NPRO)
          ALLOCATE(PROJ(NDIM,NB,NPRO))
          CALL STATE$GETC8A('PROJ',IKPT,ISPIN,NDIM*NB*NPRO,PROJ)
          ALLOCATE(DIPOLE(3,NB))
          IF(TPR) WRITE(NFIL,FMT='(A10,I10,A10,I10)')'IKPT:',IKPT,'ISPIN:',ISPIN
          ! LOOP OVER BANDS
          DO IB=1,NB
            CVAR=(0.D0,0.D0)
            DO LN=1,LNX(ISP)
              L=LOX(LN,ISP)
              IPRO=MAP(IATOM,LN)
              DO M=-L,L
                IPRO=IPRO+1
                CALL LLOFLM(L,M,LLVAL)
                ! CALCULATE GAUNT COEFFICIENT VECTOR
                ! X COMPONENT
                CALL SPHERICAL$GAUNT(LLVAL,2,LLCORE,GAUNT(1))
                ! Y COMPONENT
                CALL SPHERICAL$GAUNT(LLVAL,4,LLCORE,GAUNT(2))
                ! Z COMPONENT
                CALL SPHERICAL$GAUNT(LLVAL,3,LLCORE,GAUNT(3))
                CVAR=CVAR+CONJG(PROJ(1,IB,IPRO))*RADINT(LN)*GAUNT            
              ENDDO ! END M
            ENDDO ! END LN
            CVAR=SQRT(4.D0*PI/3.D0)*CVAR
            DIPOLE(:,IB)=CVAR
            IF(TPR) WRITE(NFIL,FMT='(A10,3(F8.5,SP,F8.5,"I ",S))')'DIPOLE:',CVAR(:)
          ENDDO ! END IB
          CALL OVERLAP$SETC8A('DIPOLE',3*NB,DIPOLE)
          CALL OVERLAP$UNSELECT
          DEALLOCATE(DIPOLE)
          DEALLOCATE(PROJ)
        ENDDO ! END ISPIN
      ENDDO ! END IKPT

      DEALLOCATE(ATOMMAP)
      DEALLOCATE(ISPECIES)
      DEALLOCATE(LNX)
      DEALLOCATE(LOX)
      DEALLOCATE(MAP)
      DEALLOCATE(AEPSI)
      DEALLOCATE(AEPHI)
      DEALLOCATE(R)
      DEALLOCATE(WORK)
      DEALLOCATE(LATOM)
      DEALLOCATE(RADINT)

      CALL XSETUP$UNSELECT
      CALL SIMULATION$UNSELECT
      CALL STATE$UNSELECT
                          CALL TIMING$CLOCKOFF('XRAY_DIPOLEMATRIX')
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE XRAY_DIPOLEMATRIX
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XRAY_ATOMMATRIX  ! MARK: XRAY$ATOMMATRIX
!     **************************************************************************
!     ** CALCULATE ATOMIC OVERLAP MATRIX                                      **
!     ** REAL SPHERICAL HARMONICS GIVE L1=L2 AND M1=M2                        **
!     ** ONLY CALCULATE FOR ONE ARBITRARY M1=M2 AS RESULT IS THE SAME WITHIN  **
!     ** THE SAME L-SHELL; M1=M2 MUST BE ENSURED ELSEWHERE                    **
!     **************************************************************************
      IMPLICIT NONE
      LOGICAL(4) :: TOVERLAP
      INTEGER(4) :: NAT
      INTEGER(4) :: IAT1,IAT2
      INTEGER(4) :: NSP1,NSP2
      INTEGER(4) :: ISP1,ISP2
      INTEGER(4) :: LNXX1,LNXX2
      INTEGER(4), ALLOCATABLE :: LNX1(:),LNX2(:)
      INTEGER(4), ALLOCATABLE :: LOX1(:,:),LOX2(:,:)
      INTEGER(4) :: LN1,LN2
      REAL(8), ALLOCATABLE :: PSPHI1(:,:),PSPHI2(:,:),PSPHI2GRID(:,:)
      REAL(8), ALLOCATABLE :: AEPHI1(:,:),AEPHI2(:,:),AEPHI2GRID(:,:)
      REAL(8), ALLOCATABLE :: AUX(:)
      REAL(8), ALLOCATABLE :: R(:)
      INTEGER(4) :: NR1,NR2
      INTEGER(4) :: GID1,GID2
      REAL(8), ALLOCATABLE :: S(:,:,:)
      INTEGER(4), ALLOCATABLE :: ISPECIES1(:),ISPECIES2(:)
      INTEGER(4), ALLOCATABLE :: ATOMMAP(:)
      INTEGER(4) :: L1,L2
                          CALL TRACE$PUSH('XRAY_ATOMMATRIX')
                          CALL TIMING$CLOCKON('XRAY_ATOMMATRIX')
      CALL XCNTL$GETL4('TOVERLAP',TOVERLAP)
      IF(TOVERLAP) THEN
        CALL ERROR$MSG('SAFEGUARD: ATOM MATRIX CALCULATION NOT ALLOWED')
        CALL ERROR$STOP('XRAY_ATOMMATRIX')
      END IF
      ! GET DATA FROM SIMULATION GROUND
      CALL SIMULATION$SELECT('GROUND')
      CALL SIMULATION$GETI4('NAT',NAT)
      ALLOCATE(ATOMMAP(NAT))
      CALL SIMULATION$GETI4A('ATOMMAP',NAT,ATOMMAP)
      ALLOCATE(ISPECIES1(NAT))
      CALL SIMULATION$GETI4A('ISPECIES',NAT,ISPECIES1)
      CALL SIMULATION$GETI4('NSP',NSP1)
      ALLOCATE(LNX1(NSP1))
      CALL SIMULATION$GETI4A('LNX',NSP1,LNX1)
      CALL SIMULATION$GETI4('LNXX',LNXX1)
      ALLOCATE(LOX1(LNXX1,NSP1))
      CALL SIMULATION$GETI4A('LOX',LNXX1*NSP1,LOX1)
      CALL SIMULATION$UNSELECT
      ! GET DATA FROM SIMULATION EXCITE
      CALL SIMULATION$SELECT('EXCITE')
      ALLOCATE(ISPECIES2(NAT))
      CALL SIMULATION$GETI4A('ISPECIES',NAT,ISPECIES2)
      CALL SIMULATION$GETI4('NSP',NSP2)
      ALLOCATE(LNX2(NSP2))
      CALL SIMULATION$GETI4A('LNX',NSP2,LNX2)
      CALL SIMULATION$GETI4('LNXX',LNXX2)
      ALLOCATE(LOX2(LNXX2,NSP2))
      CALL SIMULATION$GETI4A('LOX',LNXX2*NSP2,LOX2)
      CALL SIMULATION$UNSELECT
      ! ALLOCATE TEMPORARY MEMORY FOR ATOMIC OVERLAP MATRIX
      ALLOCATE(S(NAT,LNXX1,LNXX2))

      ! LOOP OVER ATOMS IN SIMULATION GROUND
      DO IAT1=1,NAT
        ISP1=ISPECIES1(IAT1)
        ! GET SETUP DATA FOR GROUND ATOM
        CALL XSETUP$SELECT('GROUND')
        CALL XSETUP$GETI4('GID',ISP1,GID1)
        CALL RADIAL$GETI4(GID1,'NR',NR1)
        ALLOCATE(PSPHI1(NR1,LNX1(ISP1)))
        ALLOCATE(AEPHI1(NR1,LNX1(ISP1)))
        CALL XSETUP$GETR8A('PSPHI',ISP1,NR1*LNX1(ISP1),PSPHI1)
        CALL XSETUP$GETR8A('AEPHI',ISP1,NR1*LNX1(ISP1),AEPHI1)
        CALL XSETUP$UNSELECT
        
        ALLOCATE(R(NR1))
        CALL RADIAL$R(GID1,NR1,R)
        ALLOCATE(AUX(NR1))
        
        DO LN1=1,LNX1(ISP1)
          L1=LOX1(LN1,ISP1)
          IAT2=ATOMMAP(IAT1)
          ISP2=ISPECIES2(IAT2)

          CALL XSETUP$SELECT('EXCITE')
          CALL XSETUP$GETI4('GID',ISP2,GID2)
          CALL RADIAL$GETI4(GID2,'NR',NR2)
          ALLOCATE(PSPHI2(NR2,LNX2(ISP2)))
          ALLOCATE(AEPHI2(NR2,LNX2(ISP2)))
          CALL XSETUP$GETR8A('PSPHI',ISP2,NR2*LNX2(ISP2),PSPHI2)
          CALL XSETUP$GETR8A('AEPHI',ISP2,NR2*LNX2(ISP2),AEPHI2)
          CALL XSETUP$UNSELECT

          ALLOCATE(PSPHI2GRID(NR1,LNX2(ISP2)))
          ALLOCATE(AEPHI2GRID(NR1,LNX2(ISP2)))          
          
          DO LN2=1,LNX2(ISP2)
            L2=LOX2(LN2,ISP2)
            IF(L1.NE.L2) CYCLE  ! ONLY CALCULATE FOR SAME L
            ! PUT ONTO COMMON GRID
            CALL RADIAL$CHANGEGRID(GID2,NR2,PSPHI2(:,LN2),GID1,NR1,PSPHI2GRID(:,LN2))
            CALL RADIAL$CHANGEGRID(GID2,NR2,AEPHI2(:,LN2),GID1,NR1,AEPHI2GRID(:,LN2))
            ! TODO: CHECK IF ORDER IS CORRECT
            AUX=AEPHI1(:,LN1)*AEPHI2GRID(:,LN2) &
     &          -PSPHI1(:,LN1)*PSPHI2GRID(:,LN2)
            AUX=AUX*R**2
            ! TODO: CHECK IF AUX IS ZERO OUTSIDE OF R_AUG
            CALL RADIAL$INTEGRAL(GID1,NR1,AUX,S(IAT1,LN1,LN2))
          ENDDO ! END LN2
          DEALLOCATE(PSPHI2)
          DEALLOCATE(AEPHI2)
          DEALLOCATE(PSPHI2GRID)
          DEALLOCATE(AEPHI2GRID)
        ENDDO ! END LN1
        DEALLOCATE(PSPHI1)
        DEALLOCATE(AEPHI1)
        DEALLOCATE(R)
        DEALLOCATE(AUX)
      ENDDO ! END IAT1
      DEALLOCATE(ATOMMAP)
      DEALLOCATE(ISPECIES1)
      DEALLOCATE(LNX1)
      DEALLOCATE(LOX1)
      DEALLOCATE(ISPECIES2)
      DEALLOCATE(LNX2)
      DEALLOCATE(LOX2)
      ! WRAPPER: S IS STORED IN SIMULATION_MODULE
      CALL OVERLAP$SETR8A('S',NAT*LNXX1*LNXX2,S)
      DEALLOCATE(S)
                          CALL TIMING$CLOCKOFF('XRAY_ATOMMATRIX')
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE XRAY_ATOMMATRIX
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XRAY_AUGMENTATION  ! MARK: XRAY_AUGMENTATION
!     **************************************************************************
!     ** OVERLAP CONTRIBUTION FROM PAW AUGMENTATION                           **
!     **************************************************************************
      IMPLICIT NONE
      LOGICAL(4) :: TOVERLAP
      INTEGER(4) :: NTASKS,THISTASK,WTASK
      INTEGER(4) :: NKPT,NSPIN
      INTEGER(4) :: IKPT,ISPIN
      COMPLEX(8), ALLOCATABLE :: AUG(:,:) ! (NB2,NB1)
      INTEGER(4) :: NDIM1,NDIM2
      INTEGER(4) :: NPRO1,NPRO2
      INTEGER(4) :: NB1,NB2
      INTEGER(4) :: IB1,IB2
      INTEGER(4) :: NAT
      INTEGER(4) :: IAT1,IAT2
      INTEGER(4) :: NSP1,NSP2
      INTEGER(4) :: ISP1,ISP2
      INTEGER(4), ALLOCATABLE :: ISPECIES1(:),ISPECIES2(:)
      INTEGER(4), ALLOCATABLE :: ATOMMAP(:)
      INTEGER(4) :: LNXX1,LNXX2
      INTEGER(4), ALLOCATABLE :: LOX1(:,:),LOX2(:,:)
      INTEGER(4), ALLOCATABLE :: LNX1(:),LNX2(:)
      INTEGER(4) :: LN1,LN2
      INTEGER(4) :: L1,L2
      INTEGER(4) :: M1,M2
      INTEGER(4) :: IPRO1,IPRO2
      COMPLEX(8), ALLOCATABLE :: PROJ1(:,:,:),PROJ2(:,:,:)
      INTEGER(4), ALLOCATABLE :: MAP1(:,:),MAP2(:,:)
      COMPLEX(8) :: OVLAP
      COMPLEX(8) :: CVAR
      REAL(8), ALLOCATABLE :: S(:,:,:)
                          CALL TRACE$PUSH('XRAY_AUGMENTATION')
                          CALL TIMING$CLOCKON('XRAY_AUGMENTATION')
      CALL XCNTL$GETL4('TOVERLAP',TOVERLAP)
      IF(TOVERLAP) THEN
        CALL ERROR$MSG('SAFEGUARD: AUGMENTATION OVERLAP CALCULATION NOT ALLOWED')
        CALL ERROR$STOP('XRAY_AUGMENTATION')
      END IF
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      ! GET DATA FROM SIMULATION GROUND
      CALL SIMULATION$SELECT('GROUND')
      CALL SIMULATION$GETI4('NKPT',NKPT)
      CALL SIMULATION$GETI4('NSPIN',NSPIN)
      CALL SIMULATION$GETI4('NAT',NAT)
      ALLOCATE(ISPECIES1(NAT))
      CALL SIMULATION$GETI4A('ISPECIES',NAT,ISPECIES1)
      ALLOCATE(ATOMMAP(NAT))
      CALL SIMULATION$GETI4A('ATOMMAP',NAT,ATOMMAP)
      CALL SIMULATION$GETI4('NSP',NSP1)
      ALLOCATE(LNX1(NSP1))
      CALL SIMULATION$GETI4A('LNX',NSP1,LNX1)
      CALL SIMULATION$GETI4('LNXX',LNXX1)
      ALLOCATE(LOX1(LNXX1,NSP1))
      CALL SIMULATION$GETI4A('LOX',LNXX1*NSP1,LOX1)
      ALLOCATE(MAP1(NAT,LNXX1))
      CALL SIMULATION$GETI4A('MAP',NAT*LNXX1,MAP1)
      CALL SIMULATION$UNSELECT
      ! GET DATA FROM SIMULATION EXCITE
      CALL SIMULATION$SELECT('EXCITE')
      ALLOCATE(ISPECIES2(NAT))
      CALL SIMULATION$GETI4A('ISPECIES',NAT,ISPECIES2)
      CALL SIMULATION$GETI4('NSP',NSP2)
      ALLOCATE(LNX2(NSP2))
      CALL SIMULATION$GETI4A('LNX',NSP2,LNX2)
      CALL SIMULATION$GETI4('LNXX',LNXX2)
      ALLOCATE(LOX2(LNXX2,NSP2))
      CALL SIMULATION$GETI4A('LOX',LNXX2*NSP2,LOX2)
      ALLOCATE(MAP2(NAT,LNXX2))
      CALL SIMULATION$GETI4A('MAP',NAT*LNXX2,MAP2)
      CALL SIMULATION$UNSELECT
      ! GET ATOMIC OVERLAP MATRIX (WRAPPER: S IS STORED IN SIMULATION_MODULE)
      ALLOCATE(S(NAT,LNXX1,LNXX2))
      CALL OVERLAP$GETR8A('S',NAT*LNXX1*LNXX2,S)

      ! LOOP OVER K POINTS
      DO IKPT=1,NKPT
        ! LOOP OVER SPIN
        DO ISPIN=1,NSPIN
          CALL KSMAP$WORKTASK(IKPT,ISPIN,WTASK)
          IF(THISTASK.NE.WTASK) CYCLE
          ! GET DATA FROM STATE OF SIMULATION GROUND
          CALL STATE$SELECT('GROUND')
          CALL STATE$GETI4('NB',IKPT,ISPIN,NB1)
          CALL STATE$GETI4('NDIM',IKPT,ISPIN,NDIM1)
          CALL STATE$GETI4('NPRO',IKPT,ISPIN,NPRO1)
          ALLOCATE(PROJ1(NDIM1,NB1,NPRO1))
          CALL STATE$GETC8A('PROJ',IKPT,ISPIN,NDIM1*NB1*NPRO1,PROJ1)
          CALL STATE$UNSELECT
          ! GET DATA FROM STATE OF SIMULATION EXCITE
          CALL STATE$SELECT('EXCITE')
          CALL STATE$GETI4('NB',IKPT,ISPIN,NB2)
          CALL STATE$GETI4('NDIM',IKPT,ISPIN,NDIM2)
          CALL STATE$GETI4('NPRO',IKPT,ISPIN,NPRO2)
          ALLOCATE(PROJ2(NDIM2,NB2,NPRO2))
          CALL STATE$GETC8A('PROJ',IKPT,ISPIN,NDIM2*NB2*NPRO2,PROJ2)
          CALL STATE$UNSELECT
          ! ALLOCATE AUGMENTATION OVERLAP MATRIX
          ALLOCATE(AUG(NB2,NB1))
          DO IB1=1,NB1
            DO IB2=1,NB2
              ! AUG(I,J)=<PSI1(J)|PSI2(I)>
              OVLAP=(0.D0,0.D0)
              DO IAT1=1,NAT
                ISP1=ISPECIES1(IAT1)
                IAT2=ATOMMAP(IAT1)
                ISP2=ISPECIES2(IAT2)
                DO LN1=1,LNX1(ISP1)
                  DO LN2=1,LNX2(ISP2)
                    L1=LOX1(LN1,ISP1)
                    L2=LOX2(LN2,ISP2)
                    IF(L1.NE.L2) CYCLE  ! ONLY CALCULATE FOR SAME L
                    IPRO1=MAP1(IAT1,LN1)
                    DO M1=1,2*L1+1
                      IPRO1=IPRO1+1
                      IPRO2=MAP2(IAT2,LN2)
                      DO M2=1,2*L2+1
                        IPRO2=IPRO2+1
                        IF(M1.NE.M2) CYCLE  ! ONLY CALCULATE FOR SAME M
                        CVAR=CONJG(PROJ1(1,IB1,IPRO1))*PROJ2(1,IB2,IPRO2)
                        OVLAP=OVLAP+CVAR*S(IAT1,LN1,LN2)
                      ENDDO ! END M2
                    ENDDO ! END M1
                  ENDDO ! END LN2
                ENDDO ! END LN1
              ENDDO ! END IAT1
              AUG(IB2,IB1)=OVLAP
            ENDDO ! END IB2
          ENDDO ! END IB1
          DEALLOCATE(PROJ1)
          DEALLOCATE(PROJ2)
          ! STORE AUGMENTATION OVERLAP MATRIX IN OVERLAP_MODULE
          CALL OVERLAP$SELECT(IKPT,ISPIN)
          CALL OVERLAP$SETC8A('AUG',NB2*NB1,AUG)
          CALL OVERLAP$SETL4('TOVERLAP',.TRUE.)
          CALL OVERLAP$UNSELECT
          DEALLOCATE(AUG)
        ENDDO ! END ISPIN
      ENDDO ! END IKPT
      DEALLOCATE(ISPECIES1)
      DEALLOCATE(ATOMMAP)
      DEALLOCATE(LNX1)
      DEALLOCATE(LOX1)
      DEALLOCATE(MAP1)
      DEALLOCATE(ISPECIES2)
      DEALLOCATE(LNX2)
      DEALLOCATE(LOX2)
      DEALLOCATE(MAP2)
      DEALLOCATE(S)
                          CALL TIMING$CLOCKOFF('XRAY_AUGMENTATION')
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE XRAY_AUGMENTATION
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SHARED_DATA$REPORT(NFIL)  ! MARK: SHARED_DATA$REPORT
!     **************************************************************************
!     ** REPORT SHARED DATA                                                   **
!     **************************************************************************
      USE SHARED_DATA_MODULE, ONLY: ADETPROD
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: NFIL  ! FILE UNIT NUMBER
      INTEGER(4) :: IKPT
      INTEGER(4) :: NKPT
      INTEGER(4) :: NTASKS,THISTASK,RTASK
      LOGICAL(4) :: TBASISWGHT
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      CALL KSMAP$READTASK(RTASK)
      IF(THISTASK.NE.RTASK) RETURN
                          CALL TRACE$PUSH('SHARED_DATA$REPORT')
      CALL XCNTL$GETL4('BASISWGHT',TBASISWGHT)
      CALL SIMULATION$SELECT('GROUND')
      CALL SIMULATION$GETI4('NKPT',NKPT)
      CALL SIMULATION$UNSELECT
      WRITE(NFIL,'(80("-"))')
      WRITE(NFIL,'(A)') ' BASIS OVERLAP REPORT TO FIRST ORDER'
      WRITE(NFIL,'(80("-"))')
      IF(TBASISWGHT) THEN
        WRITE(NFIL,'(A)') ' BASIS WEIGHTED USED IN SIMULATION'
      ELSE
        WRITE(NFIL,'(A)') ' NO BASIS WEIGHTED USED IN SIMULATION'
      END IF
      WRITE(NFIL,'(A12,A12,A12)') 'IKPT','ADETPROD','1/ADETPROD'
      DO IKPT=1,NKPT
        WRITE(NFIL,'(I12,F12.8,F12.8)') IKPT,ADETPROD(IKPT,1),1.D0/ADETPROD(IKPT,1)
      ENDDO ! END IKPT
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE SHARED_DATA$REPORT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE POLARISATION_CONVERT(K,N,POL,POLXYZ)  ! MARK: POLARISATION_CONVERT
!     **************************************************************************
!     ** POLARISATION IS GIVEN BY:                                            **
!     **   K: VECTOR OF LIGHT                                                 **
!     **   N: SURFACE NORMAL OF MATERIAL                                      **
!     **   POL: POLARISATION VECTOR WITH POL(1)=SIGMA AND POL(2)=PI POLAR.    **
!     ** RETURN POLARISATION IN XYZ COORDINATES                               **
!     **************************************************************************
      IMPLICIT NONE
      REAL(8), INTENT(IN) :: K(3)
      REAL(8), INTENT(IN) :: N(3)
      COMPLEX(8), INTENT(IN) :: POL(2)
      COMPLEX(8), INTENT(OUT) :: POLXYZ(3)
      REAL(8), PARAMETER :: TOL=1.D-8
      REAL(8) :: WORK(3)
      REAL(8) :: WORK2(3)
      REAL(8) :: SVAR
      CALL CROSS_PROD(K,N,WORK)
      SVAR=NORM2(WORK)
      IF(SVAR.LT.TOL) THEN
        CALL ERROR$MSG('K VECTOR AND SURFACE NORMAL ARE PARALLEL')
        CALL ERROR$MSG('POLARISATION VECTOR IS SET TO ARBITRARY ORTHO. VECTOR')
        CALL VEC_ORTHO(K,WORK)
        SVAR=NORM2(WORK)
      END IF
      WORK=WORK/SVAR
      CALL CROSS_PROD(WORK,K,WORK2)
      WORK2=WORK2/NORM2(WORK2)
      POLXYZ=POL(1)*WORK+POL(2)*WORK2
      SVAR=SQRT(SUM(ABS(POLXYZ)**2))
      POLXYZ=POLXYZ/SVAR
      RETURN
      END SUBROUTINE POLARISATION_CONVERT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE CROSS_PROD(A,B,C)  ! MARK: CROSS_PROD
!     **************************************************************************
!     ** CALCULATE CROSS PRODUCT OF TWO VECTORS                               **
!     **************************************************************************
      IMPLICIT NONE
      REAL(8), INTENT(IN) :: A(3)
      REAL(8), INTENT(IN) :: B(3)
      REAL(8), INTENT(OUT) :: C(3)
      C(1)=A(2)*B(3)-A(3)*B(2)
      C(2)=A(3)*B(1)-A(1)*B(3)
      C(3)=A(1)*B(2)-A(2)*B(1)
      RETURN
      END SUBROUTINE CROSS_PROD
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE VEC_ORTHO(A,B)  ! MARK: VEC_ORTHO
!     **************************************************************************
!     ** CALCULATE ORTHOGONAL VECTOR TO A                                      **
!     **************************************************************************
! TODO: UNDERSTAND
      IMPLICIT NONE
      REAL(8), INTENT(IN) :: A(3)
      REAL(8), INTENT(OUT) :: B(3)
      REAL(8) :: VECVAR(3)
      VECVAR = (/1.D0,0.D0,0.D0/)
      IF(DOT_PRODUCT(A,VECVAR).EQ.NORM2(A)) THEN
        VECVAR = (/0.D0,1.D0,0.D0/)
      END IF
      CALL CROSS_PROD(A,VECVAR,B)
      END SUBROUTINE VEC_ORTHO
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE LLOFLM(L,M,LL)  ! MARK: LLOFLM
!     **************************************************************************
!     ** CALCULATE LL=L*L+L-M+1                                               **
!     **************************************************************************
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: L
      INTEGER(4), INTENT(IN) :: M
      INTEGER(4), INTENT(OUT) :: LL
      LL=L*L+L-M+1
      RETURN
      END SUBROUTINE LLOFLM
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE AMPLITUDE(NB,NOCC,IEMP,LINMAT,DIPOLE,AMPL,SP)  ! MARK: AMPLITUDE
!     **************************************************************************
!     ** CALCULATE TRANSITION AMPLITUDE FOR A GIVEN INTERMEDIATE              **
!     **    STATE (IKPT,ISPIN,K) WITH A GIVEN LINEAR DEPENDENCY MATRIX        **
!     ** THREE COMPONENTS ARE FOR THE THREE CARTESIAN DIRECTIONS              **
!     ** AMPL=DIPOLE(IEMP) - SUM_M CONJG(LINMAT(IEMP,M))*DIPOLE(M)            **
!     **************************************************************************
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: NB ! NUMBER OF BANDS
      INTEGER(4), INTENT(IN) :: NOCC ! NUMBER OF OCCUPIED BANDS
      INTEGER(4), INTENT(IN) :: IEMP ! INDEX OF EMPTY BAND WITH THE FIRST EMPTY BAND=1
      COMPLEX(8), INTENT(IN) :: LINMAT(NB-NOCC,NOCC) ! LINEAR DEPENDENCE MATRIX
      COMPLEX(8), INTENT(IN) :: DIPOLE(3,NB) ! DIPOLE MATRIX
      COMPLEX(8), INTENT(OUT) :: AMPL(3) ! AMPLITUDE VECTOR
      LOGICAL(4), INTENT(IN) :: SP ! SINGLE PARTICLE AMPLITUDE
      INTEGER(4) :: IFINAL ! INDEX OF EMPTY BAND WITHIN ALL BANDS
      INTEGER(4) :: IB
      IFINAL=IEMP+NOCC
      IF(IFINAL.GT.NB) THEN
        CALL ERROR$MSG('INDEX OF EMPTY BAND IS OUT OF RANGE')
        CALL ERROR$I4VAL('IEMP',IEMP)
        CALL ERROR$I4VAL('NOCC',NOCC)
        CALL ERROR$I4VAL('IFINAL',IFINAL)
        CALL ERROR$I4VAL('NB',NB)
        CALL ERROR$STOP('AMPLITUDE')
      END IF
      IF(IFINAL.LE.NOCC) THEN
        CALL ERROR$MSG('FINAL STATE ORBITAL INDEX OCCUPIED')
        CALL ERROR$I4VAL('IEMP',IEMP)
        CALL ERROR$I4VAL('NOCC',NOCC)
        CALL ERROR$I4VAL('IFINAL',IFINAL)
        CALL ERROR$STOP('AMPLITUDE')
      END IF
      AMPL=(0.D0,0.D0)
      IF(SP) THEN
        AMPL(:)=DIPOLE(:,IFINAL)
        RETURN
      END IF
      DO IB=1,NOCC
        AMPL(:)=AMPL(:)+CONJG(LINMAT(IEMP,IB))*DIPOLE(:,IB)
      ENDDO ! END IB
      AMPL(:)=DIPOLE(:,IFINAL)-AMPL(:)
      RETURN
      END SUBROUTINE AMPLITUDE
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE MAPGRID(X,Y,N,GRID,XMIN,DE)  ! MARK: MAPGRID
!     **************************************************************************
!     ** MAP VALUE Y AT POSITION X ONTO GRID                                  **
!     ** SPLIT BETWEEN THE TWO NEIGHBORING POINTS DEPENDING ON DISTANCE       **
!     **************************************************************************
      IMPLICIT NONE
      REAL(8), INTENT(IN) :: X
      REAL(8), INTENT(IN) :: Y
      INTEGER(4), INTENT(IN) :: N
      REAL(8), INTENT(INOUT) :: GRID(N)
      REAL(8), INTENT(IN) :: XMIN
      REAL(8), INTENT(IN) :: DE
      INTEGER(4) :: I1,I2
      REAL(8) :: X0
      REAL(8) :: W1,W2
      X0=(X-XMIN)/DE+1.D0
      I1=INT(X0)
      I2=I1+1
      W2=(X0-REAL(I1,KIND=8))
      W1=1.D0-W2
      IF(I1.GT.0.AND.I1.LE.N) GRID(I1)=GRID(I1)+Y*W1
      IF(I2.GT.0.AND.I2.LE.N) GRID(I2)=GRID(I2)+Y*W2
      RETURN
      END SUBROUTINE MAPGRID
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE LORENTZCONV(N,X,Y,GAMMA)  ! MARK: LORENTZCONV
!     **************************************************************************
!     ** CALCULATE CONVOLUTION WITH LORENTZIAN FUNCTION                       **
!     ** L(X,X0,GAMMA)=(Y/2)/(PI*((X-X0)**2+(GAMMA/2)**2))                    **
!     **************************************************************************
      IMPLICIT NONE
      REAL(8), PARAMETER :: PI=4.D0*ATAN(1.D0)
      INTEGER(4), INTENT(IN) :: N
      REAL(8), INTENT(IN) :: X(N)
      REAL(8), INTENT(INOUT) :: Y(N)
      REAL(8), INTENT(IN) :: GAMMA
      REAL(8) :: WORK(N)
      INTEGER(4) :: I,J
      REAL(8) :: GAMMA2
      REAL(8) :: SVAR
      DO I=1,N
        WORK(I)=0.D0
        GAMMA2=0.25D0*GAMMA*GAMMA
        DO J=1,N
          SVAR=GAMMA/(2.D0*PI*((X(I)-X(J))**2+GAMMA2))
          WORK(I)=WORK(I)+Y(J)*SVAR
        ENDDO
      ENDDO
      Y=WORK
      RETURN
      END SUBROUTINE LORENTZCONV
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE GAUSSCONV(N,X,Y,SIGMA)
!     **************************************************************************
!     ** CALCULATE CONVOLUTION WITH GAUSSIAN FUNCTION                         **
!     ** G(X,X0,SIGMA)=(1/(SIGMA*SQRT(2*PI)))*EXP(-0.5*((X-X0)/SIGMA)**2)     **
!     **************************************************************************
      IMPLICIT NONE
      REAL(8), PARAMETER :: PI=4.D0*ATAN(1.D0)
      INTEGER(4), INTENT(IN) :: N
      REAL(8), INTENT(IN) :: X(N)
      REAL(8), INTENT(INOUT) :: Y(N)
      REAL(8), INTENT(IN) :: SIGMA
      REAL(8) :: WORK(N)
      INTEGER(4) :: I,J
      REAL(8) :: SVAR
      DO I=1,N
        WORK(I)=0.D0
        DO J=1,N
          SVAR=EXP(-0.5D0*((X(I)-X(J))/SIGMA)**2)/(SIGMA*SQRT(2.D0*PI))
          WORK(I)=WORK(I)+Y(J)*SVAR
        ENDDO
      ENDDO
      Y=WORK
      RETURN
      END SUBROUTINE GAUSSCONV
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE KVEC(E,N,K)  !MARK: KVEC
!     **************************************************************************
!     **  CALCULATE K VECTOR IN RECIPROCAL BOHRRADIUS                         **            
!     **  FROM ENERGY AND DIRECTION                                           **
!     **************************************************************************
      IMPLICIT NONE
      ! |K|=E/HBAR/C
      REAL(8), INTENT(IN) :: E  ! ENERGY OF LIGHT IN HARTREE ATOMIC UNITS
      REAL(8), INTENT(IN) :: N(3)  ! DIRECTION OF K VECTOR
      REAL(8), INTENT(OUT) :: K(3)  ! K VECTOR IN BOHRRADIUS^-1
      REAL(8) :: SVAR
      REAL(8) :: HBAR
      REAL(8) :: C
      CALL CONSTANTS('HBAR',HBAR)
      CALL CONSTANTS('C',C)
      K=N/NORM2(N)  ! NORMALISE DIRECTION
      SVAR=E/HBAR/C
      K=K*SVAR
      END SUBROUTINE KVEC
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE KTOXK(K,RBAS,XK)  ! MARK: KTOXK
!     **************************************************************************
!     **  CONVERT K-POINT VECTOR INTO RELATIVE K-POINT COORDINATES            **
!     **************************************************************************
      IMPLICIT NONE
      REAL(8)   ,INTENT(IN)  :: K(3)  ! K-POINT VECTOR IN REAL SPACE
      REAL(8)   ,INTENT(IN)  :: RBAS(3,3)  ! REAL SPACE LATTICE VECTORS
      REAL(8)   ,INTENT(OUT) :: XK(3)  ! VECTOR IN RELATIVE K-POINT COORDINATES
      REAL(8) :: GBAS(3,3)
      REAL(8) :: INVGBAS(3,3)
      REAL(8) :: VOL
      INTEGER(4) :: I
      CALL GBASS(RBAS,GBAS,VOL)
      CALL LIB$INVERTR8(3,GBAS,INVGBAS)
      XK=MATMUL(INVGBAS,K)
      RETURN
      END SUBROUTINE KTOXK
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XKTOK(XK,RBAS,K)  ! MARK: XKTOK
!     **************************************************************************
!     **  CONVERT RELATIVE K-POINT COORDINATES INTO K-POINT VECTOR            **
!     **************************************************************************
      IMPLICIT NONE
      REAL(8)   ,INTENT(IN)  :: XK(3)  ! VECTOR IN RELATIVE K-POINT COORDINATES
      REAL(8)   ,INTENT(IN)  :: RBAS(3,3)  ! REAL SPACE LATTICE VECTORS
      REAL(8)   ,INTENT(OUT) :: K(3)  ! K-POINT VECTOR IN REAL SPACE
      REAL(8) :: GBAS(3,3)
      REAL(8) :: VOL
      INTEGER(4) :: I
      CALL GBASS(RBAS,GBAS,VOL)
      K=MATMUL(GBAS,XK)
      END SUBROUTINE XKTOK

! SUBROUTINES TAKEN FROM OTHER PROGRAMS THAT MIGHT BE USEFUL IN THE FUTURE
! !
! !     ...1.........2.........3.........4.........5.........6.........7.........8
!       SUBROUTINE FERMILEVEL(EF)  !MARK: FERMILEVEL
! !     **************************************************************************
! !     ** CALCULATE FERMI LEVEL OF SIMULATION                                 **
! !     **************************************************************************
!       USE DATA_MODULE, ONLY: EIG,OCC,TINIT
!       IMPLICIT NONE
!       REAL(8), INTENT(OUT) :: EF
!       INTEGER(4) :: NFIL
!       INTEGER(4) :: NKPT
!       INTEGER(4) :: NSPIN
!       INTEGER(4) :: NDIM
!       INTEGER(4), ALLOCATABLE :: NBARR(:,:)
!       INTEGER(4) :: NB
!       INTEGER(4) :: NBB
!       REAL(8) :: RNTOT
!       REAL(8), ALLOCATABLE :: WGHT(:,:)
!       REAL(8) :: EV
!       IF(.NOT.TINIT) THEN
!         CALL ERROR$MSG('DATA MODULE NOT INITIALIZED')
!         CALL ERROR$STOP('FERMILEVEL')
!       ENDIF
!       CALL CONSTANTS('EV',EV)
!       CALL FILEHANDLER$UNIT('PROT',NFIL)
!       CALL PDOS$GETI4('NKPT',NKPT)
!       CALL PDOS$GETI4('NSPIN',NSPIN)
!       CALL PDOS$GETI4('NDIM',NDIM)
!       CALL PDOS$GETR8('RNTOT',RNTOT)
!       ALLOCATE(NBARR(NKPT,NSPIN))
!       CALL PDOS$GETI4A('NB',NKPT*NSPIN,NBARR)
!       NB=MAXVAL(NBARR)
!       DEALLOCATE(NBARR)

!       NBB=NB
!       IF(NDIM.EQ.1)NBB=2*NB  ! COLLINEAR AND NON-SPIN-POLARIZED
!       ALLOCATE(WGHT(NBB,NKPT))
!       CALL BRILLOUIN$DOS(NBB,NKPT,EIG,WGHT,RNTOT,EF)
!       DEALLOCATE(WGHT)
!       WRITE(NFIL,FMT='(A10,F12.6)')'EFERMI:',EF/EV
!       END SUBROUTINE FERMILEVEL
