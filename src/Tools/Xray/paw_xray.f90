!     ==  OPEN QUESTIONS  ======================================================
! WHAT HAPPENS FOR DIFFERENT AMOUNT OF BANDS AT DIFFERENT K-POINTS?

!     ...1.........2.........3.........4.........5.........6.........7.........8
      MODULE XCNTL_MODULE  ! MARK: XCNTL_MODULE
!     **************************************************************************
!     ** XCNTL MODULE FOR PAW XRAY TOOL                                       **
!     **************************************************************************
        USE LINKEDLIST_MODULE, ONLY: LL_TYPE
        TYPE(LL_TYPE) :: LL_CNTL
        SAVE
      END MODULE XCNTL_MODULE
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      MODULE KSMAP_MODULE  ! MARK: KSMAP_MODULE
!     **************************************************************************
!     ** KSMAP MODULE FOR PAW XRAY TOOL                                       **
!     ** CONTROLS THE PARALLELIZATION OF K-POINTS AND SPINS                   **
!     **************************************************************************
      LOGICAL(4) :: INITIALIZED=.FALSE. ! INITIALIZED
      INTEGER(4) :: NKPTG  ! #(KPOINTS TOTAL)
      INTEGER(4) :: NSPING ! #(SPINS TOTAL)
      INTEGER(4) :: RTASK  ! TASK RESPONSIBLE FOR READ/WRITE
      INTEGER(4), ALLOCATABLE :: KSMAP(:,:) ! (NKPT,NSPIN) K-POINT AND SPIN RESPONSIBILITY OF TASKS
      END MODULE KSMAP_MODULE
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      MODULE SIMULATION_MODULE  ! MARK: SIMULATION_MODULE
!     **************************************************************************
!     ** SIMULATION MODULE FOR PAW XRAY TOOL                                  **
!     **************************************************************************
      TYPE SIMULATION_TYPE
      CHARACTER(6) :: ID ! SIMULATION ID
      LOGICAL(4) :: INITIALIZED=.FALSE. ! INITIALIZED
      CHARACTER(256) :: FILE ! FILENAME
      INTEGER(4) :: NAT ! #(ATOMS)
      INTEGER(4) :: NSP ! #(SETUPS)
      INTEGER(4) :: NKPT ! #(KPOINTS)
      INTEGER(4) :: NSPIN ! #(SPINS)
      INTEGER(4) :: NDIM ! #(DIMENSIONS)
      INTEGER(4) :: NPRO ! #(PROJECTIONS)
      INTEGER(4) :: LNXX
      CHARACTER(6) :: FLAG
      INTEGER(4), ALLOCATABLE :: LMNX(:) ! (NSP)
      INTEGER(4), ALLOCATABLE :: LNX(:) ! (NSP)
      INTEGER(4), ALLOCATABLE :: LOX(:,:) ! (LNXX,NSP)
      INTEGER(4), ALLOCATABLE :: MAP(:,:) ! (NAT,LNXX) INDEX-1 OF ATOM AND LN
      LOGICAL(4) :: TINV ! INVERSION SYMMETRY
      INTEGER(4) :: NKDIV(3) ! K-POINT DIVISIONS
      INTEGER(4) :: ISHIFT(3) ! K-POINT SHIFTS
      REAL(8) :: RNTOT
      REAL(8) :: NEL
      REAL(8) :: ETOT=HUGE(1.D0)  ! TOTAL ENERGY
      REAL(8) :: EDFT=HUGE(1.D0)  ! TOTAL DFT ENERGY
      REAL(8) :: ECORE=HUGE(1.D0)  ! TOTAL CORE ENERGY
      INTEGER(4) :: SPACEGROUP
      LOGICAL(4) :: TSHIFT
      REAL(8) :: RBAS(3,3) ! BASIS VECTORS
      REAL(8) :: VCELL=-HUGE(1.D0) ! CELL VOLUME
      REAL(8), ALLOCATABLE :: R(:,:) ! (3,NAT) ATOMIC POSITIONS
      CHARACTER(16), ALLOCATABLE :: ATOMID(:) ! (NAT) ATOM IDENTIFIERS
      INTEGER(4), ALLOCATABLE :: ISPECIES(:) ! (NAT) SPECIES INDEX
      REAL(8), ALLOCATABLE :: XK(:,:) ! (3,NKPT) K-POINTS IN REL. COORD.
      REAL(8), ALLOCATABLE :: WKPT(:) ! (NKPT) K-POINT WEIGHTS
      COMPLEX(8), ALLOCATABLE :: DENMAT(:,:,:,:) ! (LMNXX,LMNXX,NDIM,NAT) DENSITY MATRIX
      END TYPE SIMULATION_TYPE
      
      INTEGER(4), ALLOCATABLE :: ATOMMAP(:) ! (NAT) ATOM INDEX MAP GROUND->EXCITE
      TYPE(SIMULATION_TYPE), TARGET :: GROUND ! GROUND STATE SIMULATION (1)
      TYPE(SIMULATION_TYPE), TARGET :: EXCITE ! EXCITED STATE SIMULATION (2)
      TYPE(SIMULATION_TYPE), POINTER :: THIS ! POINTER TO CURRENT SIMULATION
      LOGICAL(4), SAVE :: SELECTED=.FALSE. ! SIMULATION SELECTED
      END MODULE SIMULATION_MODULE
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      MODULE STATE_MODULE  ! MARK: STATE_MODULE
!     **************************************************************************
!     ** STATE MODULE FOR PAW XRAY TOOL                                       **
!     **************************************************************************
      ! WARNING: WHY ARE POINTERS USED HERE?
      TYPE STATE_TYPE
      ! IF OCCUPATION > OCCPERCENT*MAXOCC THEN OCCUPIED 
      ! DEACTIVATED IF EFERMI GIVEN, MAXOCC=2.0/1.0 FOR NSPIN=1/2
      REAL(8) :: OCCPERCENT=0.5D0 
      INTEGER(4)          :: NB=-HUGE(1) ! #(STATES)
      REAL(8), ALLOCATABLE :: EIG(:) ! (NB) EIGENVALUES
      REAL(8), ALLOCATABLE :: OCC(:) ! (NB) OCCUPATIONS
      INTEGER(4)          :: NOCC=-HUGE(1) ! #(OCCUPIED STATES)
      COMPLEX(8), ALLOCATABLE :: PROJ(:,:,:) ! (NDIM,NB,NPRO) PROJECTIONS
      END TYPE STATE_TYPE
      
      INTEGER(4) :: NKPTG
      INTEGER(4) :: NSPING
      INTEGER(4) :: NDIM
      INTEGER(4) :: NPRO
      LOGICAL(4) :: INITIALIZED=.FALSE. ! INITIALIZED
      TYPE(STATE_TYPE), POINTER :: GROUND(:,:) ! (NKPT,NSPIN) GROUND STATE
      TYPE(STATE_TYPE), POINTER :: EXCITE(:,:) ! (NKPT,NSPIN) EXCITED STATE
      TYPE(STATE_TYPE), POINTER :: THIS(:,:) ! POINTER TO CURRENT STATE 
      LOGICAL(4), SAVE :: SELECTED=.FALSE. ! STATE SELECTED
      END MODULE STATE_MODULE
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      MODULE XSETUP_MODULE  ! MARK: XSETUP_MODULE
!     **************************************************************************
!     ** XSETUP MODULE FOR PAW XRAY TOOL                                      **
!     ** NOT AVAILABLE IF START FROM RESTART FILE                             **
!     **************************************************************************
      TYPE XSETUP_TYPE
      INTEGER(4) :: GID ! GRID ID FOR RADIAL MESH
      REAL(8) :: ECORE ! CORE ENERGY
      INTEGER(4) :: LNXX
      INTEGER(4) :: LNX
      INTEGER(4), ALLOCATABLE :: L(:) ! (LNXX)
      REAL(8), ALLOCATABLE :: PSPHI(:,:) ! PSEUDO PARTIAL WAVE
      REAL(8), ALLOCATABLE :: AEPHI(:,:) ! AE PARTIAL WAVE
      INTEGER(4) :: NBATOM ! #(ATOMIC WAVE FUNCTIONS)
      INTEGER(4), ALLOCATABLE :: LATOM(:) ! (NBATOM) L QUANTUM NUMBER
      REAL(8), ALLOCATABLE :: AEPSI(:,:) ! (NR,NBATOM) AE ATOMIC WAVE FUNCTION
      END TYPE XSETUP_TYPE

      INTEGER(4) :: NSPGROUND
      TYPE(XSETUP_TYPE), POINTER :: GROUND(:) ! GROUND STATE SETUPS
      INTEGER(4) :: NSPEXCITE
      TYPE(XSETUP_TYPE), POINTER :: EXCITE(:) ! EXCITED STATE SETUPS
      TYPE(XSETUP_TYPE), POINTER :: THIS(:) ! POINTER TO CURRENT SETUP ARRAY
      INTEGER(4) :: THISNSP
      LOGICAL(4), SAVE :: SELECTED=.FALSE. ! SETUP SELECTED
      LOGICAL(4), SAVE :: TRSTRT=.FALSE. ! START FROM RESTART FILE
      END MODULE XSETUP_MODULE
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      MODULE OVERLAP_MODULE  ! MARK: OVERLAP_MODULE
!     **************************************************************************
!     ** OVERLAP MODULE FOR PAW XRAY TOOL                                     **
!     **************************************************************************
      ! TODO: CHECK WHAT IS ACTUALLY NECESSARY
      TYPE OVERLAP_TYPE
      INTEGER(4) :: NB1 ! #(BANDS IN SIMULATION 1)
      INTEGER(4) :: NB2 ! #(BANDS IN SIMULATION 2)
      INTEGER(4) :: NOCC ! #(OCCUPIED BANDS)
      COMPLEX(8), ALLOCATABLE :: PW(:,:) ! (NB2,NB1) PLANE WAVE OVERLAP MATRIX
      COMPLEX(8), ALLOCATABLE :: AUG(:,:) ! (NB2,NB1) AUGMENTATION OVERLAP MATRIX
      COMPLEX(8), ALLOCATABLE :: OV(:,:,:) ! (NB2,NB1) OVERLAP MATRIX
      ! IT IS CHECKED THAT NOCC1=NOCC2
      ! OVERLAP MATRIX
      ! | A | B |
      ! |---+---|
      ! | C | D |
      COMPLEX(8), ALLOCATABLE :: A(:,:) ! (NOCC,NOCC)
      COMPLEX(8), ALLOCATABLE :: B(:,:) ! (NOCC,NB1-NOCC)
      COMPLEX(8), ALLOCATABLE :: C(:,:) ! (NB2-NOCC,NOCC)
      COMPLEX(8), ALLOCATABLE :: D(:,:) ! (NB2-NOCC,NB1-NOCC)
      ! AINV=A^(-1)
      COMPLEX(8), ALLOCATABLE :: AINV(:,:) ! (NOCC,NOCC)
      COMPLEX(8) :: ADET ! DETERMINANT OF A
      COMPLEX(8), ALLOCATABLE :: DIPOLE(:,:) ! (3,NB2) DIPOLE MATRIX ELEMENTS
      END TYPE OVERLAP_TYPE
      
      TYPE(OVERLAP_TYPE), ALLOCATABLE, TARGET :: OVLARR(:,:) ! (NKPT,NSPIN) OVERLAP ARRAYS
      TYPE(OVERLAP_TYPE), POINTER :: THIS ! POINTER TO CURRENT OVERLAP
      INTEGER(4) :: NKPTG  ! #(KPOINTS TOTAL)
      INTEGER(4) :: NSPING ! #(SPINS TOTAL)
      LOGICAL(4), SAVE :: SELECTED=.FALSE. ! OVERLAP SELECTED
      LOGICAL(4) :: INITIALIZED=.FALSE. ! INITIALIZED
      END MODULE OVERLAP_MODULE
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      MODULE SETTINGS_MODULE  ! MARK: SETTINGS_MODULE
!     **************************************************************************
!     ** SETTINGS MODULE FOR PAW XRAY TOOL                                    **
!     **************************************************************************
      CHARACTER(32) :: COREHOLE ! ATOM ID OF CORE HOLE
      INTEGER(4) :: IATOM=-HUGE(1) ! ATOM INDEX WITH CORE HOLE IN SIM1 (FOR SIM2 USE ATOMMAP)
      INTEGER(4) :: NCORE ! N QUANTUM NUMBER OF CORE HOLE
      INTEGER(4) :: LCORE ! L QUANTUM NUMBER OF CORE HOLE
      END MODULE SETTINGS_MODULE
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      MODULE XAS_MODULE  ! MARK: XAS_MODULE
!     **************************************************************************
!     ** XAS MODULE FOR PAW XRAY TOOL                                         **
!     **************************************************************************
      TYPE XAS_SPEC_TYPE
      CHARACTER(256) :: FILE ! FILENAME FOR SPECTRUM
      REAL(8) :: NORMAL(3) ! NORMAL VECTOR OF SURFACE
      REAL(8) :: KDIR(3) ! DIRECTION OF INCIDENT RAY
      COMPLEX(8) :: POL(2) ! POLARIZATION VECTOR
      COMPLEX(8) :: POLXYZ(3) ! POLARIZATION VECTOR IN CARTESIAN COORDINATES
      LOGICAL(4) :: TPOLXYZ ! CHECK IF POLXYZ IS SET
      REAL(8) :: EBROAD ! GAUSSIAN BROADENING FOR XAS SPECTRUM (REPLACES DELTA FUNCTION)
      CHARACTER(1) :: BROADMODE ! BROADENING MODE: 'G' GAUSSIAN, 'L' LORENTZIAN,
                                ! 'N' NONE
      END TYPE XAS_SPEC_TYPE

      LOGICAL(4) :: TACTIVE=.FALSE. ! XAS ACTIVE
      LOGICAL(4) :: TINITIALIZE=.FALSE.
      INTEGER(4) :: NSPEC ! NUMBER OF SPECTRA FOR XAS
      REAL(8) :: EMIN ! MINIMUM ENERGY FOR XAS
      REAL(8) :: EMAX ! MAXIMUM ENERGY FOR XAS
      REAL(8) :: DE ! ENERGY STEP FOR XAS SPECTRUM
      INTEGER(4) :: NE ! NUMBER OF ENERGY POINTS FOR XAS SPECTRUM

      TYPE(XAS_SPEC_TYPE), ALLOCATABLE, TARGET :: SPECTRA(:) ! (NSPEC) SPECTRA
      TYPE(XAS_SPEC_TYPE), POINTER :: THIS ! POINTER TO CURRENT SPECTRUM
      LOGICAL(4), SAVE :: SELECTED=.FALSE. ! SPECTRUM SELECTED
      END MODULE XAS_MODULE
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      MODULE RIXS_MODULE  ! MARK: RIXS_MODULE
!     **************************************************************************
!     ** RIXS MODULE FOR PAW XRAY TOOL                                        **
!     **************************************************************************
      TYPE RIXS_SPEC_TYPE
      CHARACTER(256) :: FILE ! FILENAME
      REAL(8) :: NORMAL(3) ! NORMAL VECTOR OF SURFACE
      ! INCOMING LIGHT
      REAL(8) :: KDIRI(3) ! DIRECTION OF K VECTOR
      COMPLEX(8) :: POLI(2) ! POLARIZATION VECTOR
      COMPLEX(8) :: POLIXYZ(3) ! POLARIZATION VECTOR IN CARTESIAN COORDINATES
      LOGICAL(4) :: TPOLIXYZ ! CHECK IF POLIXYZ IS SET
      ! OUTGOING LIGHT
      REAL(8) :: KDIRO(3) ! DIRECTION OF K VECTOR
      COMPLEX(8) :: POLO(2) ! POLARIZATION VECTOR
      COMPLEX(8) :: POLXYZO(3) ! POLARIZATION VECTOR IN CARTESIAN COORDINATES

      REAL(8) :: GAMMA ! LIFETIME BROADENING FOR RIXS SPECTRUM
      REAL(8) :: EBROAD ! GAUSSIAN BROADENING FOR XAS SPECTRUM (REPLACES DELTA FUNCTION)
      CHARACTER(1) :: BROADMODE ! BROADENING MODE: 'G' GAUSSIAN, 'L' LORENTZIAN,
                                ! 'N' NONE
      END TYPE RIXS_SPEC_TYPE

      LOGICAL(4) :: TACTIVE=.FALSE. ! RIXS ACTIVE
      LOGICAL(4) :: TINITIALIZE=.FALSE.
      INTEGER(4) :: NSPEC ! NUMBER OF SPECTRA FOR RIXS
      ! ENERGY LOSS FOR WHICH FINAL STATES ARE CONSIDERED
      REAL(8) :: EMIN=-HUGE(1.D0) ! MINIMUM ENERGY FOR RIXS
      REAL(8) :: EMAX=HUGE(1.D0) ! MAXIMUM ENERGY FOR RIXS
      ! FOLLOWING SETTINGS ARE USED AS DEFAULTS FOR SPECTRA
      ! WILL BE OVERWRITTEN BY SPECTRA SETTINGS

      TYPE(RIXS_SPEC_TYPE), ALLOCATABLE :: SPECTRA(:) ! (NSPEC) SPECTRA
      TYPE(RIXS_SPEC_TYPE), POINTER :: THIS ! POINTER TO CURRENT SPECTRUM
      LOGICAL(4), SAVE :: SELECTED=.FALSE. ! SPECTRUM SELECTED
      END MODULE RIXS_MODULE
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      ! MODULE PAW_XRAY_MODULE  ! MARK: PAW_XRAY_MODULE
      ! TYPE SETTINGS_TYPE
      !   CHARACTER(32) :: COREHOLE ! ATOM ID OF CORE HOLE
      !   INTEGER(4) :: IATOM ! ATOM INDEX WITH CORE HOLE IN SIM1 (FOR SIM2 USE ATOMMAP)
      !   INTEGER(4) :: NCORE ! N QUANTUM NUMBER OF CORE HOLE
      !   INTEGER(4) :: LCORE ! L QUANTUM NUMBER OF CORE HOLE
      ! END TYPE SETTINGS_TYPE

      ! TYPE(SETTINGS_TYPE) :: SETTINGS

      ! REAL(8), ALLOCATABLE :: S(:,:,:) ! (NAT,LNXX1,LNXX2) ATOMIC OVERLAP MATRIX
      ! INTEGER(4), ALLOCATABLE :: ATOMMAP(:) ! (NAT) ATOM INDEX MAP BRA -> KET

      ! INTEGER(4), ALLOCATABLE :: KSMAP(:,:) ! (NKPT,NSPIN) K AND S RESPONSIBILITY OF TASKS
      ! INTEGER(4) :: NKPTG  ! #(KPOINTS TOTAL)
      ! INTEGER(4) :: NSPING ! #(SPINS TOTAL)
      ! INTEGER(4) :: RTASK  ! TASK RESPONSIBLE FOR READ/WRITE
      ! END MODULE PAW_XRAY_MODULE

!     ==========================================================================
!     ==                    PROGRAM PAW_XRAY                                  ==
!     ==========================================================================
      PROGRAM PAW_XRAY  ! MARK: PAW_XRAY
      USE XCNTL_MODULE, ONLY: LL_CNTL
      USE LINKEDLIST_MODULE
      USE CLOCK_MODULE
      IMPLICIT NONE
      INTEGER(4) :: NFIL
      CHARACTER(32) :: DATIME
      INTEGER(4) :: NTASKS
      INTEGER(4) :: THISTASK
!     **************************************************************************
      CALL MPE$INIT
                          CALL TRACE$PUSH('PAW_XRAY')
                          CALL TIMING$START
      CALL MPE$QUERY('~',NTASKS,THISTASK)
!     INITIALIZE FILES
      CALL INITIALIZEFILEHANDLER
      CALL FILEHANDLER$UNIT('PROT',NFIL)
      IF(THISTASK.EQ.1) THEN
        WRITE(NFIL,FMT='()')
        CALL CPPAW_WRITEVERSION(NFIL)
        CALL CLOCK$NOW(DATIME)        
        WRITE(NFIL,FMT='(80("="))')
        WRITE(NFIL,FMT='(80("="),T15,"  PROGRAM STARTED ",A32,"  ")')DATIME
        WRITE(NFIL,FMT='(80("="))')
      END IF
!     ==========================================================================
!     == READ XRAY CONTROL FILE                                               ==
!     ==========================================================================
                          CALL TIMING$CLOCKON('XCNTL')
      CALL FILEHANDLER$UNIT('XCNTL',NFIL)
      CALL XCNTL$READ(NFIL)
      CALL XCNTL$FILES
      CALL XCNTL$COREHOLE
      CALL XCNTL$XAS
      ! TODO: IMPLEMENT RIXS BLOCK READ


      CALL FILEHANDLER$UNIT('PROT',NFIL)
      CALL LINKEDLIST$SELECT(LL_CNTL,'~')
      ! IF(THISTASK.EQ.1) CALL LINKEDLIST$REPORT(LL_CNTL,NFIL)
      IF(THISTASK.EQ.1) CALL LINKEDLIST$REPORT_UNUSED(LL_CNTL,NFIL)


      ! TODO: IMPLEMENT READING OF OVERLAP FILE
      CALL XRAY$READ

      
      CALL KSMAP$REPORT(NFIL)
      CALL SIMULATION$SELECT('GROUND')
      CALL SIMULATION$REPORT(NFIL)
      CALL SIMULATION$UNSELECT
      CALL XSETUP$SELECT('GROUND')
      CALL XSETUP$REPORT(NFIL)
      CALL XSETUP$UNSELECT 

      CALL SIMULATION$SELECT('EXCITE')
      CALL SIMULATION$REPORT(NFIL)
      CALL SIMULATION$UNSELECT
      CALL XSETUP$SELECT('EXCITE')
      CALL XSETUP$REPORT(NFIL)
      CALL XSETUP$UNSELECT

      CALL SETTINGS$REPORT(NFIL)

      CALL XAS$REPORT(NFIL)





                          CALL TIMING$CLOCKOFF('XCNTL')

      ! CALCULATE OVERLAP

      ! CALCULATE DIPOLE MATRIX ELEMENTS

      ! ...












                          CALL TIMING$PRINT('~',NFIL)
      CALL MPE$CLOCKREPORT(NFIL)
      IF(THISTASK.EQ.1) THEN
        CALL CLOCK$NOW(DATIME)
        WRITE(NFIL,FMT='(80("="))')
        WRITE(NFIL,FMT='(80("="),T15,"  PROGRAM FINISHED ",A32,"  ")')DATIME
        WRITE(NFIL,FMT='(80("="))')
      END IF
                          CALL TRACE$POP
      CALL ERROR$NORMALSTOP
      STOP

                          CALL TRACE$POP
      END PROGRAM PAW_XRAY

!      
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE INITIALIZEFILEHANDLER
!     **************************************************************************
      USE STRINGS_MODULE
      IMPLICIT NONE
      CHARACTER(256) :: ROOTNAME
      CHARACTER(256) :: CNTLNAME
      INTEGER(4)     :: ISVAR
      INTEGER(4)     :: NARGS
      ! **************************************************************************
                          CALL TRACE$PUSH('INITIALIZEFILEHANDLER')
      NARGS=COMMAND_ARGUMENT_COUNT()
      IF(NARGS.LT.1) THEN
        CALL ERROR$MSG('ARGUMENT LIST OF EXECUTABLE IS EMPTY')
        CALL ERROR$MSG('THE CONTROL FILE OF THE XRAY TOOL IS MANDATORY')
        CALL ERROR$STOP('INITIALIZEFILEANDLER')
      END IF
      CALL GET_COMMAND_ARGUMENT(1,CNTLNAME)
      ISVAR=INDEX(CNTLNAME,-'.XCNTL',BACK=.TRUE.)
      IF(ISVAR.NE.0) THEN
        ROOTNAME=CNTLNAME(1:ISVAR-1)
      ELSE
        ROOTNAME=' '
      END IF
      CALL FILEHANDLER$SETROOT(ROOTNAME)
      CALL STANDARDFILES
      CALL FILEHANDLER$SETFILE('XCNTL',.FALSE.,CNTLNAME)
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE INITIALIZEFILEHANDLER
!
!      ..1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE STANDARDFILES
!     **************************************************************************
      USE STRINGS_MODULE
      IMPLICIT NONE
      CHARACTER(32)        :: ID
      INTEGER(4)          :: THISTASK
      INTEGER(4)          :: NTASKS
      ! **************************************************************************
                                   CALL TRACE$PUSH('STANDARDFILES')
      ! ========================================================================
      ! == SET STANDARD FILENAMES                                             ==
      ! ========================================================================
      ! ==  ERROR FILE =========================================================
      ID=+'ERR'
      CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.XERR')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','REPLACE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','APPEND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','WRITE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')
      ! ==  PROTOCOL FILE ======================================================
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      ID=+'PROT'
      ! TODO: THIS ASSUMES THAT TASKS 1 IS ALWAYS READTASK
      IF(THISTASK.GT.1) THEN
        CALL FILEHANDLER$SETFILE(ID,.FALSE.,-'/DEV/NULL')
      ELSE
        CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.XPROT')
      END IF
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','REPLACE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','APPEND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','WRITE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')
      ! ==  CONTROL FILE  == ===================================================
      ID=+'XCNTL'
      CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.XCNTL')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','OLD')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','REWIND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','READ')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')
                                   CALL TRACE$POP
      RETURN
      END SUBROUTINE STANDARDFILES
!

!     ==========================================================================
!     ==========================================================================
!     ==                    XCNTL MODULE FUNCTIONS                            ==
!     ==========================================================================
!     ==========================================================================
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XCNTL$READ(NFIL)  ! MARK: XCNTL$READ
!     **************************************************************************
!     **                                                                      **
!     **************************************************************************
      USE XCNTL_MODULE, ONLY: LL_CNTL
      USE LINKEDLIST_MODULE
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: NFIL
      LOGICAL(4) :: TCHK
                          CALL TRACE$PUSH('XCNTL$READ')
      CALL LINKEDLIST$NEW(LL_CNTL)
      CALL LINKEDLIST$READ(LL_CNTL,NFIL,'~')
      CALL LINKEDLIST$SELECT(LL_CNTL,'~')
      CALL LINKEDLIST$MARK(LL_CNTL,1)
      CALL LINKEDLIST$EXISTL(LL_CNTL,'XCNTL',1,TCHK)
      IF(.NOT.TCHK) THEN
        CALL ERROR$MSG('CONTROL FILE DOES NOT CONTAIN !XCNTL BLOCK')
        CALL ERROR$STOP('XCNTL$READ')
      END IF
      ! CHECK WETHER TO CALCULATE XAS OR RIXS
      CALL LINKEDLIST$SELECT(LL_CNTL,'XCNTL')
      CALL LINKEDLIST$EXISTL(LL_CNTL,'XAS',1,TCHK)
      CALL XAS$SETL4('ACTIVE',TCHK)
      CALL LINKEDLIST$EXISTL(LL_CNTL,'RIXS',1,TCHK)
      CALL RIXS$SETL4('ACTIVE',TCHK)
                          CALL TRACE$POP
      END SUBROUTINE XCNTL$READ
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XCNTL$FILES  ! MARK: XCNTL$FILES
!     **************************************************************************
!     ** READ FILES GROUND AND EXCITE OR RESTART FROM CNTL FILE               **
!     **************************************************************************
      USE XCNTL_MODULE, ONLY: LL_CNTL
      USE LINKEDLIST_MODULE
      IMPLICIT NONE
      LOGICAL(4) :: TOVERLAP
      LOGICAL(4) :: TCHK
      LOGICAL(4) :: TCHK1
      LOGICAL(4) :: TCHK2
      LOGICAL(4) :: TCHK3
      CHARACTER(256) :: FILENAME
                          CALL TRACE$PUSH('XCNTL$FILES')
      CALL LINKEDLIST$SELECT(LL_CNTL,'~')
      CALL LINKEDLIST$SELECT(LL_CNTL,'XCNTL')
      CALL LINKEDLIST$EXISTL(LL_CNTL,'GROUND',1,TCHK1)
      CALL LINKEDLIST$EXISTL(LL_CNTL,'EXCITE',1,TCHK2)
      CALL LINKEDLIST$EXISTL(LL_CNTL,'OVERLAP',1,TCHK3)
      ! EITHER BOTH GROUND AND EXCITE OR RESTART NEED TO BE PRESENT AND ARE
      ! MUTUALLY EXCLUSIVE
      IF(TCHK1.AND.TCHK2.AND..NOT.TCHK3) THEN
        TOVERLAP=.FALSE.
      ELSE IF(.NOT.TCHK1.AND..NOT.TCHK2.AND.TCHK3) THEN
        TOVERLAP=.TRUE.
      ELSE
        CALL ERROR$MSG('CONTROL FILE MUST CONTAIN EITHER')
        CALL ERROR$MSG('BOTH !GROUND AND !EXCITE BLOCKS OR !OVERLAP BLOCK')
        CALL ERROR$MSG('BUT NOT BOTH AT THE SAME TIME')
        CALL ERROR$MSG('PROVIDED WERE:')
        CALL ERROR$L4VAL(' !GROUND: ',TCHK1)
        CALL ERROR$L4VAL(' !EXCITE: ',TCHK2)
        CALL ERROR$L4VAL(' !OVERLAP: ',TCHK3)
        CALL ERROR$STOP('XCNTL$FILES')
      END IF
      IF(.NOT.TOVERLAP) THEN
        ! READ GROUND STATE
        CALL LINKEDLIST$SELECT(LL_CNTL,'GROUND')
        CALL LINKEDLIST$EXISTD(LL_CNTL,'FILE',1,TCHK)
        IF(.NOT.TCHK) THEN
          CALL ERROR$MSG('!GROUND:FILE NOT FOUND')
          CALL ERROR$STOP('XCNTL$FILES')
        END IF
        CALL LINKEDLIST$GET(LL_CNTL,'FILE',1,FILENAME)
        CALL SIMULATION$SELECT('GROUND')
        CALL SIMULATION$SETCH('ID','GROUND')
        CALL SIMULATION$SETCH('FILE',TRIM(ADJUSTL(FILENAME)))

        CALL FILEHANDLER$SETFILE('GROUND',.FALSE.,TRIM(ADJUSTL(FILENAME)))
        CALL FILEHANDLER$SETSPECIFICATION('GROUND','STATUS','OLD')
        CALL FILEHANDLER$SETSPECIFICATION('GROUND','POSITION','REWIND')
        CALL FILEHANDLER$SETSPECIFICATION('GROUND','ACTION','READ')
        CALL FILEHANDLER$SETSPECIFICATION('GROUND','FORM','UNFORMATTED')

        CALL SIMULATION$UNSELECT
        CALL LINKEDLIST$SELECT(LL_CNTL,'..')

        ! READ EXCITED STATE
        CALL LINKEDLIST$SELECT(LL_CNTL,'EXCITE')
        CALL LINKEDLIST$EXISTD(LL_CNTL,'FILE',1,TCHK)
        IF(.NOT.TCHK) THEN
          CALL ERROR$MSG('!EXCITE:FILE NOT FOUND')
          CALL ERROR$STOP('XCNTL$FILES')
        END IF
        CALL LINKEDLIST$GET(LL_CNTL,'FILE',1,FILENAME)
        CALL SIMULATION$SELECT('EXCITE')
        CALL SIMULATION$SETCH('ID','EXCITE')
        CALL SIMULATION$SETCH('FILE',TRIM(ADJUSTL(FILENAME)))

        CALL FILEHANDLER$SETFILE('EXCITE',.FALSE.,TRIM(ADJUSTL(FILENAME)))
        CALL FILEHANDLER$SETSPECIFICATION('EXCITE','STATUS','OLD')
        CALL FILEHANDLER$SETSPECIFICATION('EXCITE','POSITION','REWIND')
        CALL FILEHANDLER$SETSPECIFICATION('EXCITE','ACTION','READ')
        CALL FILEHANDLER$SETSPECIFICATION('EXCITE','FORM','UNFORMATTED')

        CALL SIMULATION$UNSELECT
        CALL LINKEDLIST$SELECT(LL_CNTL,'..')
      END IF
      IF(TOVERLAP) THEN
        ! TODO: IMPLEMENT HANDLING OF OVERLAP FILE
        CALL ERROR$MSG('OVERLAP NOT IMPLEMENTED YET')
        CALL ERROR$STOP('XCNTL$FILES')
      END IF
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE XCNTL$FILES
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XCNTL$COREHOLE  ! MARK: XCNTL$COREHOLE
!     **************************************************************************
!     ** READ !COREHOLE FROM CONTROL FILE                                     **
!     **************************************************************************
      ! TODO: MIGHT NOT BE NESSARY IF STARTING FROM OVERLAP FILE
      USE XCNTL_MODULE, ONLY: LL_CNTL
      USE LINKEDLIST_MODULE
      IMPLICIT NONE
      LOGICAL(4) :: TCHK
      CHARACTER(32) :: ATOM
      INTEGER(4) :: NCORE
      INTEGER(4) :: LCORE
                          CALL TRACE$PUSH('XCNTL$COREHOLE')
      CALL LINKEDLIST$SELECT(LL_CNTL,'~')
      CALL LINKEDLIST$SELECT(LL_CNTL,'XCNTL')
      CALL LINKEDLIST$EXISTL(LL_CNTL,'COREHOLE',1,TCHK)
      IF(.NOT.TCHK) THEN
        CALL ERROR$MSG('CONTROL FILE DOES NOT CONTAIN !COREHOLE BLOCK')
        CALL ERROR$STOP('XCNTL$COREHOLE')
      END IF
      CALL LINKEDLIST$SELECT(LL_CNTL,'COREHOLE')
      ! READ ATOM NAME
      CALL LINKEDLIST$EXISTD(LL_CNTL,'ATOM',1,TCHK)
      IF(.NOT.TCHK) THEN
        CALL ERROR$MSG('!COREHOLE:ATOM NOT FOUND')
        CALL ERROR$STOP('XCNTL$COREHOLE')
      END IF
      CALL LINKEDLIST$GET(LL_CNTL,'ATOM',1,ATOM)
      CALL SETTINGS$SETCH('COREHOLE',TRIM(ADJUSTL(ATOM)))
      ! READ N QUANTUM NUMBER
      CALL LINKEDLIST$EXISTD(LL_CNTL,'NCORE',1,TCHK)
      IF(.NOT.TCHK) THEN
        CALL ERROR$MSG('!COREHOLE:NCORE NOT FOUND')
        CALL ERROR$STOP('XCNTL$COREHOLE')
      END IF
      CALL LINKEDLIST$GET(LL_CNTL,'NCORE',1,NCORE)
      CALL SETTINGS$SETI4('NCORE',NCORE)
      ! READ L QUANTUM NUMBER
      CALL LINKEDLIST$EXISTD(LL_CNTL,'LCORE',1,TCHK)
      IF(.NOT.TCHK) THEN
        CALL ERROR$MSG('!COREHOLE:LCORE NOT FOUND')
        CALL ERROR$STOP('XCNTL$COREHOLE')
      END IF
      CALL LINKEDLIST$GET(LL_CNTL,'LCORE',1,LCORE)
      IF(LCORE.NE.0) THEN
        CALL ERROR$MSG('IMPLEMENTATION ONLY FOR S COREHOLES (LCORE=0)')
        CALL ERROR$I4VAL('LCORE',LCORE)
        CALL ERROR$STOP('XCNTL$COREHOLE')
      END IF
      CALL SETTINGS$SETI4('LCORE',LCORE)
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE XCNTL$COREHOLE
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XCNTL$XAS  ! MARK: XCNTL$XAS
!     **************************************************************************
!     ** READ !XCNTL!XAS FROM CONTROL FILE                                    **
!     **************************************************************************
      USE LINKEDLIST_MODULE
      USE XCNTL_MODULE, ONLY: LL_CNTL
      IMPLICIT NONE
      LOGICAL(4) :: TCHK
      LOGICAL(4) :: TCHK1
      LOGICAL(4) :: TCHK2
      LOGICAL(4) :: TCHK3
      CHARACTER(256) :: FILENAME
      INTEGER(4) :: NSPEC
      INTEGER(4) :: ISPEC
      ! DEFAULT SETTINGS
      REAL(8) :: EBROAD
      CHARACTER(1) :: BROADMODE
      REAL(8) :: EMIN
      REAL(8) :: EMAX
      REAL(8) :: DE
      
      REAL(8) :: NORMAL(3)
      LOGICAL(4) :: TNORMALDEF
      LOGICAL(4) :: TNORMAL

      REAL(8) :: KDIR(3)
      LOGICAL(4) :: TKDIRDEF
      LOGICAL(4) :: TKDIR

      COMPLEX(8) :: POL(2)
      REAL(8) :: REALPOL(4)
      LOGICAL(4) :: TPOLDEF
      LOGICAL(4) :: TPOL
      
      REAL(8) :: RVAR
      REAL(8) :: RVAR3(3)
      CHARACTER(1) :: CHVAR
      COMPLEX(8) :: CVAR2(2)
      COMPLEX(8) :: CVAR3(3)
      REAL(8) :: EV
      ! ONLY READ IF XAS IS ACTIVE
      CALL XAS$GETL4('ACTIVE',TCHK)
      IF(.NOT.TCHK) RETURN
                          CALL TRACE$PUSH('XCNTL$XAS')
      CALL CONSTANTS('EV',EV)
      CALL LINKEDLIST$SELECT(LL_CNTL,'~')
      CALL LINKEDLIST$SELECT(LL_CNTL,'XCNTL')
      CALL LINKEDLIST$SELECT(LL_CNTL,'XAS')
      
      ! EMIN[EV]
      CALL LINKEDLIST$EXISTD(LL_CNTL,'EMIN[EV]',1,TCHK)
      IF(TCHK) THEN
        CALL LINKEDLIST$GET(LL_CNTL,'EMIN[EV]',1,EMIN)
        EMIN=EMIN*EV
      ELSE
        EMIN=-HUGE(1.D0) ! MINIMUM ENERGY NOT SET
      END IF
      CALL XAS$SETR8('EMIN',EMIN)

      ! EMAX[EV]
      CALL LINKEDLIST$EXISTD(LL_CNTL,'EMAX[EV]',1,TCHK)
      IF(TCHK) THEN
        CALL LINKEDLIST$GET(LL_CNTL,'EMAX[EV]',1,EMAX)
        EMAX=EMAX*EV
      ELSE
        EMAX=HUGE(1.D0) ! MAXIMUM ENERGY NOT SET
      END IF
      CALL XAS$SETR8('EMAX',EMAX)

      ! DE[EV]
      CALL LINKEDLIST$EXISTD(LL_CNTL,'DE[EV]',1,TCHK)
      IF(TCHK) THEN
        CALL LINKEDLIST$GET(LL_CNTL,'DE[EV]',1,DE)
        DE=DE*EV
      ELSE
        DE=1.D-2*EV
      END IF
      CALL XAS$SETR8('DE',DE)

      ! EBROAD[EV]
      CALL LINKEDLIST$EXISTD(LL_CNTL,'EBROAD[EV]',1,TCHK)
      IF(TCHK) THEN
        CALL LINKEDLIST$GET(LL_CNTL,'EBROAD[EV]',1,EBROAD)
        EBROAD=EBROAD*EV
      ELSE
        EBROAD=0.3D0*EV ! DEFAULT BROADENING
      END IF

      ! BROADMODE
      CALL LINKEDLIST$EXISTD(LL_CNTL,'BROADMODE',1,TCHK)
      IF(TCHK) THEN
        CALL LINKEDLIST$GET(LL_CNTL,'BROADMODE',1,BROADMODE)
        IF(BROADMODE.NE.'G'.AND.BROADMODE.NE.'L'.AND.BROADMODE.NE.'N') THEN
          CALL ERROR$MSG('BROADMODE MUST BE G, L OR N')
          CALL ERROR$CHVAL('BROADMODE',BROADMODE)
          CALL ERROR$STOP('XCNTL$XAS')
        END IF
      ELSE
        BROADMODE='G' ! DEFAULT BROADENING MODE
      END IF

      ! NORMAL VECTOR
      CALL LINKEDLIST$EXISTD(LL_CNTL,'NORMAL',1,TNORMALDEF)
      IF(TNORMALDEF) THEN
        CALL LINKEDLIST$GET(LL_CNTL,'NORMAL',1,NORMAL)
        IF(NORM2(NORMAL).LT.1.D-6) THEN
          CALL ERROR$MSG('NORMAL VECTOR CANNOT BE ZERO')
          CALL ERROR$STOP('XCNTL$XAS')
        END IF
      END IF

      ! KDIR VECTOR
      CALL LINKEDLIST$EXISTD(LL_CNTL,'KDIR',1,TKDIRDEF)
      IF(TKDIRDEF) THEN
        CALL LINKEDLIST$GET(LL_CNTL,'KDIR',1,KDIR)
        IF(NORM2(KDIR).LT.1.D-6) THEN
          CALL ERROR$MSG('KDIR VECTOR CANNOT BE ZERO')
          CALL ERROR$STOP('XCNTL$XAS')
        END IF
      END IF

      ! POLARIZATION VECTOR
      CALL LINKEDLIST$EXISTD(LL_CNTL,'POL',1,TPOLDEF)
      IF(TPOLDEF) THEN
        CALL LINKEDLIST$GET(LL_CNTL,'POL',1,REALPOL)
        POL(1)=CMPLX(REALPOL(1),REALPOL(2),KIND=8)
        POL(2)=CMPLX(REALPOL(3),REALPOL(4),KIND=8)
        ! IF(NORM2(POL).LT.1.D-6) THEN
        !   CALL ERROR$MSG('POLARIZATION VECTOR CANNOT BE ZERO')
        !   CALL ERROR$STOP('XCNTL$XAS')
        ! END IF
      END IF

      ! READ NUMBER OF SPECTRA
      CALL LINKEDLIST$EXISTL(LL_CNTL,'SPECTRUM',1,TCHK)
      IF(.NOT.TCHK) THEN
        CALL ERROR$MSG('CONTROL FILE DOES NOT CONTAIN !XAS!SPECTRUM BLOCK')
        CALL ERROR$MSG('AT LEAST ONE SPECTRUM IS REQUIRED')
        CALL ERROR$STOP('XCNTL$XAS')
      END IF

      CALL LINKEDLIST$NLISTS(LL_CNTL,'SPECTRUM',NSPEC)
      CALL XAS$SETI4('NSPEC',NSPEC)
      CALL XAS$SETL4('INITIALIZE',.TRUE.) ! INITIALIZE XAS MODULE

      ! READ ALL SPECTRA
      DO ISPEC=1,NSPEC
        CALL XAS$ISELECT(ISPEC)
        CALL LINKEDLIST$SELECT(LL_CNTL,'~')
        CALL LINKEDLIST$SELECT(LL_CNTL,'XCNTL')
        CALL LINKEDLIST$SELECT(LL_CNTL,'XAS')
        CALL LINKEDLIST$SELECT(LL_CNTL,'SPECTRUM',ISPEC)

        ! READ FILENAME
        CALL LINKEDLIST$EXISTD(LL_CNTL,'FILE',1,TCHK)
        IF(.NOT.TCHK) THEN
          CALL ERROR$MSG('!XAS:SPECTRUM:FILE NOT FOUND')
          CALL ERROR$I4VAL('ISPEC',ISPEC)
          CALL ERROR$STOP('XCNTL$XAS')
        END IF
        CALL LINKEDLIST$GET(LL_CNTL,'FILE',1,FILENAME)
        CALL XAS$SETCH('FILE',TRIM(ADJUSTL(FILENAME)))

        ! EBROAD
        CALL LINKEDLIST$EXISTD(LL_CNTL,'EBROAD[EV]',1,TCHK)
        IF(TCHK) THEN
          CALL LINKEDLIST$GET(LL_CNTL,'EBROAD[EV]',1,RVAR)
          RVAR=RVAR*EV
        ELSE
          RVAR=EBROAD ! USE DEFAULT EBROAD
        END IF
        CALL XAS$SETR8('EBROAD',RVAR)

        ! BROADMODE
        CALL LINKEDLIST$EXISTD(LL_CNTL,'BROADMODE',1,TCHK)
        IF(TCHK) THEN
          CALL LINKEDLIST$GET(LL_CNTL,'BROADMODE',1,CHVAR)
          IF(CHVAR.NE.'G'.AND.CHVAR.NE.'L'.AND.CHVAR.NE.'N') THEN
            CALL ERROR$MSG('BROADMODE MUST BE G, L OR N')
            CALL ERROR$CHVAL('BROADMODE',CHVAR)
            CALL ERROR$STOP('XCNTL$XAS')
          END IF
        ELSE
          CHVAR=BROADMODE ! USE DEFAULT BROADMODE
        END IF
        CALL XAS$SETCH('BROADMODE',CHVAR)
        
        ! NORMAL VECTOR
        CALL LINKEDLIST$EXISTD(LL_CNTL,'NORMAL',1,TNORMAL)
        IF(TNORMAL) THEN
          CALL LINKEDLIST$GET(LL_CNTL,'NORMAL',1,RVAR3)
          IF(NORM2(RVAR3).LT.1.D-6) THEN
            CALL ERROR$MSG('NORMAL VECTOR CANNOT BE ZERO')
            CALL ERROR$I4VAL('ISPEC',ISPEC)
            CALL ERROR$STOP('XCNTL$XAS')
          END IF
          CALL XAS$SETR8A('NORMAL',3,RVAR3)
        ELSE IF(TNORMALDEF) THEN
          CALL XAS$SETR8A('NORMAL',3,NORMAL)
        ELSE
          CALL ERROR$MSG('NORMAL VECTOR MUST BE SET')
          CALL ERROR$I4VAL('ISPEC',ISPEC)
          CALL ERROR$STOP('XCNTL$XAS')
        END IF

        ! KDIR VECTOR
        CALL LINKEDLIST$EXISTD(LL_CNTL,'KDIR',1,TKDIR)
        IF(TKDIR) THEN
          CALL LINKEDLIST$GET(LL_CNTL,'KDIR',1,RVAR3)
          IF(NORM2(RVAR3).LT.1.D-6) THEN
            CALL ERROR$MSG('KDIR VECTOR CANNOT BE ZERO')
            CALL ERROR$I4VAL('ISPEC',ISPEC)
            CALL ERROR$STOP('XCNTL$XAS')
          END IF
          CALL XAS$SETR8A('KDIR',3,RVAR3)
        ELSE IF(TKDIRDEF) THEN
          CALL XAS$SETR8A('KDIR',3,KDIR)
        ELSE
          CALL ERROR$MSG('KDIR VECTOR MUST BE SET')
          CALL ERROR$I4VAL('ISPEC',ISPEC)
          CALL ERROR$STOP('XCNTL$XAS')
        END IF

        ! POLARIZATION VECTOR
        CALL LINKEDLIST$EXISTD(LL_CNTL,'POL',1,TPOL)
        IF(TPOL) THEN
          CALL LINKEDLIST$GET(LL_CNTL,'POL',1,REALPOL)
          CVAR2(1)=CMPLX(REALPOL(1),REALPOL(2),KIND=8)
          CVAR2(2)=CMPLX(REALPOL(3),REALPOL(4),KIND=8)
          ! IF(NORM2(CVAR2).LT.1.D-6) THEN
          !   CALL ERROR$MSG('POLARIZATION VECTOR CANNOT BE ZERO')
          !   CALL ERROR$I4VAL('ISPEC',ISPEC)
          !   CALL ERROR$STOP('XCNTL$XAS')
          ! END IF
          CALL XAS$SETC8A('POL',2,CVAR2)
        ELSE IF(TPOLDEF) THEN
          CALL XAS$SETC8A('POL',2,POL)
        ELSE
          CALL ERROR$MSG('POLARIZATION VECTOR MUST BE SET')
          CALL ERROR$I4VAL('ISPEC',ISPEC)
          CALL ERROR$STOP('XCNTL$XAS')
        END IF
        CALL XAS$UNSELECT
      ENDDO ! END ISPEC
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE XCNTL$XAS
!
!     ==========================================================================
!     ==========================================================================
!     ==                 SIMULATION MODULE FUNCTIONS                          ==
!     ==========================================================================
!     ==========================================================================
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION$CONSISTENCY  ! MARK: SIMULATION$CONSISTENCY
!     **************************************************************************
!     ** CHECK CONSISTENCY OF THE TWO SIMULATIONS                             **
!     **************************************************************************
! TODO: IMPLEMENT CHECK IF BOTH SIMULATIONS HAVE THE SAME PARAMETERS FOR CERTAIN
!       PROPERTIES, SUCH AS THE NUMBER OF ATOMS, SPINS, K-POINTS, ETC.
      END SUBROUTINE SIMULATION$CONSISTENCY
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION_ATOMMAP  ! MARK: SIMULATION_ATOMMAP
!     **************************************************************************
!     ** CREATE ATOM MAPPING BETWEEN GROUND AND EXCITED STATE SIMULATION      **
!     **************************************************************************
      USE SIMULATION_MODULE, ONLY: SELECTED,GROUND,EXCITE,THIS,ATOMMAP
      IMPLICIT NONE
      INTEGER(4) :: NAT
      INTEGER(4) :: IAT1
      INTEGER(4) :: IAT2
      LOGICAL(4) :: FOUND
                          CALL TRACE$PUSH('SIMULATION_ATOMMAP')
      IF(SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('CANNOT CREATE ATOM MAPPING WHEN SIMULATION IS SELECTED')
        CALL ERROR$CHVAL('SELECTED SIMULATION ID: ',THIS%ID)
        CALL ERROR$STOP('SIMULATION_ATOMMAP')
      END IF
      ! DOES NOT PROTECT FROM ATOMID NOT SET IN GROUND AND EXCITE
      IF(.NOT.GROUND%INITIALIZED.OR..NOT.EXCITE%INITIALIZED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('BOTH SIMULATIONS MUST BE INITIALIZED')
        CALL ERROR$L4VAL('GROUND: ',GROUND%INITIALIZED)
        CALL ERROR$L4VAL('EXCITE: ',EXCITE%INITIALIZED)
        CALL ERROR$STOP('SIMULATION_ATOMMAP')
      END IF
      IF(ALLOCATED(ATOMMAP)) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('ATOMMAP ALREADY ALLOCATED')
      END IF
      ! CHECKED BEFORE THAT BOTH SIMULATIONS HAVE THE SAME NUMBER OF ATOMS
      NAT=GROUND%NAT
      ALLOCATE(ATOMMAP(NAT))
      DO IAT1=1,NAT
        FOUND=.FALSE.
        DO IAT2=1,NAT
          IF(GROUND%ATOMID(IAT1).EQ.EXCITE%ATOMID(IAT2)) THEN
            ATOMMAP(IAT1)=IAT2
            FOUND=.TRUE.
            EXIT
          END IF
        ENDDO ! IAT2
        IF(.NOT.FOUND) THEN
          CALL ERROR$MSG('ATOM NOT FOUND IN EXCITE SIMULATION')
          CALL ERROR$I4VAL('GROUND ATOM INDEX: ',IAT1)
          CALL ERROR$CHVAL('GROUND ATOM ID: ',GROUND%ATOMID(IAT1))
          CALL ERROR$STOP('SIMULATION_ATOMMAP')
        END IF
      ENDDO ! IAT1
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE SIMULATION_ATOMMAP
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION$SELECT(ID)  ! MARK: SIMULATION$SELECT
!     **************************************************************************
!     ** SELECT SIMULATION IN SIMULATION MODULE                               **
!     **************************************************************************
      USE SIMULATION_MODULE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      IF(SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('CANNOT SELECT SIMULATION WHEN ALREADY SELECTED')
        CALL ERROR$CHVAL('SELECTED SIMULATION ID: ',THIS%ID)
        CALL ERROR$CHVAL('ID TO SELECT: ',ID)
        CALL ERROR$STOP('SIMULATION$SELECT')
      END IF
      IF(ID.EQ.'GROUND') THEN
        THIS=>GROUND
      ELSE IF(ID.EQ.'EXCITE') THEN
        THIS=>EXCITE
      ELSE
        CALL ERROR$MSG('SIMULATION ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID TO SELECT: ',ID)
        CALL ERROR$STOP('SIMULATION$SELECT')
      END IF
      SELECTED=.TRUE.
      RETURN
      END SUBROUTINE SIMULATION$SELECT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION$UNSELECT()  ! MARK: SIMULATION$UNSELECT
!     **************************************************************************
!     ** UNSELECT SIMULATION IN SIMULATION MODULE                             **
!     **************************************************************************
      USE SIMULATION_MODULE
      IMPLICIT NONE
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('CANNOT UNSELECT SIMULATION WHEN NOT SELECTED')
        CALL ERROR$STOP('SIMULATION$UNSELECT')
      END IF
      SELECTED=.FALSE.
      NULLIFY(THIS)
      RETURN
      END SUBROUTINE SIMULATION$UNSELECT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION$ISELECT(I)  ! MARK: SIMULATION$ISELECT
!     **************************************************************************
!     ** SELECT SIMULATION IN SIMULATION MODULE BY INDEX                      **
!     **************************************************************************
      USE SIMULATION_MODULE
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: I
      IF(SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('CANNOT SELECT SIMULATION WHEN ALREADY SELECTED')
        CALL ERROR$CHVAL('SELECTED SIMULATION ID: ',THIS%ID)
        CALL ERROR$I4VAL('INDEX TO SELECT: ',I)
        CALL ERROR$STOP('SIMULATION$ISELECT')
      END IF
      IF(I.EQ.1) THEN
        THIS=>GROUND
      ELSE IF(I.EQ.2) THEN
        THIS=>EXCITE
      ELSE
        CALL ERROR$MSG('SIMULATION INDEX NOT RECOGNIZED')
        CALL ERROR$I4VAL('INDEX TO SELECT: ',I)
        CALL ERROR$STOP('SIMULATION$ISELECT')
      END IF
      SELECTED=.TRUE.
      RETURN
      END SUBROUTINE SIMULATION$ISELECT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION$INIT(NAT,NSP,NKPT,NSPIN,NDIM,NPRO,LNXX,FLAG)  ! MARK: SIMULATION$INIT
!     **************************************************************************
!     ** INITIALIZE SIMULATION MODULE                                         **
!     ** NAT,NSP,NKPT,NSPIN,NDIM,NPRO,LNXX,FLAG ARE SIMULATION PARAMETERS     **
!     ** REQUIRES SELECTED SIMULATION                                         **
!     **************************************************************************
      USE SIMULATION_MODULE
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: NAT
      INTEGER(4), INTENT(IN) :: NSP
      INTEGER(4), INTENT(IN) :: NKPT
      INTEGER(4), INTENT(IN) :: NSPIN
      INTEGER(4), INTENT(IN) :: NDIM
      INTEGER(4), INTENT(IN) :: NPRO
      INTEGER(4), INTENT(IN) :: LNXX
      CHARACTER(6), INTENT(IN) :: FLAG
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SIMULATION SELECTED')
        CALL ERROR$STOP('SIMULATION$INIT')
      END IF
      IF(THIS%INITIALIZED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('SIMULATION ALREADY INITIALIZED')
        CALL ERROR$CHVAL('SELECTED SIMULATION ID: ',THIS%ID)
        CALL ERROR$STOP('SIMULATION$INIT')
      END IF
      THIS%NAT=NAT
      THIS%NSP=NSP
      THIS%NKPT=NKPT
      THIS%NSPIN=NSPIN
      THIS%NDIM=NDIM
      THIS%NPRO=NPRO
      THIS%LNXX=LNXX
      THIS%FLAG=FLAG
      ! ALLOCATE(THIS%LMNX(NSP))
      ALLOCATE(THIS%LNX(NSP))
      ALLOCATE(THIS%LOX(LNXX,NSP))
      ! ALLOCATE(THIS%MAP(NAT,LNXX))
      ALLOCATE(THIS%R(3,NAT))
      ALLOCATE(THIS%ATOMID(NAT))
      ALLOCATE(THIS%ISPECIES(NAT))
      ALLOCATE(THIS%XK(3,NKPT))
      ALLOCATE(THIS%WKPT(NKPT))
      ! ALLOCATE(THIS%DENMAT(LMNXX,LMNXX,NDIM,NAT))
      THIS%INITIALIZED=.TRUE.
      RETURN
      END SUBROUTINE SIMULATION$INIT

!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION$REPORT(NFIL)  ! MARK: SIMULATION$REPORT
!     **************************************************************************
!     ** REPORT SIMULATION PARAMETERS                                         **
!     ** REQUIRES SELECTED SIMULATION                                         **
!     **************************************************************************
      USE SIMULATION_MODULE, ONLY: THIS,SELECTED
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: NFIL
      INTEGER(4) :: NTASKS,THISTASK,RTASK
      REAL(8) :: EV
      INTEGER(4) :: IAT,ISP,ISPIN,IKPT
      INTEGER(4), ALLOCATABLE :: DUMMY(:,:)
      CHARACTER(256) :: FORMAT
      REAL(8) :: SVAR

      CALL MPE$QUERY('~',NTASKS,THISTASK)
      CALL KSMAP$READTASK(RTASK)
      IF(THISTASK.NE.RTASK) RETURN
                          CALL TRACE$PUSH('SIMULATION$REPORT')
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SIMULATION SELECTED')
        CALL ERROR$STOP('SIMULATION$REPORT')
      END IF
      IF(.NOT.THIS%INITIALIZED) THEN
        CALL ERROR$MSG('SIMULATION NOT INITIALIZED')
        CALL ERROR$CHVAL('SELECTED SIMULATION ID: ',THIS%ID)
        CALL ERROR$STOP('SIMULATION$REPORT')
      END IF
      CALL CONSTANTS('EV',EV)
      WRITE(NFIL,'(80("#"))')
      WRITE(NFIL,FMT='(A20,A14)')'SIMULATION REPORT',THIS%ID
      WRITE(NFIL,'(80("#"))')
      WRITE(NFIL,FMT='(A10,X,A)')'FILE:',TRIM(THIS%FILE)
      WRITE(NFIL,FMT='(A10,I10)')'NAT:',THIS%NAT
      WRITE(NFIL,FMT='(A10,I10)')'NSP:',THIS%NSP
      WRITE(NFIL,FMT='(A10,I10)')'NKPT:',THIS%NKPT
      WRITE(NFIL,FMT='(A10,I10)')'NSPIN:',THIS%NSPIN
      WRITE(NFIL,FMT='(A10,I10)')'NDIM:',THIS%NDIM
      WRITE(NFIL,FMT='(A10,I10)')'NPRO:',THIS%NPRO
      WRITE(NFIL,FMT='(A10,I10)')'LNXX:',THIS%LNXX
      WRITE(NFIL,FMT='(A10,L10)')'TINV:',THIS%TINV
      WRITE(NFIL,FMT='(A10,3I10)')'NKDIV:',THIS%NKDIV(:)
      WRITE(NFIL,FMT='(A10,3I10)')'ISHIFT:',THIS%ISHIFT(:)
      WRITE(NFIL,FMT='(A10,F10.4)')'RNTOT:',THIS%RNTOT
      WRITE(NFIL,FMT='(A10,F10.4)')'NEL:',THIS%NEL
      ! NEEDS TO BE CALLED TO TRIGGER CALCULATION OF ETOT AND ECORE
      CALL SIMULATION$GETR8('ETOT',SVAR)
      WRITE(NFIL,FMT='(A10,F20.8)')'ETOT [EV]:',THIS%ETOT/EV
      WRITE(NFIL,FMT='(A10,F20.8)')'EDFT [EV]:',THIS%EDFT/EV
      WRITE(NFIL,FMT='(A10,F20.8)')'ECORE [EV]:',THIS%ECORE/EV
      WRITE(NFIL,FMT='(A10,I10)')'SPACEGR.:',THIS%SPACEGROUP
      WRITE(NFIL,FMT='(A10,L10)')'TSHIFT:',THIS%TSHIFT
      WRITE(NFIL,FMT='(A10,3F10.4)')'RBAS:',THIS%RBAS(:,1)
      DO IAT=2,3
        WRITE(NFIL,FMT='(A10,3F10.4)')' ',THIS%RBAS(:,IAT)
      ENDDO
      WRITE(NFIL,'(A)')''
      WRITE(NFIL,FMT='(5A10)')'ATOM','X','Y','Z','SPECIES'
      DO IAT=1,THIS%NAT
        WRITE(NFIL,FMT='(A10,3F10.4,I10)')THIS%ATOMID(IAT),THIS%R(:,IAT),THIS%ISPECIES(IAT)
      ENDDO
      WRITE(NFIL,'(A)')''
      ! MAP IS ONLY CALCULATED ON FIRST CALL TO SIMULATION$GETI4A
      ! HERE IT IS CALLED IN CASE IT WAS NOT CALLED BEFORE
      ALLOCATE(DUMMY(THIS%NAT,THIS%LNXX))
      CALL SIMULATION$GETI4A('MAP',THIS%NAT*THIS%LNXX,DUMMY)
      DEALLOCATE(DUMMY)
      WRITE(NFIL,FMT='(A)')'MAPPING OF PROJECTIONS (INDEX-1)'
      WRITE(NFIL,FMT='(A10,A10)')'ATOM','MAP'
      WRITE(FORMAT,'("(I10,",I0,"I10)")')THIS%LNXX
      DO IAT=1,THIS%NAT
        WRITE(NFIL,FMT=FORMAT)IAT,THIS%MAP(IAT,:)
      ENDDO
      WRITE(NFIL,'(A)')''
      WRITE(NFIL,FMT='(6A10)')'IKPT','ISPIN','XK1','XK2','XK3','WKPT'
      DO IKPT=1,THIS%NKPT
        DO ISPIN=1,THIS%NSPIN
          WRITE(NFIL,FMT='(2I10,4F10.6)')IKPT,ISPIN,THIS%XK(:,IKPT),THIS%WKPT(IKPT)
        ENDDO
      ENDDO
      WRITE(NFIL,'(A)')''
      FLUSH(NFIL)
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE SIMULATION$REPORT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION$SETI4A(ID,LEN,VAL)  ! MARK: SIMULATION$SETI4A
!     **************************************************************************
!     ** SET INTEGER VALUE IN SIMULATION MODULE                               **
!     ** REQUIRES SELECTED SIMULATION                                         **
!     **************************************************************************
      USE SIMULATION_MODULE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: LEN
      INTEGER(4), INTENT(IN) :: VAL(LEN)
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SIMULATION SELECTED')
        CALL ERROR$STOP('SIMULATION$SETI4')
      END IF
      IF(.NOT.THIS%INITIALIZED) THEN
        CALL ERROR$MSG('SIMULATION NOT INITIALIZED')
        CALL ERROR$CHVAL('SELECTED SIMULATION ID: ',THIS%ID)
        CALL ERROR$STOP('SIMULATION$SETI4')
      END IF
      IF(ID.EQ.'LMNX') THEN
        IF(LEN.NE.THIS%NSP) THEN
          CALL ERROR$MSG('LENGTH OF LMNX ARRAY MUST BE EQUAL TO NSP')
          CALL ERROR$I4VAL('LENGTH OF LMNX: ',LEN)
          CALL ERROR$I4VAL('NSP: ',THIS%NSP)
          CALL ERROR$STOP('SIMULATION$SETI4')
        END IF
        THIS%LMNX=VAL
      ELSE IF(ID.EQ.'LNX') THEN
        IF(LEN.NE.THIS%NSP) THEN
          CALL ERROR$MSG('LENGTH OF LNX ARRAY MUST BE EQUAL TO NSP')
          CALL ERROR$I4VAL('LENGTH OF LNX: ',LEN)
          CALL ERROR$I4VAL('NSP: ',THIS%NSP)
          CALL ERROR$STOP('SIMULATION$SETI4')
        END IF
        THIS%LNX=VAL
      ELSE IF(ID.EQ.'LOX') THEN
        IF(LEN.NE.THIS%LNXX*THIS%NSP) THEN
          CALL ERROR$MSG('LENGTH OF LOX ARRAY MUST BE EQUAL TO LNXX*NSP')
          CALL ERROR$I4VAL('LENGTH OF LOX: ',LEN)
          CALL ERROR$I4VAL('LNXX: ',THIS%LNXX)
          CALL ERROR$I4VAL('NSP: ',THIS%NSP)
          CALL ERROR$STOP('SIMULATION$SETI4')
        END IF
        THIS%LOX(:,:)=RESHAPE(VAL,(/THIS%LNXX,THIS%NSP/))
      ELSE IF(ID.EQ.'MAP') THEN
        IF(LEN.NE.THIS%NAT*THIS%LNXX) THEN
          CALL ERROR$MSG('LENGTH OF MAP ARRAY MUST BE EQUAL TO NAT*LNXX')
          CALL ERROR$I4VAL('LENGTH OF MAP: ',LEN)
          CALL ERROR$I4VAL('NAT: ',THIS%NAT)
          CALL ERROR$I4VAL('LNXX: ',THIS%LNXX)
          CALL ERROR$STOP('SIMULATION$SETI4')
        END IF
        THIS%MAP(:,:)=RESHAPE(VAL,(/THIS%NAT,THIS%LNXX/))
      ELSE IF(ID.EQ.'NKDIV') THEN
        IF(LEN.NE.3) THEN
          CALL ERROR$MSG('LENGTH OF NKDIV ARRAY MUST BE 3')
          CALL ERROR$I4VAL('LENGTH OF NKDIV: ',LEN)
          CALL ERROR$STOP('SIMULATION$SETI4')
        END IF
        THIS%NKDIV=VAL
      ELSE IF(ID.EQ.'ISHIFT') THEN
        IF(LEN.NE.3) THEN
          CALL ERROR$MSG('LENGTH OF ISHIFT ARRAY MUST BE 3')
          CALL ERROR$I4VAL('LENGTH OF ISHIFT: ',LEN)
          CALL ERROR$STOP('SIMULATION$SETI4')
        END IF
        THIS%ISHIFT=VAL
      ELSE IF(ID.EQ.'ISPECIES') THEN
        IF(LEN.NE.THIS%NAT) THEN
          CALL ERROR$MSG('LENGTH OF ISPECIES ARRAY MUST BE EQUAL TO NAT')
          CALL ERROR$I4VAL('LENGTH OF ISPECIES: ',LEN)
          CALL ERROR$I4VAL('NAT: ',THIS%NAT)
          CALL ERROR$STOP('SIMULATION$SETI4')
        END IF
        THIS%ISPECIES=VAL
      ELSE
        CALL ERROR$MSG('SIMULATION SETI4A ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('SIMULATION$SETI4')
      END IF 
      RETURN
      END SUBROUTINE SIMULATION$SETI4A
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION$GETI4A(ID,LEN,VAL)  ! MARK: SIMULATION$GETI4A
!     **************************************************************************
!     ** GET INTEGER VALUE ARRAY FROM SIMULATION MODULE                       **
!     ** REQUIRES SELECTED SIMULATION                                         **
!     **************************************************************************
      USE SIMULATION_MODULE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: LEN
      INTEGER(4), INTENT(OUT) :: VAL(LEN)
      INTEGER(4) :: ISP
      INTEGER(4) :: LN
      INTEGER(4) :: IPRO
      INTEGER(4) :: IAT
      INTEGER(4) :: L
      INTEGER(4) :: M
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SIMULATION SELECTED')
        CALL ERROR$STOP('SIMULATION$GETI4A')
      END IF
      IF(.NOT.THIS%INITIALIZED) THEN
        CALL ERROR$MSG('SIMULATION NOT INITIALIZED')
        CALL ERROR$CHVAL('SELECTED SIMULATION ID: ',THIS%ID)
        CALL ERROR$STOP('SIMULATION$GETI4A')
      END IF
      IF(ID.EQ.'LMNX') THEN
        IF(LEN.NE.THIS%NSP) THEN
          CALL ERROR$MSG('LENGTH OF LMNX ARRAY MUST BE EQUAL TO NSP')
          CALL ERROR$I4VAL('LENGTH OF LMNX: ',LEN)
          CALL ERROR$I4VAL('NSP: ',THIS%NSP)
          CALL ERROR$STOP('SIMULATION$GETI4A')
        END IF
        IF(.NOT.ALLOCATED(THIS%LMNX)) THEN
          ALLOCATE(THIS%LMNX(THIS%NSP))
          THIS%LMNX=0
          DO ISP=1,THIS%NSP
            DO LN=1,THIS%LNX(ISP)
              THIS%LMNX(ISP)=THIS%LMNX(ISP)+2*THIS%LOX(LN,ISP)+1
            ENDDO
          ENDDO
        END IF
        VAL=THIS%LMNX
      ELSE IF(ID.EQ.'LNX') THEN
        IF(LEN.NE.THIS%NSP) THEN
          CALL ERROR$MSG('LENGTH OF LNX ARRAY MUST BE EQUAL TO NSP')
          CALL ERROR$I4VAL('LENGTH OF LNX: ',LEN)
          CALL ERROR$I4VAL('NSP: ',THIS%NSP)
          CALL ERROR$STOP('SIMULATION$GETI4A')
        END IF
        VAL=THIS%LNX
      ELSE IF(ID.EQ.'LOX') THEN
        IF(LEN.NE.THIS%LNXX*THIS%NSP) THEN
          CALL ERROR$MSG('LENGTH OF LOX ARRAY MUST BE EQUAL TO LNXX*NSP')
          CALL ERROR$I4VAL('LENGTH OF LOX: ',LEN)
          CALL ERROR$I4VAL('LNXX: ',THIS%LNXX)
          CALL ERROR$I4VAL('NSP: ',THIS%NSP)
          CALL ERROR$STOP('SIMULATION$GETI4A')
        END IF
        VAL(:)=RESHAPE(THIS%LOX,(/THIS%LNXX*THIS%NSP/))
      ELSE IF(ID.EQ.'MAP') THEN
        IF(LEN.NE.THIS%NAT*THIS%LNXX) THEN
          CALL ERROR$MSG('LENGTH OF MAP ARRAY MUST BE EQUAL TO NAT*LNXX')
          CALL ERROR$I4VAL('LENGTH OF MAP: ',LEN)
          CALL ERROR$I4VAL('NAT: ',THIS%NAT)
          CALL ERROR$I4VAL('LNXX: ',THIS%LNXX)
          CALL ERROR$STOP('SIMULATION$GETI4A')
        END IF
        IF(.NOT.ALLOCATED(THIS%MAP)) THEN
          ALLOCATE(THIS%MAP(THIS%NAT,THIS%LNXX))
          THIS%MAP(:,:)=0
          IPRO=0
          DO IAT=1,THIS%NAT
            ISP=THIS%ISPECIES(IAT)
            DO LN=1,THIS%LNX(ISP)
              THIS%MAP(IAT,LN)=IPRO
              L=THIS%LOX(LN,ISP)
              DO M=1,2*L+1
                IPRO=IPRO+1
              ENDDO ! END M
            ENDDO ! END LN
          ENDDO ! END IAT
        END IF
        VAL(:)=RESHAPE(THIS%MAP,(/THIS%NAT*THIS%LNXX/))
      ELSE IF(ID.EQ.'NKDIV') THEN
        IF(LEN.NE.3) THEN
          CALL ERROR$MSG('LENGTH OF NKDIV ARRAY MUST BE 3')
          CALL ERROR$I4VAL('LENGTH OF NKDIV: ',LEN)
          CALL ERROR$STOP('SIMULATION$GETI4A')
        END IF
        VAL=THIS%NKDIV
      ELSE IF(ID.EQ.'ISHIFT') THEN
        IF(LEN.NE.3) THEN
          CALL ERROR$MSG('LENGTH OF ISHIFT ARRAY MUST BE 3')
          CALL ERROR$I4VAL('LENGTH OF ISHIFT: ',LEN)
          CALL ERROR$STOP('SIMULATION$GETI4A')
        END IF
        VAL=THIS%ISHIFT
      ELSE IF(ID.EQ.'ISPECIES') THEN
        IF(LEN.NE.THIS%NAT) THEN
          CALL ERROR$MSG('LENGTH OF ISPECIES ARRAY MUST BE EQUAL TO NAT')
          CALL ERROR$I4VAL('LENGTH OF ISPECIES: ',LEN)
          CALL ERROR$I4VAL('NAT: ',THIS%NAT)
          CALL ERROR$STOP('SIMULATION$GETI4A')
        END IF
        VAL=THIS%ISPECIES
      ELSE
        CALL ERROR$MSG('SIMULATION GETI4A ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('SIMULATION$GETI4A')
      END IF
      RETURN
      END SUBROUTINE SIMULATION$GETI4A
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION$SETI4(ID,VAL)  ! MARK: SIMULATION$SETI4
!     **************************************************************************
!     ** SET INTEGER VALUE IN SIMULATION MODULE                               **
!     ** REQUIRES SELECTED SIMULATION                                         **
!     **************************************************************************
      USE SIMULATION_MODULE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: VAL
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SIMULATION SELECTED')
        CALL ERROR$STOP('SIMULATION$SETI4')
      END IF
      IF(.NOT.THIS%INITIALIZED) THEN
        CALL ERROR$MSG('SIMULATION NOT INITIALIZED')
        CALL ERROR$CHVAL('SELECTED SIMULATION ID: ',THIS%ID)
        CALL ERROR$STOP('SIMULATION$SETI4')
      END IF
      IF(ID.EQ.'SPACEGROUP') THEN
        THIS%SPACEGROUP=VAL
      ELSE
        CALL ERROR$MSG('SIMULATION SETI4 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('SIMULATION$SETI4')
      END IF
      RETURN
      END SUBROUTINE SIMULATION$SETI4
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION$GETI4(ID,VAL)  ! MARK: SIMULATION$GETI4
!     **************************************************************************
!     ** GET INTEGER VALUE FROM SIMULATION MODULE                             **
!     ** REQUIRES SELECTED SIMULATION                                         **
!     **************************************************************************
      USE SIMULATION_MODULE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(OUT) :: VAL
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SIMULATION SELECTED')
        CALL ERROR$STOP('SIMULATION$GETI4')
      END IF
      IF(.NOT.THIS%INITIALIZED) THEN
        CALL ERROR$MSG('SIMULATION NOT INITIALIZED')
        CALL ERROR$CHVAL('SELECTED SIMULATION ID: ',THIS%ID)
        CALL ERROR$STOP('SIMULATION$GETI4')
      END IF
      IF(ID.EQ.'NAT') THEN
        VAL=THIS%NAT
      ELSE IF(ID.EQ.'NSP') THEN
        VAL=THIS%NSP
      ELSE IF(ID.EQ.'NKPT') THEN
        VAL=THIS%NKPT
      ELSE IF(ID.EQ.'NSPIN') THEN
        VAL=THIS%NSPIN
      ELSE IF(ID.EQ.'NDIM') THEN
        VAL=THIS%NDIM
      ELSE IF(ID.EQ.'NPRO') THEN
        VAL=THIS%NPRO
      ELSE IF(ID.EQ.'LNXX') THEN
        VAL=THIS%LNXX
      ELSE IF(ID.EQ.'SPACEGROUP') THEN
        VAL=THIS%SPACEGROUP
      ELSE
        CALL ERROR$MSG('SIMULATION GETI4 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('SIMULATION$GETI4')
      END IF
      RETURN
      END SUBROUTINE SIMULATION$GETI4
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION$SETR8A(ID,LEN,VAL)  ! MARK: SIMULATION$SETR8A
!     **************************************************************************
!     ** SET REAL VALUE ARRAY IN SIMULATION MODULE                            **
!     ** REQUIRES SELECTED SIMULATION                                         **
!     **************************************************************************
      USE SIMULATION_MODULE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: LEN
      REAL(8), INTENT(IN) :: VAL(LEN)
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SIMULATION SELECTED')
        CALL ERROR$STOP('SIMULATION$SETR8A')
      END IF
      IF(.NOT.THIS%INITIALIZED) THEN
        CALL ERROR$MSG('SIMULATION NOT INITIALIZED')
        CALL ERROR$CHVAL('SELECTED SIMULATION ID: ',THIS%ID)
        CALL ERROR$STOP('SIMULATION$SETR8A')
      END IF
      IF(ID.EQ.'RBAS') THEN
        IF(LEN.NE.9) THEN
          CALL ERROR$MSG('LENGTH OF RBAS ARRAY MUST BE 9')
          CALL ERROR$I4VAL('LENGTH OF RBAS: ',LEN)
          CALL ERROR$STOP('SIMULATION$SETR8A')
        END IF
        THIS%RBAS=RESHAPE(VAL,(/3,3/))
        THIS%VCELL=THIS%RBAS(1,1)*(THIS%RBAS(2,2)*THIS%RBAS(3,3)-THIS%RBAS(2,3)*THIS%RBAS(3,2)) &
     &         +THIS%RBAS(2,1)*(THIS%RBAS(3,2)*THIS%RBAS(1,3)-THIS%RBAS(3,3)*THIS%RBAS(1,2)) &
     &         +THIS%RBAS(3,1)*(THIS%RBAS(1,2)*THIS%RBAS(2,3)-THIS%RBAS(1,3)*THIS%RBAS(2,2)) 
      ELSE IF(ID.EQ.'R') THEN
        IF(LEN.NE.THIS%NAT*3) THEN
          CALL ERROR$MSG('LENGTH OF R ARRAY MUST BE EQUAL TO NAT*3')
          CALL ERROR$I4VAL('LENGTH OF R: ',LEN)
          CALL ERROR$I4VAL('NAT: ',THIS%NAT)
          CALL ERROR$STOP('SIMULATION$SETR8A')
        END IF
        THIS%R(:,:)=RESHAPE(VAL,(/3,THIS%NAT/))
      ELSE IF(ID.EQ.'XK') THEN
        IF(LEN.NE.THIS%NKPT*3) THEN
          CALL ERROR$MSG('LENGTH OF XK ARRAY MUST BE EQUAL TO NKPT*3')
          CALL ERROR$I4VAL('LENGTH OF XK: ',LEN)
          CALL ERROR$I4VAL('NKPT: ',THIS%NKPT)
          CALL ERROR$STOP('SIMULATION$SETR8A')
        END IF
        THIS%XK(:,:)=RESHAPE(VAL,(/3,THIS%NKPT/))
      ELSE IF(ID.EQ.'WKPT') THEN
        IF(LEN.NE.THIS%NKPT) THEN
          CALL ERROR$MSG('LENGTH OF WKPT ARRAY MUST BE EQUAL TO NKPT')
          CALL ERROR$I4VAL('LENGTH OF WKPT: ',LEN)
          CALL ERROR$I4VAL('NKPT: ',THIS%NKPT)
          CALL ERROR$STOP('SIMULATION$SETR8A')
        END IF
        THIS%WKPT(:)=VAL
      ELSE
        CALL ERROR$MSG('SIMULATION SETR8A ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('SIMULATION$SETR8A')
      END IF
      RETURN
      END SUBROUTINE SIMULATION$SETR8A
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION$GETR8A(ID,LEN,VAL)  ! MARK: SIMULATION$GETR8A
!     **************************************************************************
!     ** GET REAL VALUE ARRAY FROM SIMULATION MODULE                          **
!     ** REQUIRES SELECTED SIMULATION                                         **
!     **************************************************************************
      USE SIMULATION_MODULE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: LEN
      REAL(8), INTENT(OUT) :: VAL(LEN)
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SIMULATION SELECTED')
        CALL ERROR$STOP('SIMULATION$GETR8A')
      END IF
      IF(.NOT.THIS%INITIALIZED) THEN
        CALL ERROR$MSG('SIMULATION NOT INITIALIZED')
        CALL ERROR$CHVAL('SELECTED SIMULATION ID: ',THIS%ID)
        CALL ERROR$STOP('SIMULATION$GETR8A')
      END IF
      IF(ID.EQ.'RBAS') THEN
        IF(LEN.NE.9) THEN
          CALL ERROR$MSG('LENGTH OF RBAS ARRAY MUST BE 9')
          CALL ERROR$I4VAL('LENGTH OF RBAS: ',LEN)
          CALL ERROR$STOP('SIMULATION$GETR8A')
        END IF
        VAL(:)=RESHAPE(THIS%RBAS,(/9/))
      ELSE IF(ID.EQ.'R') THEN
        IF(LEN.NE.THIS%NAT*3) THEN
          CALL ERROR$MSG('LENGTH OF R ARRAY MUST BE EQUAL TO NAT*3')
          CALL ERROR$I4VAL('LENGTH OF R: ',LEN)
          CALL ERROR$I4VAL('NAT: ',THIS%NAT)
          CALL ERROR$STOP('SIMULATION$GETR8A')
        END IF
        VAL(:)=RESHAPE(THIS%R,(/3*THIS%NAT/))
      ELSE IF(ID.EQ.'XK') THEN
        IF(LEN.NE.THIS%NKPT*3) THEN
          CALL ERROR$MSG('LENGTH OF XK ARRAY MUST BE EQUAL TO NKPT*3')
          CALL ERROR$I4VAL('LENGTH OF XK: ',LEN)
          CALL ERROR$I4VAL('NKPT: ',THIS%NKPT)
          CALL ERROR$STOP('SIMULATION$GETR8A')
        END IF
        VAL(:)=RESHAPE(THIS%XK,(/3*THIS%NKPT/))
      ELSE IF(ID.EQ.'WKPT') THEN
        IF(LEN.NE.THIS%NKPT) THEN
          CALL ERROR$MSG('LENGTH OF WKPT ARRAY MUST BE EQUAL TO NKPT')
          CALL ERROR$I4VAL('LENGTH OF WKPT: ',LEN)
          CALL ERROR$I4VAL('NKPT: ',THIS%NKPT)
          CALL ERROR$STOP('SIMULATION$GETR8A')
        END IF
        VAL(:)=THIS%WKPT
      ELSE
        CALL ERROR$MSG('SIMULATION GETR8A ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('SIMULATION$GETR8A')
      END IF
      RETURN
      END SUBROUTINE SIMULATION$GETR8A
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION$SETR8(ID,VAL)  ! MARK: SIMULATION$SETR8
!     **************************************************************************
!     ** SET REAL VALUE IN SIMULATION MODULE                                  **
!     ** REQUIRES SELECTED SIMULATION                                         **
!     **************************************************************************
      USE SIMULATION_MODULE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      REAL(8), INTENT(IN) :: VAL
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SIMULATION SELECTED')
        CALL ERROR$STOP('SIMULATION$SETR8')
      END IF
      IF(.NOT.THIS%INITIALIZED) THEN
        CALL ERROR$MSG('SIMULATION NOT INITIALIZED')
        CALL ERROR$CHVAL('SELECTED SIMULATION ID: ',THIS%ID)
        CALL ERROR$STOP('SIMULATION$SETR8')
      END IF
      IF(ID.EQ.'RNTOT') THEN
        THIS%RNTOT=VAL
      ELSE IF(ID.EQ.'NEL') THEN
        THIS%NEL=VAL
      ELSE IF(ID.EQ.'ETOT') THEN
        THIS%ETOT=VAL
      ELSE IF(ID.EQ.'EDFT') THEN
        THIS%EDFT=VAL
      ELSE IF(ID.EQ.'ECORE') THEN
        THIS%ECORE=VAL
      ELSE
        CALL ERROR$MSG('SIMULATION SETR8 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('SIMULATION$SETR8')
      END IF
      RETURN
      END SUBROUTINE SIMULATION$SETR8
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION$GETR8(ID,VAL)  ! MARK: SIMULATION$GETR8
!     **************************************************************************
!     ** GET REAL VALUE FROM SIMULATION MODULE                                **
!     ** REQUIRES SELECTED SIMULATION                                         **
!     **************************************************************************
      USE SIMULATION_MODULE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      REAL(8), INTENT(OUT) :: VAL
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SIMULATION SELECTED')
        CALL ERROR$STOP('SIMULATION$GETR8')
      END IF
      IF(.NOT.THIS%INITIALIZED) THEN
        CALL ERROR$MSG('SIMULATION NOT INITIALIZED')
        CALL ERROR$CHVAL('SELECTED SIMULATION ID: ',THIS%ID)
        CALL ERROR$STOP('SIMULATION$GETR8')
      END IF
      IF(ID.EQ.'RNTOT') THEN
        VAL=THIS%RNTOT
      ELSE IF(ID.EQ.'NEL') THEN
        VAL=THIS%NEL
      ELSE IF(ID.EQ.'ETOT') THEN
        ! IF ETOT IS HUGE, IT MEANS IT HAS NOT BEEN CALCULATED YET
        IF(THIS%ETOT.EQ.HUGE(1.D0)) THEN
          ! IF ECORE IS HUGE, IT MEANS IT HAS NOT BEEN CALCULATED YET
          IF(THIS%ECORE.EQ.HUGE(1.D0)) CALL SIMULATION_ECORE
          THIS%ETOT=THIS%EDFT+THIS%ECORE
        END IF
        VAL=THIS%ETOT
      ELSE IF(ID.EQ.'EDFT') THEN
        VAL=THIS%EDFT
      ELSE IF(ID.EQ.'ECORE') THEN
        ! IF ECORE IS HUGE, IT MEANS IT HAS NOT BEEN CALCULATED YET
        IF(THIS%ECORE.EQ.HUGE(1.D0)) CALL SIMULATION_ECORE
        VAL=THIS%ECORE
      ELSE IF(ID.EQ.'VCELL') THEN
        ! IF VCELL IS NEGATIVE HUGE, IT MEANS IT HAS NOT BEEN CALCULATED YET
        IF(THIS%VCELL.EQ.-HUGE(1.D0)) THEN
          CALL ERROR$MSG('VCELL NOT CALCULATED YET, NEEDS RBAS')
          CALL ERROR$CHVAL('SELECTED SIMULATION ID: ',THIS%ID)
          CALL ERROR$STOP('SIMULATION$GETR8')
        END IF
        VAL=THIS%VCELL  
      ELSE
        CALL ERROR$MSG('SIMULATION GETR8 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('SIMULATION$GETR8')
      END IF
      RETURN
      END SUBROUTINE SIMULATION$GETR8
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION$SETL4(ID,VAL)  ! MARK: SIMULATION$SETL4
!     **************************************************************************
!     ** SET LOGICAL VALUE IN SIMULATION MODULE                               **
!     ** REQUIRES SELECTED SIMULATION                                         **
!     **************************************************************************
      USE SIMULATION_MODULE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      LOGICAL(4), INTENT(IN) :: VAL
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SIMULATION SELECTED')
        CALL ERROR$STOP('SIMULATION$SETL4')
      END IF
      IF(.NOT.THIS%INITIALIZED) THEN
        CALL ERROR$MSG('SIMULATION NOT INITIALIZED')
        CALL ERROR$CHVAL('SELECTED SIMULATION ID: ',THIS%ID)
        CALL ERROR$STOP('SIMULATION$SETL4')
      END IF
      IF(ID.EQ.'TINV') THEN
        THIS%TINV=VAL
      ELSE IF(ID.EQ.'TSHIFT') THEN
        THIS%TSHIFT=VAL
      ELSE
        CALL ERROR$MSG('SIMULATION SETL4 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('SIMULATION$SETL4')
      END IF
      RETURN
      END SUBROUTINE SIMULATION$SETL4
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION$GETL4(ID,VAL)  ! MARK: SIMULATION$GETL4
!     **************************************************************************
!     ** GET LOGICAL VALUE FROM SIMULATION MODULE                             **
!     ** REQUIRES SELECTED SIMULATION                                         **
!     **************************************************************************
      USE SIMULATION_MODULE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      LOGICAL(4), INTENT(OUT) :: VAL
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SIMULATION SELECTED')
        CALL ERROR$STOP('SIMULATION$GETL4')
      END IF
      IF(.NOT.THIS%INITIALIZED) THEN
        CALL ERROR$MSG('SIMULATION NOT INITIALIZED')
        CALL ERROR$CHVAL('SELECTED SIMULATION ID: ',THIS%ID)
        CALL ERROR$STOP('SIMULATION$GETL4')
      END IF
      IF(ID.EQ.'TINV') THEN
        VAL=THIS%TINV
      ELSE IF(ID.EQ.'TSHIFT') THEN
        VAL=THIS%TSHIFT
      ELSE
        CALL ERROR$MSG('SIMULATION GETL4 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('SIMULATION$GETL4')
      END IF
      RETURN
      END SUBROUTINE SIMULATION$GETL4
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION$SETCHA(ID,LEN,VAL)  ! MARK: SIMULATION$SETCHA
!     **************************************************************************
!     ** SET CHARACTER VALUE ARRAY IN SIMULATION MODULE                       **
!     ** REQUIRES SELECTED SIMULATION                                         **
!     **************************************************************************
      USE SIMULATION_MODULE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: LEN
      CHARACTER(*), INTENT(IN) :: VAL(LEN)
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SIMULATION SELECTED')
        CALL ERROR$STOP('SIMULATION$SETCHA')
      END IF
      IF(.NOT.THIS%INITIALIZED) THEN
        CALL ERROR$MSG('SIMULATION NOT INITIALIZED')
        CALL ERROR$CHVAL('SELECTED SIMULATION ID: ',THIS%ID)
        CALL ERROR$STOP('SIMULATION$SETCHA')
      END IF
      IF(ID.EQ.'ATOMID') THEN
        IF(LEN.NE.THIS%NAT) THEN
          CALL ERROR$MSG('LENGTH OF ATOMID ARRAY MUST BE EQUAL TO NAT')
          CALL ERROR$I4VAL('LENGTH OF ATOMID: ',LEN)
          CALL ERROR$I4VAL('NAT: ',THIS%NAT)
          CALL ERROR$STOP('SIMULATION$SETCHA')
        END IF
        THIS%ATOMID=VAL
      ELSE
        CALL ERROR$MSG('SIMULATION SETCHA ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('SIMULATION$SETCHA')
      END IF
      RETURN
      END SUBROUTINE SIMULATION$SETCHA
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION$GETCHA(ID,LEN,VAL)  ! MARK: SIMULATION$GETCHA
!     **************************************************************************
!     ** GET CHARACTER VALUE ARRAY FROM SIMULATION MODULE                     **
!     ** REQUIRES SELECTED SIMULATION                                         **
!     **************************************************************************
      USE SIMULATION_MODULE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: LEN
      CHARACTER(*), INTENT(OUT) :: VAL(LEN)
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SIMULATION SELECTED')
        CALL ERROR$STOP('SIMULATION$GETCHA')
      END IF
      IF(.NOT.THIS%INITIALIZED) THEN
        CALL ERROR$MSG('SIMULATION NOT INITIALIZED')
        CALL ERROR$CHVAL('SELECTED SIMULATION ID: ',THIS%ID)
        CALL ERROR$STOP('SIMULATION$GETCHA')
      END IF
      IF(ID.EQ.'ATOMID') THEN
        IF(LEN.NE.THIS%NAT) THEN
          CALL ERROR$MSG('LENGTH OF ATOMID ARRAY MUST BE EQUAL TO NAT')
          CALL ERROR$I4VAL('LENGTH OF ATOMID: ',LEN)
          CALL ERROR$I4VAL('NAT: ',THIS%NAT)
          CALL ERROR$STOP('SIMULATION$GETCHA')
        END IF
        VAL=THIS%ATOMID
      ELSE
        CALL ERROR$MSG('SIMULATION GETCHA ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('SIMULATION$GETCHA')
      END IF
      RETURN
      END SUBROUTINE SIMULATION$GETCHA
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION$SETCH(ID,VAL)  ! MARK: SIMULATION$SETCH
!     **************************************************************************
!     ** SET CHARACTER VALUE IN SIMULATION MODULE                             **
!     ** CAN SET VALUES BEFORE INITIALIZATION                                 **
!     ** REQUIRES SELECTED SIMULATION                                         **
!     **************************************************************************
      USE SIMULATION_MODULE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      CHARACTER(*), INTENT(IN) :: VAL
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SIMULATION SELECTED')
        CALL ERROR$STOP('SIMULATION$SETCH')
      END IF
      IF(ID.EQ.'ID') THEN
        THIS%ID=VAL
      ELSE IF(ID.EQ.'FILE') THEN
        THIS%FILE=VAL
      ELSE
        CALL ERROR$MSG('SIMULATION SETCH ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('SIMULATION$SETCH')
      END IF
      RETURN
      END SUBROUTINE SIMULATION$SETCH
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION$GETCH(ID,VAL)  ! MARK: SIMULATION$GETCH
!     **************************************************************************
!     ** GET CHARACTER VALUE FROM SIMULATION MODULE                           **
!     ** REQUIRES SELECTED SIMULATION                                         **
!     **************************************************************************
      USE SIMULATION_MODULE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      CHARACTER(*), INTENT(OUT) :: VAL
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SIMULATION SELECTED')
        CALL ERROR$STOP('SIMULATION$GETCH')
      END IF
      IF(ID.EQ.'ID') THEN
        VAL=THIS%ID
      ELSE IF(ID.EQ.'FILE') THEN
        VAL=THIS%FILE
      ELSE IF(ID.EQ.'FLAG') THEN
        IF(.NOT.THIS%INITIALIZED) THEN
        CALL ERROR$MSG('SIMULATION NOT INITIALIZED')
        CALL ERROR$CHVAL('SELECTED SIMULATION ID: ',THIS%ID)
        CALL ERROR$STOP('SIMULATION$GETCH')
      END IF
        VAL=THIS%FLAG
      ELSE
        CALL ERROR$MSG('SIMULATION GETCH ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('SIMULATION$GETCH')
      END IF
      RETURN
      END SUBROUTINE SIMULATION$GETCH
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SIMULATION_ECORE
!     **************************************************************************
!     ** CALCULATE ECORE FOR SELECTED SIMULATION                              **
!     ** REQUIRES SELECTED SIMULATION                                         **
!     **************************************************************************
      USE SIMULATION_MODULE, ONLY: SELECTED,THIS
      IMPLICIT NONE
      REAL(8) :: E
      INTEGER(4) :: IAT
      INTEGER(4) :: ISP
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SIMULATION SELECTED')
        CALL ERROR$STOP('SIMULATION_ECORE')
      END IF
      THIS%ECORE=0.D0
      CALL XSETUP$SELECT(THIS%ID)
      DO IAT=1,THIS%NAT
        ISP=THIS%ISPECIES(IAT)
        CALL XSETUP$GETR8('ECORE',ISP,E)
        THIS%ECORE=THIS%ECORE+E
      ENDDO
      CALL XSETUP$UNSELECT
      RETURN
      END SUBROUTINE SIMULATION_ECORE
!
!     ==========================================================================
!     ==========================================================================
!     ==                   XSETUP MODULE FUNCTIONS                            ==
!     ==========================================================================
!     ==========================================================================
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XSETUP$REPORT(NFIL)  ! MARK: XSETUP$REPORT
!     **************************************************************************
!     ** REPORT XSETUP ARRAY                                                  **
!     ** REQUIRES SELECTED XSETUP ARRAY                                       **
!     **************************************************************************
      USE XSETUP_MODULE, ONLY: THIS,SELECTED,THISNSP
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: NFIL
      INTEGER(4) :: ISP
      CHARACTER(256) :: FORMAT
      INTEGER(4) :: NTASKS,THISTASK,RTASK
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      CALL KSMAP$READTASK(RTASK)
      IF(RTASK.NE.THISTASK) RETURN
                          CALL TRACE$PUSH('XSETUP$REPORT')
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO XSETUP SELECTED')
        CALL ERROR$STOP('XSETUP$REPORT')
      END IF
      WRITE(NFIL,FMT='(5A10)')'SETUP','GID','ECORE[H]','LNX','LOX'
      ! LNXX IS THE SAME FOR ALL SPECIES WITHIN ONE SIMULATION
      WRITE(FORMAT,'("(2I10,F10.4,I10,",I0,"I10)")')THIS(1)%LNXX
      DO ISP=1,THISNSP
        WRITE(NFIL,FMT=FORMAT)ISP,THIS(ISP)%GID,THIS(ISP)%ECORE, &
     &                          THIS(ISP)%LNX,THIS(ISP)%L(:)
      ENDDO
      WRITE(NFIL,FMT='(A)')'RADIAL REPORT'
      CALL RADIAL$REPORT(NFIL)
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE XSETUP$REPORT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XSETUP$SELECT(ID)  ! MARK: XSETUP$SELECT
!     **************************************************************************
!     ** SELECT XSETUP ARRAY                                                  **
!     **************************************************************************
      USE XSETUP_MODULE, ONLY: GROUND,EXCITE,SELECTED,THIS, &
     &                         NSPGROUND,NSPEXCITE,THISNSP
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      IF(SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('CANNOT SELECT SETUP WHEN ALREADY SELECTED')
        CALL ERROR$STOP('XSETUP$SELECT')
      END IF
      IF(ID.EQ.'GROUND') THEN
        IF(.NOT.ASSOCIATED(GROUND)) THEN
          CALL ERROR$MSG('GROUND SETUP ARRAY NOT ALLOCATED')
          CALL ERROR$STOP('XSETUP$SELECT')
        END IF
        THIS=>GROUND
        THISNSP=NSPGROUND
      ELSE IF(ID.EQ.'EXCITE') THEN
        IF(.NOT.ASSOCIATED(EXCITE)) THEN
          CALL ERROR$MSG('EXCITE SETUP ARRAY NOT ALLOCATED')
          CALL ERROR$STOP('XSETUP$SELECT')
        END IF
        THIS=>EXCITE
        THISNSP=NSPEXCITE
      ELSE
        CALL ERROR$MSG('XSETUP SELECT ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('XSETUP$SELECT')
      END IF
      SELECTED=.TRUE.
      RETURN
      END SUBROUTINE XSETUP$SELECT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XSETUP$UNSELECT()  ! MARK: XSETUP$UNSELECT
!     **************************************************************************
!     ** UNSELECT XSETUP ARRAY                                                **
!     **************************************************************************
      USE XSETUP_MODULE, ONLY: SELECTED,THIS,THISNSP
      IMPLICIT NONE
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('CANNOT UNSELECT SETUP ARRAY WHEN NOT SELECTED')
        CALL ERROR$STOP('XSETUP$UNSELECT')
      END IF
      SELECTED=.FALSE.
      NULLIFY(THIS)
      THISNSP=0
      RETURN
      END SUBROUTINE XSETUP$UNSELECT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XSETUP$ISELECT(I)  ! MARK: XSETUP$ISELECT
!     **************************************************************************
!     ** SELECT XSETUP ARRAY BY INTEGER INDEX                                 **
!     **************************************************************************
      USE XSETUP_MODULE, ONLY: SELECTED,GROUND,EXCITE,THIS, &
     &                         NSPGROUND,NSPEXCITE,THISNSP
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: I
      IF(SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('CANNOT SELECT SETUP WHEN ALREADY SELECTED')
        CALL ERROR$STOP('XSETUP$ISELECT')
      END IF
      IF(I.EQ.1) THEN
        IF(.NOT.ASSOCIATED(GROUND)) THEN
          CALL ERROR$MSG('GROUND SETUP ARRAY NOT ALLOCATED')
          CALL ERROR$STOP('XSETUP$ISELECT')
        END IF
        THIS=>GROUND
        THISNSP=NSPGROUND
      ELSE IF(I.EQ.2) THEN
        IF(.NOT.ASSOCIATED(EXCITE)) THEN
          CALL ERROR$MSG('EXCITE SETUP ARRAY NOT ALLOCATED')
          CALL ERROR$STOP('XSETUP$ISELECT')
        END IF
        THIS=>EXCITE
        THISNSP=NSPEXCITE
      ELSE
        CALL ERROR$MSG('XSETUP ISELECT INDEX NOT RECOGNIZED')
        CALL ERROR$I4VAL('INDEX: ',I)
        CALL ERROR$STOP('XSETUP$ISELECT')
      END IF
      SELECTED=.TRUE.
      RETURN
      END SUBROUTINE XSETUP$ISELECT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XSETUP$INIT(I,NSP)  ! MARK: XSETUP$INIT
!     **************************************************************************
!     ** INITIALIZE XSETUP ARRAY                                              **  
!     ** REQUIRES SELECTED SETUP ARRAY                                        **
!     **************************************************************************
      USE XSETUP_MODULE, ONLY: GROUND,EXCITE,NSPGROUND,NSPEXCITE
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: I
      INTEGER(4), INTENT(IN) :: NSP
      IF(NSP.LE.0) THEN
        CALL ERROR$MSG('INVALID NUMBER OF SPECIES')
        CALL ERROR$I4VAL('NUMBER OF SPECIES: ',NSP)
        CALL ERROR$STOP('XSETUP$INIT')
      END IF
      IF(I.EQ.1) THEN
        IF(ASSOCIATED(GROUND)) THEN
          CALL ERROR$MSG('GROUND SETUP ARRAY ALREADY ALLOCATED')
          CALL ERROR$STOP('XSETUP$INIT')
        END IF
        ALLOCATE(GROUND(NSP))
        NSPGROUND=NSP
      ELSE IF(I.EQ.2) THEN
        IF(ASSOCIATED(EXCITE)) THEN
          CALL ERROR$MSG('EXCITE SETUP ARRAY ALREADY ALLOCATED')
          CALL ERROR$STOP('XSETUP$INIT')
        END IF
        ALLOCATE(EXCITE(NSP))
        NSPEXCITE=NSP
      ELSE
        CALL ERROR$MSG('XSETUP INIT INDEX NOT RECOGNIZED')
        CALL ERROR$I4VAL('INDEX: ',I)
        CALL ERROR$STOP('XSETUP$INIT')
      END IF
      RETURN
      END SUBROUTINE XSETUP$INIT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XSETUP$NEW(ISP,GID,ECORE,LNXX,LNX,L,NBATOM)  ! MARK: XSETUP$NEW
!     **************************************************************************
!     ** ADD NEW SETUP TO SETUP ARRAY                                         **
!     ** REQUIRES SELECTED SETUP ARRAY                                        **
!     **************************************************************************
      USE XSETUP_MODULE, ONLY: SELECTED,THIS
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: ISP
      INTEGER(4), INTENT(IN) :: GID
      REAL(8), INTENT(IN) :: ECORE
      INTEGER(4), INTENT(IN) :: LNXX
      INTEGER(4), INTENT(IN) :: LNX
      INTEGER(4), INTENT(IN) :: L(LNXX)
      INTEGER(4), INTENT(IN) :: NBATOM
      INTEGER(4) :: NR
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SETUP SELECTED')
        CALL ERROR$STOP('XSETUP$INIT')
      END IF
      IF(ISP.LE.0.OR.ISP.GT.SIZE(THIS)) THEN
        CALL ERROR$MSG('INVALID SPECIES INDEX')
        CALL ERROR$I4VAL('SPECIES INDEX: ',ISP)
        CALL ERROR$STOP('XSETUP$NEW')
      END IF
      CALL RADIAL$GETI4(GID,'NR',NR)
      THIS(ISP)%GID=GID
      THIS(ISP)%ECORE=ECORE
      THIS(ISP)%LNXX=LNXX
      THIS(ISP)%LNX=LNX
      ALLOCATE(THIS(ISP)%L(LNXX))
      THIS(ISP)%L(:)=L(:)
      ALLOCATE(THIS(ISP)%PSPHI(NR,LNX))
      ALLOCATE(THIS(ISP)%AEPHI(NR,LNX))
      THIS(ISP)%NBATOM=NBATOM
      ALLOCATE(THIS(ISP)%LATOM(NBATOM))
      ALLOCATE(THIS(ISP)%AEPSI(NR,NBATOM))
      RETURN
      END SUBROUTINE XSETUP$NEW
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XSETUP$GETI4A(ID,ISP,LEN,VAL)  ! MARK: XSETUP$GETI4A
!     **************************************************************************
!     ** GET INTEGER VALUE ARRAY FROM SELECTED SETUP                          **
!     ** REQUIRES SELECTED SETUP ARRAY                                        **
!     **************************************************************************
      USE XSETUP_MODULE, ONLY: SELECTED,THIS
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: ISP
      INTEGER(4), INTENT(IN) :: LEN
      INTEGER(4), INTENT(OUT) :: VAL(LEN)
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SETUP SELECTED')
        CALL ERROR$STOP('XSETUP$GETI4A')
      END IF
      IF(ISP.LE.0.OR.ISP.GT.SIZE(THIS)) THEN
        CALL ERROR$MSG('INVALID SPECIES INDEX')
        CALL ERROR$I4VAL('SPECIES INDEX: ',ISP)
        CALL ERROR$STOP('XSETUP$GETI4A')
      END IF
      IF(ID.EQ.'LATOM') THEN
        IF(LEN.NE.THIS(ISP)%NBATOM) THEN
          CALL ERROR$MSG('LENGTH OF LATOM ARRAY MUST BE EQUAL TO NBATOM')
          CALL ERROR$I4VAL('LENGTH OF LATOM: ',LEN)
          CALL ERROR$I4VAL('NBATOM: ',THIS(ISP)%NBATOM)
          CALL ERROR$STOP('XSETUP$GETI4A')
        END IF
        VAL(:)=THIS(ISP)%LATOM(:)
      ELSE
        CALL ERROR$MSG('XSETUP GETI4A ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('XSETUP$GETI4A')
      END IF
      RETURN
      END SUBROUTINE XSETUP$GETI4A
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XSETUP$SETI4A(ID,ISP,LEN,VAL)  ! MARK: XSETUP$SETI4A
!     **************************************************************************
!     ** SET INTEGER VALUE ARRAY IN SELECTED SETUP                            **
!     ** REQUIRES SELECTED SETUP ARRAY                                        **
!     **************************************************************************
      USE XSETUP_MODULE, ONLY: SELECTED,THIS
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: ISP
      INTEGER(4), INTENT(IN) :: LEN
      INTEGER(4), INTENT(IN) :: VAL(LEN)
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SETUP SELECTED')
        CALL ERROR$STOP('XSETUP$SETI4A')
      END IF
      IF(ISP.LE.0.OR.ISP.GT.SIZE(THIS)) THEN
        CALL ERROR$MSG('INVALID SPECIES INDEX')
        CALL ERROR$I4VAL('SPECIES INDEX: ',ISP)
        CALL ERROR$STOP('XSETUP$SETI4A')
      END IF
      IF(ID.EQ.'LATOM') THEN
        IF(LEN.NE.THIS(ISP)%NBATOM) THEN
          CALL ERROR$MSG('LENGTH OF LATOM ARRAY MUST BE EQUAL TO NBATOM')
          CALL ERROR$I4VAL('LENGTH OF LATOM: ',LEN)
          CALL ERROR$I4VAL('NBATOM: ',THIS(ISP)%NBATOM)
          CALL ERROR$STOP('XSETUP$SETI4A')
        END IF
        THIS(ISP)%LATOM(:)=VAL(:)
      ELSE
        CALL ERROR$MSG('XSETUP SETI4A ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('XSETUP$SETI4A')
      END IF
      RETURN
      END SUBROUTINE XSETUP$SETI4A
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XSETUP$GETI4(ID,ISP,VAL)  ! MARK: XSETUP$GETI4
!     **************************************************************************
!     ** GET INTEGER VALUE FROM SELECTED SETUP                                **
!     ** REQUIRES SELECTED SETUP ARRAY                                        **
!     **************************************************************************
      USE XSETUP_MODULE, ONLY: SELECTED,THIS
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: ISP
      INTEGER(4), INTENT(OUT) :: VAL
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SETUP SELECTED')
        CALL ERROR$STOP('XSETUP$GETI4')
      END IF
      IF(ISP.LE.0.OR.ISP.GT.SIZE(THIS)) THEN
        CALL ERROR$MSG('INVALID SPECIES INDEX')
        CALL ERROR$I4VAL('SPECIES INDEX: ',ISP)
        CALL ERROR$STOP('XSETUP$GETI4')
      END IF
      IF(ID.EQ.'GID') THEN
        VAL=THIS(ISP)%GID
      ELSE IF(ID.EQ.'NBATOM') THEN
        VAL=THIS(ISP)%NBATOM
      ELSE
        CALL ERROR$MSG('XSETUP GETI4 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('XSETUP$GETI4')
      END IF
      RETURN
      END SUBROUTINE XSETUP$GETI4
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XSETUP$GETR8A(ID,ISP,LEN,VAL)  ! MARK: XSETUP$GETR8A
!     **************************************************************************
!     ** GET REAL VALUE ARRAY FROM SELECTED SETUP                             **
!     ** REQUIRES SELECTED SETUP ARRAY                                        **
!     **************************************************************************
      USE XSETUP_MODULE, ONLY: SELECTED,THIS
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: ISP
      INTEGER(4), INTENT(IN) :: LEN
      REAL(8), INTENT(OUT) :: VAL(LEN)
      INTEGER(4) :: NR
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SETUP SELECTED')
        CALL ERROR$STOP('XSETUP$GETR8A')
      END IF
      IF(ISP.LE.0.OR.ISP.GT.SIZE(THIS)) THEN
        CALL ERROR$MSG('INVALID SPECIES INDEX')
        CALL ERROR$I4VAL('SPECIES INDEX: ',ISP)
        CALL ERROR$STOP('XSETUP$GETR8A')
      END IF
      CALL RADIAL$GETI4(THIS(ISP)%GID,'NR',NR)
      IF(ID.EQ.'PSPHI') THEN
        IF(LEN.NE.NR*THIS(ISP)%LNX) THEN
          CALL ERROR$MSG('LENGTH MUST BE EQUAL TO NR*LNX')
          CALL ERROR$I4VAL('LENGTH: ',LEN)
          CALL ERROR$I4VAL('NR*LNX: ',NR*THIS(ISP)%LNX)
          CALL ERROR$STOP('XSETUP$GETR8A')
        END IF
        VAL(:)=RESHAPE(THIS(ISP)%PSPHI,(/LEN/))
      ELSE IF(ID.EQ.'AEPHI') THEN
        IF(LEN.NE.NR*THIS(ISP)%LNX) THEN
          CALL ERROR$MSG('LENGTH MUST BE EQUAL TO NR*LNX')
          CALL ERROR$I4VAL('LENGTH: ',LEN)
          CALL ERROR$I4VAL('NR*LNX: ',NR*THIS(ISP)%LNX)
          CALL ERROR$STOP('XSETUP$GETR8A')
        END IF
        VAL(:)=RESHAPE(THIS(ISP)%AEPHI,(/LEN/))
      ELSE IF(ID.EQ.'AEPSI') THEN
        IF(LEN.NE.NR*THIS(ISP)%NBATOM) THEN
          CALL ERROR$MSG('LENGTH MUST BE EQUAL TO NR*NBATOM')
          CALL ERROR$I4VAL('LENGTH: ',LEN)
          CALL ERROR$I4VAL('NR*NBATOM: ',NR*THIS(ISP)%NBATOM)
          CALL ERROR$STOP('XSETUP$GETR8A')
        END IF
        VAL(:)=RESHAPE(THIS(ISP)%AEPSI,(/LEN/))
      ELSE
        CALL ERROR$MSG('XSETUP GETR8A ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('XSETUP$GETR8A')
      END IF
      RETURN
      END SUBROUTINE XSETUP$GETR8A
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XSETUP$SETR8A(ID,ISP,LEN,VAL)  ! MARK: XSETUP$SETR8A
!     **************************************************************************
!     ** SET REAL VALUE ARRAY IN SELECTED SETUP                               **
!     ** REQUIRES SELECTED SETUP ARRAY                                        **
!     **************************************************************************
      USE XSETUP_MODULE, ONLY: SELECTED,THIS
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: ISP
      INTEGER(4), INTENT(IN) :: LEN
      REAL(8), INTENT(IN) :: VAL(LEN)
      INTEGER(4) :: NR
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SETUP SELECTED')
        CALL ERROR$STOP('XSETUP$SETR8A')
      END IF
      IF(ISP.LE.0.OR.ISP.GT.SIZE(THIS)) THEN
        CALL ERROR$MSG('INVALID SPECIES INDEX')
        CALL ERROR$I4VAL('SPECIES INDEX: ',ISP)
        CALL ERROR$STOP('XSETUP$SETR8A')
      END IF
      CALL RADIAL$GETI4(THIS(ISP)%GID,'NR',NR)
      IF(ID.EQ.'PSPHI') THEN
        IF(LEN.NE.NR*THIS(ISP)%LNX) THEN
          CALL ERROR$MSG('LENGTH MUST BE EQUAL TO NR*LNX')
          CALL ERROR$I4VAL('LENGTH: ',LEN)
          CALL ERROR$I4VAL('NR*LNX: ',NR*THIS(ISP)%LNX)
          CALL ERROR$STOP('XSETUP$SETR8A')
        END IF
        THIS(ISP)%PSPHI(:,:)=RESHAPE(VAL,(/NR,THIS(ISP)%LNX/))
      ELSE IF(ID.EQ.'AEPHI') THEN
        IF(LEN.NE.NR*THIS(ISP)%LNX) THEN
          CALL ERROR$MSG('LENGTH MUST BE EQUAL TO NR*LNX')
          CALL ERROR$I4VAL('LENGTH: ',LEN)
          CALL ERROR$I4VAL('NR*LNX: ',NR*THIS(ISP)%LNX)
          CALL ERROR$STOP('XSETUP$SETR8A')
        END IF
        THIS(ISP)%AEPHI(:,:)=RESHAPE(VAL,(/NR,THIS(ISP)%LNX/))
      ELSE IF(ID.EQ.'AEPSI') THEN
        IF(LEN.NE.NR*THIS(ISP)%NBATOM) THEN
          CALL ERROR$MSG('LENGTH MUST BE EQUAL TO NR*NBATOM')
          CALL ERROR$I4VAL('LENGTH: ',LEN)
          CALL ERROR$I4VAL('NR*NBATOM: ',NR*THIS(ISP)%NBATOM)
          CALL ERROR$STOP('XSETUP$SETR8A')
        END IF
        THIS(ISP)%AEPSI(:,:)=RESHAPE(VAL,(/NR,THIS(ISP)%NBATOM/))
      ELSE
        CALL ERROR$MSG('XSETUP SETR8A ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('XSETUP$SETR8A')
      END IF
      RETURN
      END SUBROUTINE XSETUP$SETR8A
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XSETUP$GETR8(ID,ISP,VAL)  ! MARK: XSETUP$GETR8
!     **************************************************************************
!     ** GET REAL VALUE FROM SELECTED SETUP                                   **
!     ** REQUIRES SELECTED SETUP ARRAY                                        **
!     **************************************************************************
      USE XSETUP_MODULE, ONLY: SELECTED,THIS
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: ISP
      REAL(8), INTENT(OUT) :: VAL
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SETUP SELECTED')
        CALL ERROR$STOP('XSETUP$GETR8')
      END IF
      IF(ISP.LE.0.OR.ISP.GT.SIZE(THIS)) THEN
        CALL ERROR$MSG('INVALID SPECIES INDEX')
        CALL ERROR$I4VAL('SPECIES INDEX: ',ISP)
        CALL ERROR$STOP('XSETUP$GETR8')
      END IF
      IF(ID.EQ.'ECORE') THEN
        VAL=THIS(ISP)%ECORE
      ELSE
        CALL ERROR$MSG('XSETUP GETR8 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('XSETUP$GETR8')
      END IF
      RETURN
      END SUBROUTINE XSETUP$GETR8
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XSETUP$SETR8(ID,ISP,VAL)  ! MARK: XSETUP$SETR8
!     **************************************************************************
!     ** SET REAL VALUE IN SELECTED SETUP                                     **
!     ** REQUIRES SELECTED SETUP ARRAY                                        **
!     **************************************************************************
      USE XSETUP_MODULE, ONLY: SELECTED,THIS
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: ISP
      REAL(8), INTENT(IN) :: VAL
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SETUP SELECTED')
        CALL ERROR$STOP('XSETUP$SETR8')
      END IF
      IF(ISP.LE.0.OR.ISP.GT.SIZE(THIS)) THEN
        CALL ERROR$MSG('INVALID SPECIES INDEX')
        CALL ERROR$I4VAL('SPECIES INDEX: ',ISP)
        CALL ERROR$STOP('XSETUP$SETR8')
      END IF
      IF(ID.EQ.'ECORE') THEN
        THIS(ISP)%ECORE=VAL
      ELSE
        CALL ERROR$MSG('XSETUP SETR8 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('XSETUP$SETR8')
      END IF
      RETURN
      END SUBROUTINE XSETUP$SETR8
!
!     ==========================================================================
!     ==========================================================================
!     ==                    KSMAP MODULE FUNCTIONS                            ==
!     ==========================================================================
!     ==========================================================================
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE KSMAP$INIT(NKPTG_,NSPING_)
!     **************************************************************************
!     ** INITIALIZE KSMAP FOR TASKS                                           **
!     ** KSMAP(NKPTG,NSPING) IS THE MAP OF KPOINTS AND SPINS TO TASKS         **
!     ** RTASK IS THE TASK RESPONSIBLE FOR READING AND WRITING                **
!     **************************************************************************
      USE KSMAP_MODULE, ONLY: NKPTG,NSPING,RTASK,KSMAP,INITIALIZED
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: NKPTG_
      INTEGER(4), INTENT(IN) :: NSPING_
      INTEGER(4) :: NTASKS,THISTASK
      INTEGER(4) :: IKPT,ISPIN,IND
      IF(INITIALIZED) THEN
        ! IF ALREADY INITIALIZED, CHECK IF SAME VALUES
        IF(NKPTG_.NE.NKPTG.OR.NSPING_.NE.NSPING) THEN
          CALL ERROR$MSG('KSMAP ALREADY INITIALIZED WITH DIFFERENT VALUES')
          CALL ERROR$I4VAL('OLD NKPTG: ',NKPTG)
          CALL ERROR$I4VAL('OLD NSPING: ',NSPING)
          CALL ERROR$I4VAL('NEW NKPTG: ',NKPTG_)
          CALL ERROR$I4VAL('NEW NSPING: ',NSPING)
          CALL ERROR$STOP('KSMAP$INIT')
        END IF
        RETURN
      END IF
                          CALL TRACE$PUSH('KSMAP$INIT')
      NSPING=NSPING_
      NKPTG=NKPTG_
      ALLOCATE(KSMAP(NKPTG,NSPING))
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      ! ONLY ONE TASK: 
      !   BOTH READ TASK AND RESPONSIBLE FOR EVERY KPOINT
      IF(NTASKS.EQ.1) THEN
        RTASK=1
        KSMAP=1
      ! MORE THAN ONE TASK:
      !   FIRST IS READ TASK, OTHERS ARE RESPONSIBLE FOR DIFFERENT KPOINTS
      ELSE
        RTASK=1
        DO IKPT=1,NKPTG
          DO ISPIN=1,NSPING
            IND=NSPING*(IKPT-1)+ISPIN
            IND=MOD(IND-1,NTASKS-1)+2
            KSMAP(IKPT,ISPIN)=IND
          ENDDO
        ENDDO
      END IF
      INITIALIZED=.TRUE.
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE KSMAP$INIT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE KSMAP$REPORT(NFIL)
!     **************************************************************************
!     ** REPORT KSMAP TO FILE                                                 **
!     **************************************************************************
      USE KSMAP_MODULE, ONLY: NKPTG,NSPING,RTASK,KSMAP,INITIALIZED
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: NFIL
      INTEGER(4), PARAMETER :: PERLINE=14
      INTEGER(4) :: IKPT,ISPIN,IND
      INTEGER(4) :: BEGINKPT,ENDKPT
      INTEGER(4) :: NTASKS,THISTASK
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      IF(THISTASK.NE.RTASK) RETURN
                          CALL TRACE$PUSH('KSMAP$REPORT')
      IF(.NOT.INITIALIZED) THEN
        CALL ERROR$MSG('KSMAP NOT INITIALIZED')
        CALL ERROR$STOP('KSMAP$REPORT')
      END IF    
      WRITE(NFIL,FMT='(A)')''
      WRITE(NFIL,'(80("#"))')
      WRITE(NFIL,FMT='(A)')'KSMAP REPORT'
      WRITE(NFIL,'(80("#"))')
      WRITE(NFIL,FMT='(A8,I5)')'NTASKS:',NTASKS    
      WRITE(NFIL,FMT='(A8,I5)')'RW TASK:',RTASK
      BEGINKPT=1
      DO WHILE(.TRUE.)
        ! KPT IN THIS LINE (HALF FOR NSPIN=2)
        ENDKPT=MIN(BEGINKPT+PERLINE/NSPING-1,NKPTG)
        ! TODO: CHECK THIS IS OK FOR NSPING=2
        IF(NSPING.EQ.1) THEN
          WRITE(NFIL,FMT='(A8,*(I4,"|"))')'KPOINT:',(IKPT, IKPT=BEGINKPT,ENDKPT)
          WRITE(NFIL,FMT='(A8,*(I4,"|"))')'SPIN:',(1, IKPT=BEGINKPT,ENDKPT)
        ELSE
          WRITE(NFIL,FMT='(A8,*(I9,"|"))')'KPOINT:',(IKPT, IKPT=BEGINKPT,ENDKPT)
           WRITE(NFIL,FMT='(A8,*(I4,"|"))')'SPIN:',(MOD(IKPT-1,NSPING)+1, IKPT=BEGINKPT,ENDKPT)
        END IF
        ! WRITE(NFIL,FMT='(A8,*(I4,"|"))')'SPIN:',(MOD(IND-1,NSPING)+1, IND=BEGINKPT*NSPING-1,ENDKPT*NSPING)
        WRITE(NFIL,FMT='(A8,*(I4,"|"))')'KSMAP:',(KSMAP(IKPT,:), IKPT=BEGINKPT,ENDKPT)
        IF(ENDKPT.NE.NKPTG) THEN
          BEGINKPT=ENDKPT+1
        ELSE
          EXIT
        END IF
      ENDDO
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE KSMAP$REPORT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE KSMAP$READTASK(RTASK_)  ! MARK: KSMAP$READTASK
!     **************************************************************************
!     ** GET READ TASK                                                        **
!     ** REQUIRES KSMAP INITIALIZED                                           **
!     **************************************************************************
      USE KSMAP_MODULE, ONLY: RTASK,INITIALIZED
      IMPLICIT NONE
      INTEGER(4), INTENT(OUT) :: RTASK_
      IF(.NOT.INITIALIZED) THEN
        CALL ERROR$MSG('KSMAP NOT INITIALIZED')
        CALL ERROR$STOP('KSMAP$READTASK')
      END IF
      RTASK_=RTASK
      RETURN
      END SUBROUTINE KSMAP$READTASK
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE KSMAP$WORKTASK(IKPT,ISPIN,TASK_)  ! MARK: KSMAP$WORKTASK
!     **************************************************************************  
!     ** GET WORK TASK FOR KPOINT AND SPIN                                    **
!     ** REQUIRES KSMAP INITIALIZED                                           **
!     **************************************************************************
      USE KSMAP_MODULE, ONLY: KSMAP,INITIALIZED,NKPTG,NSPING
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: IKPT
      INTEGER(4), INTENT(IN) :: ISPIN
      INTEGER(4), INTENT(OUT) :: TASK_
      IF(.NOT.INITIALIZED) THEN
        CALL ERROR$MSG('KSMAP NOT INITIALIZED')
        CALL ERROR$STOP('KSMAP$WORKTASK')
      END IF
      IF(IKPT.LE.0.OR.IKPT.GT.NKPTG) THEN
        CALL ERROR$MSG('INVALID KPOINT INDEX')
        CALL ERROR$I4VAL('KPOINT INDEX: ',IKPT)
        CALL ERROR$STOP('KSMAP$WORKTASK')
      END IF
      IF(ISPIN.LE.0.OR.ISPIN.GT.NSPING) THEN
        CALL ERROR$MSG('INVALID SPIN INDEX')
        CALL ERROR$I4VAL('SPIN INDEX: ',ISPIN)
        CALL ERROR$STOP('KSMAP$WORKTASK')
      END IF
      TASK_=KSMAP(IKPT,ISPIN)
      RETURN
      END SUBROUTINE KSMAP$WORKTASK
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE KSMAP$WORKTASKSKPT(IKPT,TASKS_)  ! MARK: KSMAP$WORKTASKSKPT
!     **************************************************************************  
!     ** GET WORK TASKS FOR KPOINT                                            **
!     ** REQUIRES KSMAP INITIALIZED                                           **
!     **************************************************************************
      USE KSMAP_MODULE, ONLY: KSMAP,INITIALIZED,NKPTG,NSPING
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: IKPT
      INTEGER(4), INTENT(OUT) :: TASKS_(NSPING)
      IF(.NOT.INITIALIZED) THEN
        CALL ERROR$MSG('KSMAP NOT INITIALIZED')
        CALL ERROR$STOP('KSMAP$WORKTASK')
      END IF
      IF(IKPT.LE.0.OR.IKPT.GT.NKPTG) THEN
        CALL ERROR$MSG('INVALID KPOINT INDEX')
        CALL ERROR$I4VAL('KPOINT INDEX: ',IKPT)
        CALL ERROR$STOP('KSMAP$WORKTASK')
      END IF
      TASKS_(:)=KSMAP(IKPT,:)
      RETURN
      END SUBROUTINE KSMAP$WORKTASKSKPT
!
!     ==========================================================================
!     ==========================================================================
!     ==                  SETTINGS MODULE FUNCTIONS                           ==
!     ==========================================================================
!     ==========================================================================
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SETTINGS$REPORT(NFIL)  ! MARK: SETTINGS$REPORT
!     **************************************************************************
!     ** REPORT SETTINGS MODULE TO FILE                                       **
!     ** REQUIRES SETTINGS MODULE INITIALIZED                                 **
!     **************************************************************************
      USE SETTINGS_MODULE, ONLY: NCORE,LCORE,IATOM,COREHOLE
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: NFIL
      INTEGER(4) :: NTASKS,THISTASK,RTASK
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      CALL KSMAP$READTASK(RTASK)
      IF(THISTASK.NE.RTASK) RETURN
                          CALL TRACE$PUSH('SETTINGS$REPORT')
      WRITE(NFIL,'(80("#"))')
      WRITE(NFIL,FMT='(A19)')'SETTINGS'
      WRITE(NFIL,'(80("#"))')
      !TODO: DATA NOT AVAILABLE FROM RESTART FILE
      WRITE(NFIL,FMT='(A10,X,A)')'HOLE ATOM:',TRIM(COREHOLE)
      IF(IATOM.EQ.-HUGE(1)) THEN
        CALL ERROR$MSG('SAFEGUARD: IATOM NOT SET')
        CALL ERROR$STOP('SETTINGS$REPORT')
      END IF
      WRITE(NFIL,FMT='(A10,I10)')'IND1 ATOM:',IATOM
      WRITE(NFIL,FMT='(A10,I10)')'NCORE:',NCORE
      WRITE(NFIL,FMT='(A10,I10)')'LCORE:',LCORE
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE SETTINGS$REPORT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SETTINGS_IATOM  ! MARK: SETTINGS_IATOM
!     **************************************************************************
!     ** FIND COREHOLE ATOM IN SIMULATION GROUND                              **
!     **************************************************************************
      USE SETTINGS_MODULE, ONLY: IATOM,COREHOLE
      IMPLICIT NONE
      CHARACTER(16), ALLOCATABLE :: ATOMID(:)
      INTEGER(4) :: NAT
      INTEGER(4) :: IAT
      LOGICAL(4) :: FOUND
                          CALL TRACE$PUSH('SETTINGS_IATOM')
      IF(IATOM.NE.-HUGE(1)) THEN
        CALL ERROR$MSG('SAFEGUARD: IATOM ALREADY SET')
        CALL ERROR$STOP('SETTINGS_IATOM')
      END IF
      CALL SIMULATION$SELECT('GROUND')
      CALL SIMULATION$GETI4('NAT',NAT)
      ALLOCATE(ATOMID(NAT))
      CALL SIMULATION$GETCHA('ATOMID',NAT,ATOMID)
      DO IAT=1,NAT
        IF(TRIM(COREHOLE).EQ.TRIM(ATOMID(IAT))) THEN
          FOUND=.TRUE.
          EXIT
        END IF
      ENDDO
      IF(FOUND) THEN
        IATOM=IAT
      ELSE
        CALL ERROR$MSG('COREHOLE ATOM NOT FOUND IN SIMULATION GROUND')
        CALL ERROR$CHVAL('COREHOLE: ',COREHOLE)
        CALL ERROR$STOP('SETTINGS_IATOM')
      END IF
      CALL SIMULATION$UNSELECT
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE SETTINGS_IATOM
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SETTINGS$GETI4(ID,VAL)  ! MARK: SETTINGS$GETI4
!     **************************************************************************
!     ** GET INTEGER FROM SETTINGS MODULE                                     **
!     **************************************************************************
      USE SETTINGS_MODULE, ONLY: NCORE,LCORE,IATOM
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(OUT) :: VAL
      IF(ID.EQ.'NCORE') THEN
        VAL=NCORE
      ELSE IF(ID.EQ.'LCORE') THEN
        VAL=LCORE
      ELSE IF(ID.EQ.'IATOM') THEN
        ! CALL SHOULD BE UNNECESSARY, BUT IS A SAFEGUARD
        IF(IATOM.EQ.-HUGE(1)) CALL SETTINGS_IATOM
        VAL=IATOM
      ELSE
        CALL ERROR$MSG('SETTINGS GETI4 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('SETTINGS$GETI4')
      END IF
      RETURN
      END SUBROUTINE SETTINGS$GETI4
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SETTINGS$SETI4(ID,VAL)  ! MARK: SETTINGS$SETI4
!     **************************************************************************
!     ** SET INTEGER IN SETTINGS MODULE                                       **
!     **************************************************************************
      USE SETTINGS_MODULE, ONLY: NCORE,LCORE,IATOM
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: VAL
      IF(ID.EQ.'NCORE') THEN
        NCORE=VAL
      ELSE IF(ID.EQ.'LCORE') THEN
        LCORE=VAL
      ELSE IF(ID.EQ.'IATOM') THEN
        IATOM=VAL
      ELSE
        CALL ERROR$MSG('SETTINGS SETI4 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('SETTINGS$SETI4')
      END IF
      RETURN
      END SUBROUTINE SETTINGS$SETI4
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SETTINGS$GETCH(ID,VAL)  ! MARK: SETTINGS$GETCH
!     **************************************************************************
!     ** GET CHARACTER FROM SETTINGS MODULE                                   **
!     **************************************************************************
      USE SETTINGS_MODULE, ONLY: COREHOLE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      CHARACTER(*), INTENT(OUT) :: VAL
      IF(ID.EQ.'COREHOLE') THEN
        VAL=COREHOLE
      ELSE
        CALL ERROR$MSG('SETTINGS GETCH ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('SETTINGS$GETCH')
      END IF
      RETURN
      END SUBROUTINE SETTINGS$GETCH
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE SETTINGS$SETCH(ID,VAL)  ! MARK: SETTINGS$SETCH
!     **************************************************************************
!     ** SET CHARACTER IN SETTINGS MODULE                                     **
!     **************************************************************************
      USE SETTINGS_MODULE, ONLY: COREHOLE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      CHARACTER(*), INTENT(IN) :: VAL
      IF(ID.EQ.'COREHOLE') THEN
        COREHOLE=VAL
      ELSE
        CALL ERROR$MSG('SETTINGS SETCH ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('SETTINGS$SETCH')
      END IF
      RETURN
      END SUBROUTINE
!
!     ==========================================================================
!     ==========================================================================
!     ==                      XAS MODULE FUNCTIONS                            ==
!     ==========================================================================
!     ==========================================================================
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$REPORT(NFIL)  ! MARK: XAS$REPORT
!     **************************************************************************
!     ** REPORT XAS MODULE TO FILE                                            **
!     ** REQUIRES XAS ACTIVE, INITIALIZED, AND UNSELECTED                     **
!     **************************************************************************
      USE XAS_MODULE, ONLY: TACTIVE,TINITIALIZE,SELECTED,NSPEC,EMIN,EMAX,DE,THIS
      USE STRINGS_MODULE
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: NFIL
      REAL(8) :: EV
      INTEGER(4) :: NE
      INTEGER(4) :: ISPEC
      COMPLEX(8) :: POLXYZ(3)
      CHARACTER(12) :: MODE
      INTEGER(4) :: NTASKS,THISTASK,RTASK
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      CALL KSMAP$READTASK(RTASK)
      IF(THISTASK.NE.RTASK) RETURN
      IF(.NOT.TACTIVE) RETURN
                          CALL TRACE$PUSH('XAS$REPORT')
      IF(.NOT.TINITIALIZE) THEN
        CALL ERROR$MSG('XAS NOT INITIALIZED')
        CALL ERROR$STOP('XAS$REPORT')
      END IF
      IF(SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('XAS SPECTRUM SELECTED')
        CALL ERROR$STOP('XAS$REPORT')
      END IF
      CALL CONSTANTS('EV',EV)
      WRITE(NFIL,'(80("#"))')
      WRITE(NFIL,FMT='(A19)')'XAS MODULE'
      WRITE(NFIL,'(80("#"))')
      WRITE(NFIL,FMT='(A12,I10)')'NSPEC:',NSPEC
      WRITE(NFIL,FMT='(A12,F10.3)')'EMIN:',EMIN/EV
      WRITE(NFIL,FMT='(A12,F10.3)')'EMAX:',EMAX/EV
      WRITE(NFIL,FMT='(A12,F10.3)')'DE:',DE/EV
      ! SAFEGUARD TO SET NE
      CALL XAS$GETI4('NE',NE)
      WRITE(NFIL,FMT='(A12,I10)')'NE:',NE

      DO ISPEC=1,NSPEC
        CALL XAS$ISELECT(ISPEC)
        WRITE(NFIL,'(80("-"))')
        WRITE(NFIL,FMT='(A12,I10)')'SPECTRUM:',ISPEC
        WRITE(NFIL,FMT='(A12,X,A)')'FILE:',TRIM(THIS%FILE)
        WRITE(NFIL,FMT='(A12,3F10.4)')'NORMAL:',THIS%NORMAL(:)
        WRITE(NFIL,FMT='(A12,3F10.4)')'KDIR:',THIS%KDIR(:)
        WRITE(NFIL,FMT=-'(A12,2(F8.5,SP,F8.5,"I ",S))')'POL:',THIS%POL(:)
        ! SAFEGUARD TO SET POLXYZ
        CALL XAS$GETC8A('POLXYZ',3,POLXYZ)
        WRITE(NFIL,FMT=-'(A12,3(F8.5,SP,F8.5,"I ",S))')'POLXYZ:',THIS%POLXYZ(:)
        WRITE(NFIL,FMT='(A12,F10.4)')'EBROAD[EV]:',THIS%EBROAD/EV
        IF(THIS%BROADMODE.EQ.'G') THEN
          MODE='(GAUSSIAN)'
        ELSE IF(THIS%BROADMODE.EQ.'L') THEN
          MODE='(LORENTZIAN)'
        ELSE IF(THIS%BROADMODE.EQ.'N') THEN
          MODE='(NONE)'
        END IF
        WRITE(NFIL,FMT='(A12,A2,X,A)')'BROADMODE:',THIS%BROADMODE,TRIM(ADJUSTL(MODE))
        CALL XAS$UNSELECT
      ENDDO
      FLUSH(NFIL)
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE XAS$REPORT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$ISELECT(ISPEC)  ! MARK: XAS$ISELECT
!     **************************************************************************
!     ** SELECT SPECTRUM FOR XAS MODULE                                       **
!     ** REQUIRES XAS INITIALIZED                                             **
!     **************************************************************************
      USE XAS_MODULE, ONLY: TINITIALIZE,NSPEC,SELECTED,SPECTRA,THIS
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: ISPEC
      IF(.NOT.TINITIALIZE) THEN
        CALL ERROR$MSG('XAS NOT INITIALIZED')
        CALL ERROR$STOP('XAS$ISELECT')
      END IF
      IF(SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('XAS SPECTRUM ALREADY SELECTED')
        CALL ERROR$STOP('XAS$ISELECT')
      END IF
      IF(ISPEC.LE.0.OR.ISPEC.GT.NSPEC) THEN
        CALL ERROR$MSG('INVALID SPECTRUM INDEX')
        CALL ERROR$I4VAL('SPECTRUM INDEX: ',ISPEC)
        CALL ERROR$STOP('XAS$ISELECT')
      END IF
      THIS=>SPECTRA(ISPEC)
      SELECTED=.TRUE.
      RETURN
      END SUBROUTINE XAS$ISELECT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$UNSELECT()  ! MARK: XAS$UNSELECT
!     **************************************************************************
!     ** UNSELECT SPECTRUM FOR XAS MODULE                                     **
!     ** REQUIRES XAS INITIALIZED AND SELECTED                                **
!     **************************************************************************
      USE XAS_MODULE, ONLY: TINITIALIZE,SELECTED,THIS
      IMPLICIT NONE
      IF(.NOT.TINITIALIZE) THEN
        CALL ERROR$MSG('XAS NOT INITIALIZED')
        CALL ERROR$STOP('XAS$UNSELECT')
      END IF
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('CANNOT UNSELECT SPECTRUM IF NONE SELECTED')
        CALL ERROR$STOP('XAS$UNSELECT')
      END IF
      NULLIFY(THIS)
      SELECTED=.FALSE.
      RETURN
      END SUBROUTINE XAS$UNSELECT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$GETL4(ID,VAL)  ! MARK: XAS$GETL4
!     **************************************************************************
!     ** GET LOGICAL FROM XAS MODULE                                         **
!     **************************************************************************
      USE XAS_MODULE, ONLY: TACTIVE,TINITIALIZE,SELECTED,THIS
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      LOGICAL(4), INTENT(OUT) :: VAL
      IF(ID.EQ.'INITIALIZE') THEN
        VAL=TINITIALIZE
      ELSE IF(ID.EQ.'ACTIVE') THEN
        VAL=TACTIVE
      ELSE IF(ID.EQ.'TPOLXYZ') THEN
          IF(.NOT.TINITIALIZE) THEN
            CALL ERROR$MSG('XAS NOT INITIALIZED')
            CALL ERROR$STOP('XAS$GETL4')
          END IF
          IF(.NOT.SELECTED) THEN
            CALL ERROR$MSG('XAS SPECTRUM NOT SELECTED')
            CALL ERROR$STOP('XAS$GETL4')
          END IF
          VAL=THIS%TPOLXYZ
      ELSE
        CALL ERROR$MSG('XAS GETL4 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('XAS$GETL4')
      END IF
      RETURN
      END SUBROUTINE XAS$GETL4
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$SETL4(ID,VAL)  ! MARK: XAS$SETL4
!     **************************************************************************
!     ** SET LOGICAL IN XAS MODULE                                           **
!     **************************************************************************
      USE XAS_MODULE, ONLY: TACTIVE,TINITIALIZE,SELECTED,THIS
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      LOGICAL(4), INTENT(IN) :: VAL
      IF(ID.EQ.'ACTIVE') THEN
        TACTIVE=VAL
      ELSE IF(ID.EQ.'INITIALIZE') THEN
        TINITIALIZE=VAL
      ELSE IF(ID.EQ.'TPOLXYZ') THEN
        IF(.NOT.SELECTED) THEN
          CALL ERROR$MSG('XAS SPECTRUM NOT SELECTED')
          CALL ERROR$STOP('XAS$SETL4')
        END IF
        THIS%TPOLXYZ=VAL
      ELSE
        CALL ERROR$MSG('XAS SETL4 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('XAS$SETL4')
      END IF
      RETURN
      END SUBROUTINE XAS$SETL4
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$GETI4(ID,VAL)  ! MARK: XAS$GETI4
!     **************************************************************************
!     ** GET INTEGER FROM XAS MODULE                                        **
!     **************************************************************************
      USE XAS_MODULE, ONLY: NSPEC,NE,TINITIALIZE,EMIN,EMAX,DE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(OUT) :: VAL
      IF(.NOT.TINITIALIZE) THEN
        CALL ERROR$MSG('XAS NOT INITIALIZED')
        CALL ERROR$STOP('XAS$GETI4')
      END IF
      IF(ID.EQ.'NSPEC') THEN
        VAL=NSPEC
      ELSE IF(ID.EQ.'NE') THEN
        NE=INT((EMAX-EMIN)/DE)+1
        VAL=NE
      ELSE
        CALL ERROR$MSG('XAS GETI4 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('XAS$GETI4')
      END IF
      RETURN
      END SUBROUTINE XAS$GETI4
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$SETI4(ID,VAL)  ! MARK: XAS$SETI4
!     **************************************************************************
!     ** SET INTEGER IN XAS MODULE                                          **
!     **************************************************************************
      USE XAS_MODULE, ONLY: NSPEC,NE,SPECTRA
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: VAL
      IF(ID.EQ.'NSPEC') THEN
        NSPEC=VAL
        IF(.NOT.ALLOCATED(SPECTRA)) THEN
          ALLOCATE(SPECTRA(NSPEC))
        ELSE
          CALL ERROR$MSG('XAS SETI4 NSPEC ALREADY ALLOCATED')
          CALL ERROR$I4VAL('OLD NSPEC: ',SIZE(SPECTRA))
          CALL ERROR$I4VAL('NEW NSPEC: ',VAL)
          CALL ERROR$STOP('XAS$SETI4')
        END IF
      ELSE IF(ID.EQ.'NE') THEN
        NE=VAL
      ELSE
        CALL ERROR$MSG('XAS SETI4 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('XAS$SETI4')
      END IF
      RETURN
      END SUBROUTINE XAS$SETI4
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$GETR8(ID,VAL)  ! MARK: XAS$GETR8
!     **************************************************************************
!     ** GET REAL FROM XAS MODULE                                             **
!     **************************************************************************
      USE XAS_MODULE, ONLY: EMIN,EMAX,DE,TINITIALIZE,SELECTED,THIS
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      REAL(8), INTENT(OUT) :: VAL
      IF(.NOT.TINITIALIZE) THEN
        CALL ERROR$MSG('XAS NOT INITIALIZED')
        CALL ERROR$STOP('XAS$GETR8')
      END IF
      IF(ID.EQ.'EMIN') THEN
        VAL=EMIN
      ELSE IF(ID.EQ.'EMAX') THEN
        VAL=EMAX
      ELSE IF(ID.EQ.'DE') THEN
        VAL=DE
      ELSE IF(ID.EQ.'EBROAD') THEN
        IF(.NOT.SELECTED) THEN
          CALL ERROR$MSG('XAS SPECTRUM NOT SELECTED')
          CALL ERROR$STOP('XAS$GETR8')
        END IF
        VAL=THIS%EBROAD
      ELSE
        CALL ERROR$MSG('XAS GETR8 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('XAS$GETR8')
      END IF
      RETURN
      END SUBROUTINE XAS$GETR8
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$SETR8(ID,VAL)  ! MARK: XAS$SETR8
!     **************************************************************************
!     ** SET REAL IN XAS MODULE                                               **
!     **************************************************************************
      USE XAS_MODULE, ONLY: EMIN,EMAX,DE,SELECTED,THIS
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      REAL(8), INTENT(IN) :: VAL
      IF(ID.EQ.'EMIN') THEN
        EMIN=VAL
      ELSE IF(ID.EQ.'EMAX') THEN
        EMAX=VAL
      ELSE IF(ID.EQ.'DE') THEN
        DE=VAL
      ELSE IF(ID.EQ.'EBROAD') THEN
        IF(.NOT.SELECTED) THEN
          CALL ERROR$MSG('XAS SPECTRUM NOT SELECTED')
          CALL ERROR$STOP('XAS$SETR8')
        END IF
        THIS%EBROAD=VAL
      ELSE
        CALL ERROR$MSG('XAS SETR8 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('XAS$SETR8')
      END IF
      RETURN
      END SUBROUTINE XAS$SETR8
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$GETCH(ID,VAL)  ! MARK: XAS$GETCH
!     **************************************************************************
!     ** GET CHARACTER FROM XAS MODULE                                       **
!     **************************************************************************
      USE XAS_MODULE, ONLY: TINITIALIZE,SELECTED,THIS
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      CHARACTER(*), INTENT(OUT) :: VAL
      IF(.NOT.TINITIALIZE) THEN
        CALL ERROR$MSG('XAS NOT INITIALIZED')
        CALL ERROR$STOP('XAS$GETCH')
      END IF
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('XAS SPECTRUM NOT SELECTED')
        CALL ERROR$STOP('XAS$GETCH')
      END IF
      IF(ID.EQ.'FILE') THEN
        VAL=THIS%FILE
      ELSE IF(ID.EQ.'BROADMODE') THEN
        VAL=THIS%BROADMODE
      ELSE
        CALL ERROR$MSG('XAS GETCH ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('XAS$GETCH')
      END IF
      RETURN
      END SUBROUTINE XAS$GETCH
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$SETCH(ID,VAL)  ! MARK: XAS$SETCH
!     **************************************************************************
!     ** SET CHARACTER IN XAS MODULE                                         **
!     **************************************************************************
      USE XAS_MODULE, ONLY: SELECTED,THIS
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      CHARACTER(*), INTENT(IN) :: VAL
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('XAS SPECTRUM NOT SELECTED')
        CALL ERROR$STOP('XAS$SETCH')
      END IF
      IF(ID.EQ.'FILE') THEN
        THIS%FILE=VAL
      ELSE IF(ID.EQ.'BROADMODE') THEN
        THIS%BROADMODE=VAL
      ELSE
        CALL ERROR$MSG('XAS SETCH ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('XAS$SETCH')
      END IF
      RETURN
      END SUBROUTINE XAS$SETCH
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$GETR8A(ID,LEN,VAL)  ! MARK: XAS$GETR8A
!     **************************************************************************
!     ** GET REAL ARRAY FROM XAS MODULE                                      **
!     ** REQUIRES XAS INITIALIZED AND SELECTED                                 **
!     **************************************************************************
      USE XAS_MODULE, ONLY: SELECTED,THIS,TINITIALIZE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: LEN
      REAL(8), INTENT(OUT) :: VAL(LEN)
      IF(.NOT.TINITIALIZE) THEN
        CALL ERROR$MSG('XAS NOT INITIALIZED')
        CALL ERROR$STOP('XAS$GETR8A')
      END IF
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('XAS SPECTRUM NOT SELECTED')
        CALL ERROR$STOP('XAS$GETR8A')
      END IF
      IF(ID.EQ.'NORMAL') THEN
        IF(LEN.NE.3) THEN
          CALL ERROR$MSG('XAS GETR8A NORMAL LEN NOT 3')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$STOP('XAS$GETR8A')
        END IF
        VAL(:)=THIS%NORMAL(:)
      ELSE IF(ID.EQ.'KDIR') THEN
        IF(LEN.NE.3) THEN
          CALL ERROR$MSG('XAS GETR8A KDIR LEN NOT 3')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$STOP('XAS$GETR8A')
        END IF
        VAL(:)=THIS%KDIR(:)
      ELSE
        CALL ERROR$MSG('XAS GETR8A ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('XAS$GETR8A')
      END IF
      RETURN
      END SUBROUTINE XAS$GETR8A
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$SETR8A(ID,LEN,VAL)  ! MARK: XAS$SETR8A
!     **************************************************************************
!     ** SET REAL ARRAY IN XAS MODULE                                         **
!     **************************************************************************
      USE XAS_MODULE, ONLY: SELECTED,THIS
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: LEN
      REAL(8), INTENT(IN) :: VAL(LEN)
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('XAS SPECTRUM NOT SELECTED')
        CALL ERROR$STOP('XAS$SETR8A')
      END IF
      IF(ID.EQ.'NORMAL') THEN
        IF(LEN.NE.3) THEN
          CALL ERROR$MSG('XAS SETR8A NORMAL LEN NOT 3')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$STOP('XAS$SETR8A')
        END IF
        THIS%NORMAL(:)=VAL(:)
      ELSE IF(ID.EQ.'KDIR') THEN
        IF(LEN.NE.3) THEN
          CALL ERROR$MSG('XAS SETR8A KDIR LEN NOT 3')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$STOP('XAS$SETR8A')
        END IF
        THIS%KDIR(:)=VAL(:)
      ELSE
        CALL ERROR$MSG('XAS SETR8A ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('XAS$SETR8A')
      END IF
      RETURN
      END SUBROUTINE XAS$SETR8A
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$GETC8A(ID,LEN,VAL)  ! MARK: XAS$GETC8A
!     **************************************************************************
!     ** GET CHARACTER ARRAY FROM XAS MODULE                                 **
!     ** REQUIRES XAS INITIALIZED AND SELECTED                                 **
!     **************************************************************************
      USE XAS_MODULE, ONLY: SELECTED,THIS,TINITIALIZE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: LEN
      COMPLEX(8), INTENT(OUT) :: VAL(LEN)
      IF(.NOT.TINITIALIZE) THEN
        CALL ERROR$MSG('XAS NOT INITIALIZED')
        CALL ERROR$STOP('XAS$GETC8A')
      END IF
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('XAS SPECTRUM NOT SELECTED')
        CALL ERROR$STOP('XAS$GETC8A')
      END IF
      IF(ID.EQ.'POL') THEN
        IF(LEN.NE.2) THEN
          CALL ERROR$MSG('XAS GETC8A POL LEN NOT 2')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$STOP('XAS$GETC8A')
        END IF
        VAL(:)=THIS%POL(:)
      ELSE IF(ID.EQ.'POLXYZ') THEN
        IF(LEN.NE.3) THEN
          CALL ERROR$MSG('XAS GETC8A POLXYZ LEN NOT 3')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$STOP('XAS$GETC8A')
        END IF
        IF(.NOT.THIS%TPOLXYZ) THEN
          CALL POLARISATION_CONVERT(THIS%KDIR,THIS%NORMAL,THIS%POL,THIS%POLXYZ)
          THIS%TPOLXYZ=.TRUE.
        END IF
        VAL(:)=THIS%POLXYZ(:)
      ELSE
        CALL ERROR$MSG('XAS GETC8A ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('XAS$GETC8A')
      END IF
      RETURN
      END SUBROUTINE XAS$GETC8A
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$SETC8A(ID,LEN,VAL)  ! MARK: XAS$SETC8A
!     **************************************************************************
!     ** SET CHARACTER ARRAY IN XAS MODULE                                    **
!     **************************************************************************
      USE XAS_MODULE, ONLY: SELECTED,THIS
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: LEN
      COMPLEX(8), INTENT(IN) :: VAL(LEN)
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('XAS SPECTRUM NOT SELECTED')
        CALL ERROR$STOP('XAS$SETC8A')
      END IF
      IF(ID.EQ.'POL') THEN
        IF(LEN.NE.2) THEN
          CALL ERROR$MSG('XAS SETC8A POL LEN NOT 2')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$STOP('XAS$SETC8A')
        END IF
        THIS%POL(:)=VAL(:)
      ! ELSE IF(ID.EQ.'POLXYZ') THEN
      !   IF(LEN.NE.3) THEN
      !     CALL ERROR$MSG('XAS SETC8A POLXYZ LEN NOT 3')
      !     CALL ERROR$I4VAL('LEN: ',LEN)
      !     CALL ERROR$STOP('XAS$SETC8A')
      !   END IF
      !   THIS%POLXYZ(:)=VAL(:)
      ELSE
        CALL ERROR$MSG('XAS SETC8A ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('XAS$SETC8A')
      END IF
      RETURN
      END SUBROUTINE XAS$SETC8A
!
!     ==========================================================================
!     ==========================================================================
!     ==                      RIXS MODULE FUNCTIONS                           ==
!     ==========================================================================
!     ==========================================================================
! TODO: UPDATE RIXS FUNCTIONS
! !
! !     ...1.........2.........3.........4.........5.........6.........7.........8
!       SUBROUTINE RIXS$GETL4(ID,VAL)  ! MARK: RIXS$GETL4
! !     **************************************************************************
! !     ** GET LOGICAL FROM RIXS MODULE                                        **
! !     **************************************************************************
!       USE RIXS_MODULE, ONLY: TACTIVE,TINITIALIZE
!       IMPLICIT NONE
!       CHARACTER(*), INTENT(IN) :: ID
!       LOGICAL(4), INTENT(OUT) :: VAL
!       IF(ID.EQ.'INITIALIZE') THEN
!         VAL=TINITIALIZE
!       ELSE IF(ID.EQ.'ACTIVE') THEN
!         IF(.NOT.TINITIALIZE) THEN
!           CALL ERROR$MSG('RIXS NOT INITIALIZED')
!           CALL ERROR$STOP('RIXS$GETL4')
!         END IF
!         VAL=TACTIVE
!       ELSE
!         CALL ERROR$MSG('RIXS GETL4 ID NOT RECOGNIZED')
!         CALL ERROR$CHVAL('ID: ',ID)
!         CALL ERROR$STOP('RIXS$GETL4')
!       END IF
!       RETURN
!       END SUBROUTINE RIXS$GETL4
! !
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE RIXS$SETL4(ID,VAL)  ! MARK: RIXS$SETL4
!     **************************************************************************
!     ** SET LOGICAL IN RIXS MODULE                                          **
!     **************************************************************************
      USE RIXS_MODULE, ONLY: TACTIVE,TINITIALIZE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      LOGICAL(4), INTENT(IN) :: VAL
      IF(ID.EQ.'ACTIVE') THEN
        TACTIVE=VAL
      ELSE IF(ID.EQ.'INITIALIZE') THEN
        TINITIALIZE=VAL
      ELSE
        CALL ERROR$MSG('RIXS SETL4 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('RIXS$SETL4')
      END IF
      RETURN
      END SUBROUTINE RIXS$SETL4
! !
! !     ...1.........2.........3.........4.........5.........6.........7.........8
!       SUBROUTINE RIXS$GETI4(ID,VAL)  ! MARK: RIXS$GETI4
! !     **************************************************************************
! !     ** GET INTEGER FROM RIXS MODULE                                       **
! !     **************************************************************************
!       USE RIXS_MODULE, ONLY: NSPEC,TINITIALIZE
!       IMPLICIT NONE
!       CHARACTER(*), INTENT(IN) :: ID
!       INTEGER(4), INTENT(OUT) :: VAL
!       IF(.NOT.TINITIALIZE) THEN
!         CALL ERROR$MSG('RIXS NOT INITIALIZED')
!         CALL ERROR$STOP('RIXS$GETI4')
!       END IF
!       IF(ID.EQ.'NSPEC') THEN
!         VAL=NSPEC
!       ELSE
!         CALL ERROR$MSG('RIXS GETI4 ID NOT RECOGNIZED')
!         CALL ERROR$CHVAL('ID: ',ID)
!         CALL ERROR$STOP('RIXS$GETI4')
!       END IF
!       RETURN
!       END SUBROUTINE RIXS$GETI4
! !
! !     ...1.........2.........3.........4.........5.........6.........7.........8
!       SUBROUTINE RIXS$SETI4(ID,VAL)  ! MARK: RIXS$SETI4
! !     **************************************************************************
! !     ** SET INTEGER IN RIXS MODULE                                         **
! !     **************************************************************************
!       USE RIXS_MODULE, ONLY: NSPEC
!       IMPLICIT NONE
!       CHARACTER(*), INTENT(IN) :: ID
!       INTEGER(4), INTENT(IN) :: VAL
!       IF(ID.EQ.'NSPEC') THEN
!         NSPEC=VAL
!       ELSE
!         CALL ERROR$MSG('RIXS SETI4 ID NOT RECOGNIZED')
!         CALL ERROR$CHVAL('ID: ',ID)
!         CALL ERROR$STOP('RIXS$SETI4')
!       END IF
!       RETURN
!       END SUBROUTINE RIXS$SETI4
! !
! !     ...1.........2.........3.........4.........5.........6.........7.........8
!       SUBROUTINE RIXS$GETR8(ID,VAL)  ! MARK: RIXS$GETR8
! !     **************************************************************************
! !     ** GET REAL FROM RIXS MODULE                                           **
! !     **************************************************************************
!       USE RIXS_MODULE, ONLY: EMIN,EMAX,GAMMA,TINITIALIZE
!       IMPLICIT NONE
!       CHARACTER(*), INTENT(IN) :: ID
!       REAL(8), INTENT(OUT) :: VAL
!       IF(.NOT.TINITIALIZE) THEN
!         CALL ERROR$MSG('RIXS NOT INITIALIZED')
!         CALL ERROR$STOP('RIXS$GETR8')
!       END IF
!       IF(ID.EQ.'EMIN') THEN
!         VAL=EMIN
!       ELSE IF(ID.EQ.'EMAX') THEN
!         VAL=EMAX
!       ELSE IF(ID.EQ.'GAMMA') THEN
!         VAL=GAMMA
!       ELSE
!         CALL ERROR$MSG('RIXS GETR8 ID NOT RECOGNIZED')
!         CALL ERROR$CHVAL('ID: ',ID)
!         CALL ERROR$STOP('RIXS$GETR8')
!       END IF
!       RETURN
!       END SUBROUTINE RIXS$GETR8
! !
! !     ...1.........2.........3.........4.........5.........6.........7.........8
!       SUBROUTINE RIXS$SETR8(ID,VAL)  ! MARK: RIXS$SETR8
! !     **************************************************************************
! !     ** SET REAL IN RIXS MODULE                                              **
! !     **************************************************************************
!       USE RIXS_MODULE, ONLY: EMIN,EMAX,GAMMA
!       IMPLICIT NONE
!       CHARACTER(*), INTENT(IN) :: ID
!       REAL(8), INTENT(IN) :: VAL
!       IF(ID.EQ.'EMIN') THEN
!         EMIN=VAL
!       ELSE IF(ID.EQ.'EMAX') THEN
!         EMAX=VAL
!       ELSE IF(ID.EQ.'GAMMA') THEN
!         GAMMA=VAL
!       ELSE
!         CALL ERROR$MSG('RIXS SETR8 ID NOT RECOGNIZED')
!         CALL ERROR$CHVAL('ID: ',ID)
!         CALL ERROR$STOP('RIXS$SETR8')
!       END IF
!       RETURN
!       END SUBROUTINE RIXS$SETR8
! !
!     ==========================================================================
!     ==========================================================================
!     ==                    STATE MODULE FUNCTIONS                            ==
!     ==========================================================================
!     ==========================================================================
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE STATE$INIT(ISIM,NKPT_,NSPIN_,NDIM_,NPRO_)  ! MARK: STATE$INIT
!     **************************************************************************
!     ** INITIALIZE STATE MODULE                                              **
!     **************************************************************************
!     TODO: NPRO IS ENFORCED TO BE THE SAME FOR BOTH SIMULATIONS
      USE STATE_MODULE
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: ISIM
      INTEGER(4), INTENT(IN) :: NKPT_
      INTEGER(4), INTENT(IN) :: NSPIN_
      INTEGER(4), INTENT(IN) :: NDIM_
      INTEGER(4), INTENT(IN) :: NPRO_
                          CALL TRACE$PUSH('STATE$INIT')
      IF(INITIALIZED) THEN
        ! IF ALREADY INITIALIZED, CHECK IF SAME VALUES
        IF(NKPT_.NE.NKPTG.OR.NSPIN_.NE.NSPING.OR.NDIM_.NE.NDIM.OR.NPRO_.NE.NPRO) THEN
          CALL ERROR$MSG('STATE ALREADY INITIALIZED WITH DIFFERENT VALUES')
          CALL ERROR$I4VAL('OLD NKPTG: ',NKPTG)
          CALL ERROR$I4VAL('OLD NSPING: ',NSPING)
          CALL ERROR$I4VAL('OLD NDIM: ',NDIM)
          CALL ERROR$I4VAL('OLD NPRO: ',NPRO)
          CALL ERROR$I4VAL('NEW NKPTG: ',NKPT_)
          CALL ERROR$I4VAL('NEW NSPING: ',NSPIN_)
          CALL ERROR$I4VAL('NEW NDIM: ',NDIM_)
          CALL ERROR$I4VAL('NEW NPRO: ',NPRO_)
          CALL ERROR$STOP('STATE$INIT')
        END IF
        RETURN
      END IF
      NKPTG=NKPT_
      NSPING=NSPIN_
      NDIM=NDIM_
      NPRO=NPRO_
      ALLOCATE(GROUND(NKPTG,NSPING))
      ALLOCATE(EXCITE(NKPTG,NSPING))
      INITIALIZED=.TRUE.
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE STATE$INIT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE STATE$SELECT(ID)  ! MARK: STATE$SELECT
!     **************************************************************************
!     ** SELECT STATE ARRAY                                                   **
!     **************************************************************************
      USE STATE_MODULE, ONLY: GROUND,EXCITE,THIS,SELECTED
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      IF(SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('CANNOT SELECT STATE ARRAY WHEN ALREADY SELECTED')
        CALL ERROR$STOP('STATE$SELECT')
      END IF
      IF(ID.EQ.'GROUND') THEN
        ! IF(.NOT.ALLOCATED(GROUND)) THEN
        !   CALL ERROR$MSG('GROUND STATE ARRAY NOT ALLOCATED')
        !   CALL ERROR$STOP('STATE$SELECT')
        ! END IF
        THIS=GROUND
      ELSE IF(ID.EQ.'EXCITE') THEN
        ! IF(.NOT.ALLOCATED(EXCITE)) THEN
        !   CALL ERROR$MSG('EXCITE STATE ARRAY NOT ALLOCATED')
        !   CALL ERROR$STOP('STATE$SELECT')
        ! END IF
        THIS=EXCITE
      ELSE
        CALL ERROR$MSG('STATE SELECT ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('STATE$SELECT')
      END IF
      SELECTED=.TRUE.
      RETURN
      END SUBROUTINE STATE$SELECT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE STATE$UNSELECT()  ! MARK: STATE$UNSELECT
!     **************************************************************************
!     ** UNSELECT STATE ARRAY                                                 **
!     **************************************************************************
      USE STATE_MODULE, ONLY: THIS,SELECTED
      IMPLICIT NONE
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('CANNOT UNSELECT STATE ARRAY WHEN NOT SELECTED')
        CALL ERROR$STOP('STATE$UNSELECT')
      END IF
      SELECTED=.FALSE.
      NULLIFY(THIS)
      RETURN
      END SUBROUTINE STATE$UNSELECT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE STATE$ISELECT(I)  ! MARK: STATE$ISELECT
!     **************************************************************************
!     ** SELECT STATE ARRAY BY INDEX                                          **
!     **************************************************************************
      USE STATE_MODULE, ONLY: GROUND,EXCITE,THIS,SELECTED
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: I
      IF(SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('CANNOT SELECT STATE ARRAY WHEN ALREADY SELECTED')
        CALL ERROR$STOP('STATE$ISELECT')
      END IF
      IF(I.EQ.1) THEN
        ! IF(.NOT.ALLOCATED(GROUND)) THEN
        !   CALL ERROR$MSG('GROUND STATE ARRAY NOT ALLOCATED')
        !   CALL ERROR$STOP('STATE$ISELECT')
        ! END IF
        THIS=>GROUND
      ELSE IF(I.EQ.2) THEN
        ! IF(.NOT.ALLOCATED(EXCITE)) THEN
        !   CALL ERROR$MSG('EXCITE STATE ARRAY NOT ALLOCATED')
        !   CALL ERROR$STOP('STATE$ISELECT')
        ! END IF
        THIS=>EXCITE
      ELSE
        CALL ERROR$MSG('STATE ISELECT INDEX NOT RECOGNIZED')
        CALL ERROR$I4VAL('INDEX: ',I)
        CALL ERROR$STOP('STATE$ISELECT')
      END IF
      SELECTED=.TRUE.
      RETURN
      END SUBROUTINE STATE$ISELECT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE STATE$NEW(IKPT,ISPIN,NB)  ! MARK: STATE$NEW
!     **************************************************************************
!     ** CREATE NEW STATE IN ARRAY                                            **
!     ** REQUIRES SELECTED STATE ARRAY                                        **
!     **************************************************************************
      USE STATE_MODULE, ONLY: THIS,SELECTED,NKPTG,NSPING
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: IKPT
      INTEGER(4), INTENT(IN) :: ISPIN
      INTEGER(4), INTENT(IN) :: NB
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO STATE ARRAY SELECTED')
        CALL ERROR$STOP('STATE$NEW')
      END IF
      IF(IKPT.LE.0.OR.IKPT.GT.NKPTG) THEN
        CALL ERROR$MSG('INVALID KPOINT INDEX')
        CALL ERROR$I4VAL('KPOINT INDEX: ',IKPT)
        CALL ERROR$STOP('STATE$NEW')
      END IF
      IF(ISPIN.LE.0.OR.ISPIN.GT.NSPING) THEN
        CALL ERROR$MSG('INVALID SPIN INDEX')
        CALL ERROR$I4VAL('SPIN INDEX: ',ISPIN)
        CALL ERROR$STOP('STATE$NEW')
      END IF
      IF(NB.LE.0) THEN
        CALL ERROR$MSG('NUMBER OF BANDS MUST BE POSITIVE')
        CALL ERROR$I4VAL('NUMBER OF BANDS: ',NB)
        CALL ERROR$STOP('STATE$NEW')
      END IF
      IF(THIS(IKPT,ISPIN)%NB.NE.(-HUGE(1))) THEN
        CALL ERROR$MSG('STATE ALREADY EXISTS')
        CALL ERROR$I4VAL('KPOINT INDEX: ',IKPT)
        CALL ERROR$I4VAL('SPIN INDEX: ',ISPIN)
        CALL ERROR$STOP('STATE$NEW')
      END IF
      ! INITIALIZE STATE
      THIS(IKPT,ISPIN)%NB=NB
      ALLOCATE(THIS(IKPT,ISPIN)%EIG(NB))
      ALLOCATE(THIS(IKPT,ISPIN)%OCC(NB))
      ! TODO: PROJ IS NOT ALLOCATED HERE AS IT MIGHT NOT BE USED WITH A RESTART FILE
      RETURN
      END SUBROUTINE STATE$NEW
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE STATE$GETI4(ID,IKPT,ISPIN,VAL)  ! MARK: STATE$GETI4
!     **************************************************************************
!     ** GET INTEGER VALUE FROM SELECTED STATE                                **
!     ** REQUIRES SELECTED STATE ARRAY                                        **
!     **************************************************************************
      USE STATE_MODULE, ONLY: THIS,SELECTED,NKPTG,NSPING
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: IKPT
      INTEGER(4), INTENT(IN) :: ISPIN
      INTEGER(4), INTENT(OUT) :: VAL
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO STATE ARRAY SELECTED')
        CALL ERROR$STOP('STATE$GETI4')
      END IF
      IF(IKPT.LE.0.OR.IKPT.GT.NKPTG) THEN
        CALL ERROR$MSG('INVALID KPOINT INDEX')
        CALL ERROR$I4VAL('KPOINT INDEX: ',IKPT)
        CALL ERROR$STOP('STATE$GETI4')
      END IF
      IF(ISPIN.LE.0.OR.ISPIN.GT.NSPING) THEN
        CALL ERROR$MSG('INVALID SPIN INDEX')
        CALL ERROR$I4VAL('SPIN INDEX: ',ISPIN)
        CALL ERROR$STOP('STATE$GETI4')
      END IF
      IF(ID.EQ.'NB') THEN
        VAL=THIS(IKPT,ISPIN)%NB
      ELSE IF(ID.EQ.'NOCC') THEN
        ! TODO: TRIGGER CALCULATION OF NOCC HERE
        CALL ERROR$MSG('NOCC NOT IMPLEMENTED YET')
        CALL ERROR$STOP('STATE$GETI4')
        VAL=THIS(IKPT,ISPIN)%NOCC
      ELSE
        CALL ERROR$MSG('STATE GETI4 ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('STATE$GETI4')
      END IF
      RETURN
      END SUBROUTINE STATE$GETI4
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE STATE$SETR8A(ID,IKPT,ISPIN,LEN,VAL)  ! MARK: STATE$SETR8A
!     **************************************************************************
!     ** SET REAL VALUE ARRAY IN SELECTED STATE                               **
!     ** REQUIRES SELECTED STATE ARRAY                                        **
!     **************************************************************************
      USE STATE_MODULE, ONLY: THIS,SELECTED,NKPTG,NSPING
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: IKPT
      INTEGER(4), INTENT(IN) :: ISPIN
      INTEGER(4), INTENT(IN) :: LEN
      REAL(8), INTENT(IN) :: VAL(LEN)
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO STATE ARRAY SELECTED')
        CALL ERROR$STOP('STATE$SETR8A')
      END IF
      IF(IKPT.LE.0.OR.IKPT.GT.NKPTG) THEN
        CALL ERROR$MSG('INVALID KPOINT INDEX')
        CALL ERROR$I4VAL('KPOINT INDEX: ',IKPT)
        CALL ERROR$STOP('STATE$SETR8A')
      END IF
      IF(ISPIN.LE.0.OR.ISPIN.GT.NSPING) THEN
        CALL ERROR$MSG('INVALID SPIN INDEX')
        CALL ERROR$I4VAL('SPIN INDEX: ',ISPIN)
        CALL ERROR$STOP('STATE$SETR8A')
      END IF
      IF(ID.EQ.'EIG') THEN
        IF(LEN.NE.THIS(IKPT,ISPIN)%NB) THEN
          CALL ERROR$MSG('LEN MUST BE EQUAL TO NUMBER OF BANDS')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$I4VAL('NB: ',THIS(IKPT,ISPIN)%NB)
          CALL ERROR$CHVAL('ID: ',ID)
          CALL ERROR$STOP('STATE$SETR8A')
        END IF
        THIS(IKPT,ISPIN)%EIG(:)=VAL(:)
      ELSE IF(ID.EQ.'OCC') THEN
        IF(LEN.NE.THIS(IKPT,ISPIN)%NB) THEN
          CALL ERROR$MSG('LENGTH MUST BE EQUAL TO NUMBER OF BANDS')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$I4VAL('NB: ',THIS(IKPT,ISPIN)%NB)
          CALL ERROR$CHVAL('ID: ',ID)
          CALL ERROR$STOP('STATE$SETR8A')
        END IF
        THIS(IKPT,ISPIN)%OCC=VAL(:)
      ELSE
        CALL ERROR$MSG('STATE SETR8A ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('STATE$SETR8A')
      END IF
      RETURN
      END SUBROUTINE STATE$SETR8A
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE STATE$GETR8A(ID,IKPT,ISPIN,LEN,VAL)  ! MARK: STATE$GETR8A
!     **************************************************************************
!     ** GET REAL VALUE ARRAY FROM SELECTED STATE                             **
!     ** REQUIRES SELECTED STATE ARRAY                                        **
!     **************************************************************************
      USE STATE_MODULE, ONLY: THIS,SELECTED,NKPTG,NSPING
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: IKPT
      INTEGER(4), INTENT(IN) :: ISPIN
      INTEGER(4), INTENT(IN) :: LEN
      REAL(8), INTENT(OUT) :: VAL(LEN)
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO STATE ARRAY SELECTED')
        CALL ERROR$STOP('STATE$GETR8A')
      END IF
      IF(IKPT.LE.0.OR.IKPT.GT.NKPTG) THEN
        CALL ERROR$MSG('INVALID KPOINT INDEX')
        CALL ERROR$I4VAL('KPOINT INDEX: ',IKPT)
        CALL ERROR$STOP('STATE$GETR8A')
      END IF
      IF(ISPIN.LE.0.OR.ISPIN.GT.NSPING) THEN
        CALL ERROR$MSG('INVALID SPIN INDEX')
        CALL ERROR$I4VAL('SPIN INDEX: ',ISPIN)
        CALL ERROR$STOP('STATE$GETR8A')
      END IF
      IF(ID.EQ.'EIG') THEN
        IF(LEN.NE.THIS(IKPT,ISPIN)%NB) THEN
          CALL ERROR$MSG('LEN MUST BE EQUAL TO NUMBER OF BANDS')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$I4VAL('NB: ',THIS(IKPT,ISPIN)%NB)
          CALL ERROR$CHVAL('ID: ',ID)
          CALL ERROR$STOP('STATE$GETR8A')
        END IF
        VAL(:)=THIS(IKPT,ISPIN)%EIG(:)
      ELSE IF(ID.EQ.'OCC') THEN
        IF(LEN.NE.THIS(IKPT,ISPIN)%NB) THEN
          CALL ERROR$MSG('LENGTH MUST BE EQUAL TO NUMBER OF BANDS')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$I4VAL('NB: ',THIS(IKPT,ISPIN)%NB)
          CALL ERROR$CHVAL('ID: ',ID)
          CALL ERROR$STOP('STATE$GETR8A')
        END IF
        VAL(:)=THIS(IKPT,ISPIN)%OCC(:)
      ELSE
        CALL ERROR$MSG('STATE GETR8A ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('STATE$GETR8A')
      END IF
      RETURN
      END SUBROUTINE STATE$GETR8A
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE STATE$SETC8A(ID,IKPT,ISPIN,LEN,VAL)  ! MARK: STATE$SETC8A
!     **************************************************************************
!     ** SET COMPLEX VALUE ARRAY IN SELECTED STATE                            **
!     ** REQUIRES SELECTED STATE ARRAY                                        **
!     **************************************************************************
      USE STATE_MODULE, ONLY: THIS,SELECTED,NKPTG,NSPING,NDIM,NPRO
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: IKPT
      INTEGER(4), INTENT(IN) :: ISPIN
      INTEGER(4), INTENT(IN) :: LEN
      COMPLEX(8), INTENT(IN) :: VAL(LEN)
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO STATE ARRAY SELECTED')
        CALL ERROR$STOP('STATE$SETC8A')
      END IF
      IF(IKPT.LE.0.OR.IKPT.GT.NKPTG) THEN
        CALL ERROR$MSG('INVALID KPOINT INDEX')
        CALL ERROR$I4VAL('KPOINT INDEX: ',IKPT)
        CALL ERROR$STOP('STATE$SETC8A')
      END IF
      IF(ISPIN.LE.0.OR.ISPIN.GT.NSPING) THEN
        CALL ERROR$MSG('INVALID SPIN INDEX')
        CALL ERROR$I4VAL('SPIN INDEX: ',ISPIN)
        CALL ERROR$STOP('STATE$SETC8A')
      END IF
      IF(ID.EQ.'PROJ') THEN
        IF(LEN.NE.NDIM*THIS(IKPT,ISPIN)%NB*NPRO) THEN
          CALL ERROR$MSG('LEN MUST BE EQUAL TO NDIM*NB*NPRO')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$I4VAL('NDIM*NB*NPRO: ',NDIM*THIS(IKPT,ISPIN)%NB*NPRO)
          CALL ERROR$CHVAL('ID: ',ID)
          CALL ERROR$STOP('STATE$SETC8A')
        END IF
        IF(.NOT.ALLOCATED(THIS(IKPT,ISPIN)%PROJ)) THEN
          ALLOCATE(THIS(IKPT,ISPIN)%PROJ(NDIM,THIS(IKPT,ISPIN)%NB,NPRO))
        END IF
        THIS(IKPT,ISPIN)%PROJ=RESHAPE(VAL,(/NDIM,THIS(IKPT,ISPIN)%NB,NPRO/))
      ELSE
        CALL ERROR$MSG('STATE SETC8A ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('STATE$SETC8A')
      END IF
      RETURN
      END SUBROUTINE STATE$SETC8A
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE STATE$GETC8A(ID,IKPT,ISPIN,LEN,VAL)  ! MARK: STATE$GETC8A
!     **************************************************************************
!     ** GET COMPLEX VALUE ARRAY FROM SELECTED STATE                          **
!     ** REQUIRES SELECTED STATE ARRAY                                        **
!     **************************************************************************
      USE STATE_MODULE, ONLY: THIS,SELECTED,NKPTG,NSPING,NDIM,NPRO
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4), INTENT(IN) :: IKPT
      INTEGER(4), INTENT(IN) :: ISPIN
      INTEGER(4), INTENT(IN) :: LEN
      COMPLEX(8), INTENT(OUT) :: VAL(LEN)
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO STATE ARRAY SELECTED')
        CALL ERROR$STOP('STATE$GETC8A')
      END IF
      IF(IKPT.LE.0.OR.IKPT.GT.NKPTG) THEN
        CALL ERROR$MSG('INVALID KPOINT INDEX')
        CALL ERROR$I4VAL('KPOINT INDEX: ',IKPT)
        CALL ERROR$STOP('STATE$GETC8A')
      END IF
      IF(ISPIN.LE.0.OR.ISPIN.GT.NSPING) THEN
        CALL ERROR$MSG('INVALID SPIN INDEX')
        CALL ERROR$I4VAL('SPIN INDEX: ',ISPIN)
        CALL ERROR$STOP('STATE$GETC8A')
      END IF
      IF(ID.EQ.'PROJ') THEN
        IF(LEN.NE.NDIM*THIS(IKPT,ISPIN)%NB*NPRO) THEN
          CALL ERROR$MSG('LEN MUST BE EQUAL TO NDIM*NB*NPRO')
          CALL ERROR$I4VAL('LEN: ',LEN)
          CALL ERROR$I4VAL('NDIM*NB*NPRO: ',NDIM*THIS(IKPT,ISPIN)%NB*NPRO)
          CALL ERROR$CHVAL('ID: ',ID)
          CALL ERROR$STOP('STATE$GETC8A')
        END IF
        IF(.NOT.ALLOCATED(THIS(IKPT,ISPIN)%PROJ)) THEN
          CALL ERROR$MSG('PROJ NOT ALLOCATED')
          CALL ERROR$I4VAL('IKPT: ',IKPT)
          CALL ERROR$I4VAL('ISPIN: ',ISPIN)
          CALL ERROR$STOP('STATE$GETC8A')
        END IF
        VAL(:)=RESHAPE(THIS(IKPT,ISPIN)%PROJ,(/NDIM*THIS(IKPT,ISPIN)%NB*NPRO/))
      ELSE
        CALL ERROR$MSG('STATE GETC8A ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID: ',ID)
        CALL ERROR$STOP('STATE$GETC8A')
      END IF
      RETURN
      END SUBROUTINE STATE$GETC8A
!
!     ==========================================================================
!     ==========================================================================
!     ==                    OVERLAP MODULE FUNCTIONS                          ==
!     ==========================================================================
!     ==========================================================================
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE OVERLAP$INIT(NKPT_,NSPIN_)  ! MARK: OVERLAP$INIT
!     **************************************************************************
!     ** INITIALIZE OVERLAP MODULE                                            **
!     **************************************************************************
      USE OVERLAP_MODULE, ONLY: NKPTG,NSPING,OVLARR,INITIALIZED
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: NKPT_
      INTEGER(4), INTENT(IN) :: NSPIN_
                          CALL TRACE$PUSH('OVERLAP$INIT')
      IF(INITIALIZED) THEN
        CALL ERROR$MSG('OVERLAP ALREADY INITIALIZED')
        CALL ERROR$STOP('OVERLAP$INIT')
      END IF
      NKPTG=NKPT_
      NSPING=NSPIN_
      ALLOCATE(OVLARR(NKPTG,NSPING))
      INITIALIZED=.TRUE.
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE OVERLAP$INIT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE OVERLAP$SELECT(IKPT,ISPIN)  ! MARK: OVERLAP$SELECT
!     **************************************************************************
!     ** SELECT OVERLAP FOR KPOINT AND SPIN                                   **
!     **************************************************************************
      USE OVERLAP_MODULE, ONLY: OVLARR,THIS,SELECTED,NKPTG,NSPING
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: IKPT
      INTEGER(4), INTENT(IN) :: ISPIN
      IF(SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('CANNOT SELECT OVERLAP WHEN ALREADY SELECTED')
        CALL ERROR$STOP('OVERLAP$SELECT')
      END IF
      IF(IKPT.LE.0.OR.IKPT.GT.NKPTG) THEN
        CALL ERROR$MSG('INVALID KPOINT INDEX')
        CALL ERROR$I4VAL('KPOINT INDEX: ',IKPT)
        CALL ERROR$STOP('OVERLAP$SELECT')
      END IF
      IF(ISPIN.LE.0.OR.ISPIN.GT.NSPING) THEN
        CALL ERROR$MSG('INVALID SPIN INDEX')
        CALL ERROR$I4VAL('SPIN INDEX: ',ISPIN)
        CALL ERROR$STOP('OVERLAP$SELECT')
      END IF
      THIS=>OVLARR(IKPT,ISPIN)
      SELECTED=.TRUE.
      RETURN
      END SUBROUTINE OVERLAP$SELECT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE OVERLAP$UNSELECT()  ! MARK: OVERLAP$UNSELECT
!     **************************************************************************
!     ** UNSELECT OVERLAP                                                    **
!     **************************************************************************
      USE OVERLAP_MODULE, ONLY: THIS,SELECTED
      IMPLICIT NONE
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('SAFEGUARD FUNCTION:')
        CALL ERROR$MSG('CANNOT UNSELECT OVERLAP WHEN NOT SELECTED')
        CALL ERROR$STOP('OVERLAP$UNSELECT')
      END IF
      SELECTED=.FALSE.
      NULLIFY(THIS)
      RETURN
      END SUBROUTINE OVERLAP$UNSELECT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XRAY$READ  ! MARK: XRAY$READ
!     **************************************************************************
!     ** READ SIMULATION FILES IN PARALLEL AND CALCULATE PLANE WAVE OVERLAP   **
!     ** ON THE FLY.                                                          **
!     **************************************************************************
      USE MPE_MODULE
      IMPLICIT NONE
      ! CHANGING THIS WILL LIKELY BREAK THINGS
      INTEGER(4), PARAMETER :: NSIM=2
      LOGICAL(4), PARAMETER :: TPR=.TRUE.
      INTEGER(4) :: NFIL(2)
      CHARACTER(6) :: ID
      INTEGER(4) :: NAT,NSP,NKPT,NSPIN,NDIM,LNXX
      INTEGER(4) :: NPRO(NSIM)
      CHARACTER(6) :: FLAG
      INTEGER(4), ALLOCATABLE :: LNX(:)  ! (NSP)
      INTEGER(4), ALLOCATABLE :: LOX(:,:)  ! (LNXX,NSP)
      INTEGER(4) :: NKDIV(3)
      INTEGER(4) :: ISHIFT(3)
      REAL(8) :: RNTOT
      REAL(8) :: NEL
      REAL(8) :: EDFT
      INTEGER(4) :: ILOGICAL
      LOGICAL(4) :: TINV
      INTEGER(4) :: SPACEGROUP
      LOGICAL(4) :: TSHIFT
      REAL(8), ALLOCATABLE :: R(:,:)  ! (3,NAT)
      CHARACTER(16), ALLOCATABLE :: ATOMID(:)  ! (NAT)
      INTEGER(4), ALLOCATABLE :: ISPECIES(:)  ! (NAT)
      REAL(8) :: RBAS(3,3)
      REAL(8) :: VCELL
      INTEGER(4) :: GID
      CHARACTER(8) :: GRIDTYPE
      INTEGER(4) :: NR
      REAL(8) :: DEX
      REAL(8) :: R1
      REAL(8) :: ECORE
      REAL(8), ALLOCATABLE :: PSPHI(:,:)  ! (NR,LNX)
      REAL(8), ALLOCATABLE :: AEPHI(:,:)  ! (NR,LNX)
      INTEGER(4) :: NBATOM
      INTEGER(4), ALLOCATABLE :: LATOM(:)  ! (NBATOM)
      REAL(8), ALLOCATABLE :: AEPSI(:,:)  ! (NR,NBATOM)
      INTEGER(4) :: NBX
      INTEGER(4) :: NKPT_
      INTEGER(4) :: NSPIN_
      REAL(8), ALLOCATABLE :: OCC(:,:,:)  ! (NMX,NKPT_,NSPIN_)
      REAL(8), ALLOCATABLE :: XK(:,:)  ! (3,NKPT_)
      REAL(8), ALLOCATABLE :: WKPT(:)  ! (NKPT_)
      CHARACTER(8) :: KEY(NSIM)
      INTEGER(4) :: NGG(NSIM)
      INTEGER(4) :: NDIM_(NSIM)
      INTEGER(4) :: NB(NSIM)
      LOGICAL(4) :: TSUPER(NSIM)

      INTEGER(4), ALLOCATABLE :: IGVEC(:,:,:) ! (NSIM,3,NGG)
      REAL(8) :: XK_(NSIM,3)
      COMPLEX(8), ALLOCATABLE :: PSIK1(:,:,:) ! (NGG,NDIM,NB)
      COMPLEX(8), ALLOCATABLE :: PSIK2(:,:,:) ! (NGG,NDIM,NB)
      COMPLEX(8), ALLOCATABLE :: PROJ1(:,:,:) ! (NDIM,NB,NPRO)
      COMPLEX(8), ALLOCATABLE :: PROJ2(:,:,:) ! (NDIM,NB,NPRO)
      REAL(8), ALLOCATABLE :: EIG1(:) ! (NB)
      REAL(8), ALLOCATABLE :: EIG2(:) ! (NB)

      COMPLEX(8), ALLOCATABLE :: PW(:,:) ! (NB2,NB1)

      INTEGER(4) :: ISIM
      INTEGER(4) :: ISP
      INTEGER(4) :: IKPT
      INTEGER(4) :: ISPIN
      INTEGER(4) :: IB1
      INTEGER(4) :: IB2
      INTEGER(4) :: NTASKS,THISTASK,RTASK,WTASK
      INTEGER(4), ALLOCATABLE :: WTASKSKPT(:) ! (NSPING)

                          CALL TRACE$PUSH('XRAY$READ')
                          CALL TIMING$CLOCKON('XRAY$READ')
      CALL MPE$QUERY('~',NTASKS,THISTASK)

      DO ISIM=1,NSIM
        CALL SIMULATION$ISELECT(ISIM)
        ! ERROR: ID AND FILE MUST HAVE BEEN SET BEFORE
        CALL SIMULATION$GETCH('ID',ID)
        IF(THISTASK.EQ.1) THEN
          IF(TPR) CALL TRACE$PASS('READING GENERAL QUANTITIES')
          ! ERROR: FILEHANDLING FOR SIMULATION FILES MISSING
          CALL FILEHANDLER$UNIT(ID,NFIL(ISIM))
          REWIND(NFIL(ISIM))
          ! ======================================================================
          ! == READ GENERAL QUANTATIES                                          ==
          ! ======================================================================
          ! NAT,NSP,NKPT,NSPIN,NDIM,NPRO,LNXX,FLAG
          READ(NFIL(ISIM))NAT,NSP,NKPT,NSPIN,NDIM,NPRO(ISIM),LNXX,FLAG
        END IF
        CALL MPE$BROADCAST('~',1,NAT)
        CALL MPE$BROADCAST('~',1,NSP)
        CALL MPE$BROADCAST('~',1,NKPT)
        CALL MPE$BROADCAST('~',1,NSPIN)
        CALL MPE$BROADCAST('~',1,NDIM)
        CALL MPE$BROADCAST('~',1,NPRO(ISIM))
        CALL MPE$BROADCAST('~',1,LNXX)
        CALL MPE$BROADCAST('~',1,FLAG)
        CALL SIMULATION$INIT(NAT,NSP,NKPT,NSPIN,NDIM,NPRO(ISIM),LNXX,FLAG)
        ! DISTRIBUTE WORKLOAD FOR K-POINT AND SPIN LOOPS WHILE READING
        CALL KSMAP$INIT(NKPT,NSPIN)
        CALL KSMAP$READTASK(RTASK)

        ALLOCATE(LNX(NSP))
        ALLOCATE(LOX(LNXX,NSP))
        IF(THISTASK.EQ.RTASK) THEN
          ! LNX(NSP),LOX(LNXX,NSP)
          READ(NFIL(ISIM))LNX,LOX
          ! NKDIV(3),ISHIFT(3),RNTOT,NEL,EDFT,ILOGICAL
          READ(NFIL(ISIM))NKDIV,ISHIFT,RNTOT,NEL,EDFT,ILOGICAL
          TINV=.FALSE.
          IF(ILOGICAL.EQ.1) TINV=.TRUE.
          ! SPACEGROUP,TSHIFT
          READ(NFIL(ISIM))SPACEGROUP,ILOGICAL
          TSHIFT=.FALSE.
          IF(ILOGICAL.EQ.1) TSHIFT=.TRUE.
        END IF
        CALL MPE$BROADCAST('~',RTASK,LNX)
        CALL MPE$BROADCAST('~',RTASK,LOX)
        CALL MPE$BROADCAST('~',RTASK,NKDIV)
        CALL MPE$BROADCAST('~',RTASK,ISHIFT)
        CALL MPE$BROADCAST('~',RTASK,RNTOT)
        CALL MPE$BROADCAST('~',RTASK,NEL)
        CALL MPE$BROADCAST('~',RTASK,EDFT)
        CALL MPE$BROADCAST('~',RTASK,TINV)
        CALL MPE$BROADCAST('~',RTASK,SPACEGROUP)
        CALL MPE$BROADCAST('~',RTASK,TSHIFT)
        CALL SIMULATION$SETI4A('LNX',NSP,LNX)
        CALL SIMULATION$SETI4A('LOX',LNXX*NSP,LOX)
        CALL SIMULATION$SETI4A('NKDIV',3,NKDIV)
        CALL SIMULATION$SETI4A('ISHIFT',3,ISHIFT)
        CALL SIMULATION$SETR8('RNTOT',RNTOT)
        CALL SIMULATION$SETR8('NEL',NEL)
        CALL SIMULATION$SETR8('EDFT',EDFT)
        CALL SIMULATION$SETL4('TINV',TINV)
        CALL SIMULATION$SETI4('SPACEGROUP',SPACEGROUP)
        CALL SIMULATION$SETL4('TSHIFT',TSHIFT)
        ! ======================================================================
        ! ==  READ ATOMIC STRUCTURE                                           ==
        ! ======================================================================
        ALLOCATE(R(3,NAT))
        ALLOCATE(ATOMID(NAT))
        ALLOCATE(ISPECIES(NAT))
        IF(THISTASK.EQ.RTASK) THEN
          IF(TPR) CALL TRACE$PASS('READING ATOMIC STRUCTURE')
          ! RBAS(3,3),R(3,NAT),ATOMID(NAT),ISPECIES(NAT)
          READ(NFIL(ISIM))RBAS,R,ATOMID,ISPECIES
        END IF
        CALL MPE$BROADCAST('~',RTASK,RBAS)
        CALL MPE$BROADCAST('~',RTASK,R)
        CALL MPE$BROADCAST('~',RTASK,ATOMID)
        CALL MPE$BROADCAST('~',RTASK,ISPECIES)
        CALL SIMULATION$SETR8A('RBAS',9,RBAS)
        CALL SIMULATION$SETR8A('R',3*NAT,R)
        CALL SIMULATION$SETCHA('ATOMID',NAT,ATOMID)
        CALL SIMULATION$SETI4A('ISPECIES',NAT,ISPECIES)
        CALL SIMULATION$GETR8('VCELL',VCELL)
        ! ======================================================================
        ! ==  ELEMENT SPECIFIC QUANTITIES                                     ==
        ! ======================================================================
        CALL XSETUP$INIT(ISIM,NSP)
        CALL XSETUP$ISELECT(ISIM)
        DO ISP=1,NSP
          IF(THISTASK.EQ.RTASK) THEN
            IF(TPR) CALL TRACE$PASS('READING ELEMENT SPECIFIC QUANTITIES')
            ! GRIDTYPE,NR,DEX,R1
            READ(NFIL(ISIM))GRIDTYPE,NR,DEX,R1
            ! ECORE
            READ(NFIL(ISIM))ECORE
          END IF
          CALL MPE$BROADCAST('~',RTASK,GRIDTYPE)
          CALL MPE$BROADCAST('~',RTASK,NR)
          CALL MPE$BROADCAST('~',RTASK,DEX)
          CALL MPE$BROADCAST('~',RTASK,R1)
          CALL MPE$BROADCAST('~',RTASK,ECORE)
          CALL RADIAL$NEW(GRIDTYPE,GID)
          CALL RADIAL$SETI4(GID,'NR',NR)
          CALL RADIAL$SETR8(GID,'DEX',DEX)
          CALL RADIAL$SETR8(GID,'R1',R1)
          ALLOCATE(PSPHI(NR,LNX(ISP)))
          ALLOCATE(AEPHI(NR,LNX(ISP)))
          IF(THISTASK.EQ.RTASK) THEN
            ! PSPHI(NR,LNX(ISP))
            READ(NFIL(ISIM))PSPHI
            ! AEPHI(NR,LNX(ISP))
            READ(NFIL(ISIM))AEPHI
            ! NBATOM
            READ(NFIL(ISIM))NBATOM
          END IF
          CALL MPE$BROADCAST('~',RTASK,PSPHI)
          CALL MPE$BROADCAST('~',RTASK,AEPHI)
          CALL MPE$BROADCAST('~',RTASK,NBATOM)
          ALLOCATE(LATOM(NBATOM))
          ALLOCATE(AEPSI(NR,NBATOM))
          IF(THISTASK.EQ.RTASK) THEN
            ! LATOM(NBATOM)
            READ(NFIL(ISIM))LATOM
            ! AEPSI(NR,NBATOM)
            READ(NFIL(ISIM))AEPSI
          END IF
          CALL MPE$BROADCAST('~',RTASK,LATOM)
          CALL MPE$BROADCAST('~',RTASK,AEPSI)
          CALL XSETUP$NEW(ISP,GID,ECORE,LNXX,LNX(ISP),LOX(:,ISP),NBATOM)
          CALL XSETUP$SETR8A('PSPHI',ISP,NR*LNX(ISP),PSPHI)
          CALL XSETUP$SETR8A('AEPHI',ISP,NR*LNX(ISP),AEPHI)
          CALL XSETUP$SETI4A('LATOM',ISP,NBATOM,LATOM)
          CALL XSETUP$SETR8A('AEPSI',ISP,NR*NBATOM,AEPSI)
          DEALLOCATE(PSPHI)
          DEALLOCATE(AEPHI)
          DEALLOCATE(LATOM)
          DEALLOCATE(AEPSI)
        ENDDO ! END ISP
        ! ======================================================================
        ! ==  OCCUPATIONS AND K-POINTS AND THEIR WEIGHTS                      ==
        ! ======================================================================
        IF(THISTASK.EQ.RTASK) THEN
          IF(TPR) CALL TRACE$PASS('READING K-POINTS AND OCCUPATIONS')
          ! NBX,NKPT_,NSPIN_
          READ(NFIL(ISIM))NBX,NKPT_,NSPIN_
          IF(NKPT_.NE.NKPT.OR.NSPIN_.NE.NSPIN) THEN
            CALL ERROR$MSG('NKPT OR NSPIN NOT CONSISTENT WITH INITIALIZATION')
            CALL ERROR$I4VAL('NKPT: ',NKPT_)
            CALL ERROR$I4VAL('NSPIN: ',NSPIN_)
            CALL ERROR$I4VAL('INITIALIZED NKPT: ',NKPT)
            CALL ERROR$I4VAL('INITIALIZED NSPIN: ',NSPIN)
            CALL ERROR$STOP('XRAY$READ')
          END IF
        END IF
        CALL MPE$BROADCAST('~',RTASK,NBX)
        CALL MPE$BROADCAST('~',RTASK,NKPT)
        CALL MPE$BROADCAST('~',RTASK,NSPIN)

        ALLOCATE(OCC(NBX,NKPT,NSPIN))
        ALLOCATE(XK(3,NKPT))
        ALLOCATE(WKPT(NKPT))
        ! OCC(NBX,NKPT,NSPIN), XK(3,NKPT),WKPT(NKPT)
        IF(THISTASK.EQ.RTASK) THEN
          READ(NFIL(ISIM))OCC,XK,WKPT
        END IF
        CALL MPE$BROADCAST('~',RTASK,OCC)
        CALL MPE$BROADCAST('~',RTASK,XK)
        CALL MPE$BROADCAST('~',RTASK,WKPT)
        CALL SIMULATION$SETR8A('XK',3*NKPT,XK)
        CALL SIMULATION$SETR8A('WKPT',NKPT,WKPT)
        DEALLOCATE(XK)
        DEALLOCATE(WKPT)

        CALL STATE$INIT(ISIM,NKPT,NSPIN,NDIM,NPRO(ISIM))
        CALL STATE$ISELECT(ISIM)
        DO IKPT=1,NKPT
          DO ISPIN=1,NSPIN
            CALL KSMAP$WORKTASK(IKPT,ISPIN,WTASK)
            IF(THISTASK.NE.WTASK.AND.THISTASK.NE.RTASK) CYCLE
            CALL STATE$NEW(IKPT,ISPIN,NBX)
            CALL STATE$SETR8A('OCC',IKPT,ISPIN,NBX,OCC(:,IKPT,ISPIN))
          ENDDO ! END ISPIN
        ENDDO ! END IKPT
        DEALLOCATE(OCC)
        DEALLOCATE(LNX)
        DEALLOCATE(LOX)
        DEALLOCATE(R)
        DEALLOCATE(ATOMID)
        DEALLOCATE(ISPECIES)
        CALL XSETUP$UNSELECT
        CALL SIMULATION$UNSELECT
        CALL STATE$UNSELECT
      ENDDO ! END ISIM

      ! CREATE MAPPING BETWEEN ATOMS IN THE SIMULATION GROUND TO EXCITE
      CALL SIMULATION_ATOMMAP
      ! FIND INDEX OF COREHOLE ATOM IN SIMULATION GROUND
      CALL SETTINGS_IATOM

      ! ========================================================================
      ! ==  WAVE FUNCTIONS AND PROJECTIONS                                    ==
      ! ========================================================================
      CALL OVERLAP$INIT(NKPT,NSPIN)
      ALLOCATE(WTASKSKPT(NSPIN))
      DO IKPT=1,NKPT
        CALL KSMAP$WORKTASKSKPT(IKPT,WTASKSKPT)
        ! CYCLE EARLY IF THIS TASK IS NOT WORKING ON THIS KPOINT
        IF(ALL(THISTASK.NE.WTASKSKPT(:)).AND.THISTASK.NE.RTASK) CYCLE

        IF(THISTASK.EQ.RTASK) THEN
          IF(TPR) CALL TRACE$I4VAL(' READ/SEND IKPT: ',IKPT)
          ! READ GENERAL INFORMATION ABOUT K POINT
          DO ISIM=1,NSIM
            ! KEY,NGG,NDIM,NB,TSUPER
            READ(NFIL(ISIM))KEY(ISIM),NGG(ISIM),NDIM_(ISIM),NB(ISIM),ILOGICAL
            TSUPER(ISIM)=.FALSE.
            IF(ILOGICAL.EQ.1) TSUPER(ISIM)=.TRUE.
            IF(KEY(ISIM).NE.'PSI') THEN
              CALL ERROR$MSG('KEY NOT "PSI"')
              CALL ERROR$MSG('FILE IS CORRUPTED') 
              CALL ERROR$CHVAL('KEY: ',KEY(ISIM))
              CALL ERROR$I4VAL('IKPT: ',IKPT)
              CALL ERROR$STOP('XRAY$READ')
            END IF
          ENDDO ! END ISIM
          ! TODO: CHECK IF NGG IS THE SAME? IS THAT REQUIRED?
          ! READ K POINT AND G VECTORS 
          ALLOCATE(IGVEC(NSIM,3,NGG(1)))
          DO ISIM=1,NSIM
            ! XK_(3),IGVEC(ISIM,3,NGG)
            READ(NFIL(ISIM))XK_(ISIM,:),IGVEC(ISIM,:,:)
          ENDDO ! END ISIM
          CALL TESTKPT!(NSIM,KEY,NGG,NDIM_,TSUPER,XK_,IGVEC)
          DEALLOCATE(IGVEC)
        END IF
        DO ISPIN=1,NSPIN
          CALL KSMAP$WORKTASK(IKPT,ISPIN,WTASK)
          CALL MPE$SENDRECEIVE('~',RTASK,WTASK,NGG)
          CALL MPE$SENDRECEIVE('~',RTASK,WTASK,NDIM_)
          CALL MPE$SENDRECEIVE('~',RTASK,WTASK,NB)
        ENDDO ! END ISPIN
        ! WARNING: REQUIRES SUPER WAVE FUNCTIONS TO BE UNRAVELLED
        ALLOCATE(PSIK1(NGG(1),NDIM_(1),NB(1)))
        ALLOCATE(PSIK2(NGG(2),NDIM_(2),NB(2)))
        ALLOCATE(PROJ1(NDIM_(1),NB(1),NPRO(1)))
        ALLOCATE(PROJ2(NDIM_(2),NB(2),NPRO(2)))
        ALLOCATE(EIG1(NB(1)))
        ALLOCATE(EIG2(NB(2)))
        ALLOCATE(PW(NB(2),NB(1)))

        DO ISPIN=1,NSPIN
          CALL KSMAP$WORKTASK(IKPT,ISPIN,WTASK)
          IF(THISTASK.NE.WTASK.AND.THISTASK.NE.RTASK) CYCLE

          IF(THISTASK.EQ.RTASK) THEN
            ! READ PLANE WAVE BASIS
            READ(NFIL(1))PSIK1
            READ(NFIL(2))PSIK2
            ! READ PROJECTIONS
            READ(NFIL(1))PROJ1
            READ(NFIL(2))PROJ2
            ! READ EIGENVALUES
            READ(NFIL(1))EIG1
            READ(NFIL(2))EIG2
          END IF
          CALL MPE$SENDRECEIVE('~',RTASK,WTASK,PSIK1)
          CALL MPE$SENDRECEIVE('~',RTASK,WTASK,PSIK2)
          CALL MPE$SENDRECEIVE('~',RTASK,WTASK,PROJ1)
          CALL MPE$SENDRECEIVE('~',RTASK,WTASK,PROJ2)
          CALL MPE$SENDRECEIVE('~',RTASK,WTASK,EIG1)
          CALL MPE$SENDRECEIVE('~',RTASK,WTASK,EIG2)
          
          ! TODO: BREAKS IF NBX != NB(1) OR NB(2)
          CALL STATE$ISELECT(1)
          CALL STATE$SETR8A('EIG',IKPT,ISPIN,NB(1),EIG1)
          CALL STATE$SETC8A('PROJ',IKPT,ISPIN,NDIM_(1)*NB(1)*NPRO(1),PROJ1)
          CALL STATE$UNSELECT
          CALL STATE$ISELECT(2)
          CALL STATE$SETR8A('EIG',IKPT,ISPIN,NB(2),EIG2)
          CALL STATE$SETC8A('PROJ',IKPT,ISPIN,NDIM_(2)*NB(2)*NPRO(2),PROJ2)
          CALL STATE$UNSELECT

          CALL TIMING$CLOCKON('XRAY$READ_SCALARPRODUCT')
          IF(THISTASK.EQ.WTASK) THEN
            CALL TRACE$I4VAL(' CALCULATING IKPT: ',IKPT)
            DO IB2=1,NB(2)
              DO IB1=1,NB(1)
                ! NO DIM LOOP AS NDIM=1
                ! SCALARPRODUCT (SUM OVER G VECTORS)
                ! PW(I,J)=<PSI1(J)|PSI2(I)>
                ! WARNING: CHECK IF SCALARPRODUCT IS CORRECT ALSO WITH CONJG
                !          SHOULD BE THE CASE AS CALL OF ZGEMM IS DONE WITH 'C' OPTION
                ! WARNING: CHECK WILL NOT WORK IF ONLY USING REAL WAVE FUNCTIONS AT GAMMA POINT
                CALL LIB$SCALARPRODUCTC8(.FALSE.,NGG(1),1,PSIK1(:,1,IB1),1,PSIK2(:,1,IB2),PW(IB2,IB1))
              ENDDO ! END IB1
            ENDDO ! END IB2
            PW=PW*VCELL
          END IF
          CALL TIMING$CLOCKOFF('XRAY$READ_SCALARPRODUCT')
          ! MISSING: DETECTION OF OCCUPIED BANDS BASED ON FERMI ENERGY
        ENDDO ! END ISPIN
        DEALLOCATE(PW)
        DEALLOCATE(PSIK1)
        DEALLOCATE(PSIK2)
        DEALLOCATE(PROJ1)
        DEALLOCATE(PROJ2)
        DEALLOCATE(EIG1)
        DEALLOCATE(EIG2)
      ENDDO ! END IKPT
                          CALL TIMING$CLOCKOFF('XRAY$READ')
                          CALL TRACE$POP
      RETURN

      CONTAINS 
        SUBROUTINE TESTKPT!(NSIM,KEY,NGG,NDIM,TSUPER,XK,IGVEC)
        ! INTEGER(4), INTENT(IN) :: NSIM
        ! CHARACTER(8), INTENT(IN) :: KEY(NSIM)
        ! INTEGER(4), INTENT(IN) :: NGG(NSIM)
        ! INTEGER(4), INTENT(IN) :: NDIM(NSIM)
        ! LOGICAL(4), INTENT(IN) :: TSUPER(NSIM)
        ! REAL(8), INTENT(IN) :: XK(NSIM,3)
        ! INTEGER(4), INTENT(IN) :: IGVEC(NSIM,3,NGG(1))
        IMPLICIT NONE
        REAL(8),PARAMETER :: TOL=1.D-8
        IF(KEY(1).NE.KEY(2)) THEN
          CALL ERROR$MSG('KEYS NOT THE SAME IN BOTH SIMULATIONS')
          CALL ERROR$I4VAL('IKPT',IKPT)
          CALL ERROR$CHVAL('KEY1',KEY(1))
          CALL ERROR$CHVAL('KEY2',KEY(2))
          CALL ERROR$STOP('RIXS$READ')
        END IF
        IF(NGG(1).NE.NGG(2)) THEN
          CALL ERROR$MSG('NGG NOT THE SAME IN BOTH SIMULATIONS')
          CALL ERROR$I4VAL('IKPT',IKPT)
          CALL ERROR$I4VAL('NGG1',NGG(1))
          CALL ERROR$I4VAL('NGG2',NGG(2))
          CALL ERROR$STOP('RIXS$READ')
        END IF
        IF(NDIM_(1).NE.NDIM_(2)) THEN
          CALL ERROR$MSG('NDIM NOT THE SAME IN BOTH SIMULATIONS')
          CALL ERROR$I4VAL('IKPT',IKPT)
          CALL ERROR$I4VAL('NDIM1',NDIM_(1))
          CALL ERROR$I4VAL('NDIM2',NDIM_(2))
          CALL ERROR$STOP('RIXS$READ')
        END IF
        ! TODO: CHECK NDIM AGAINST PREVIOUSLY READ ONE
        IF(TSUPER(1).NEQV.TSUPER(2)) THEN
          CALL ERROR$MSG('TSUPER NOT THE SAME IN BOTH SIMULATIONS')
          CALL ERROR$I4VAL('IKPT',IKPT)
          CALL ERROR$L4VAL('TSUPER1',TSUPER(1))
          CALL ERROR$L4VAL('TSUPER2',TSUPER(2))
          CALL ERROR$STOP('RIXS$READ')
        END IF
        ! CHECK IF XK SAME IN BOTH SIMULATIONS
        IF(SUM(ABS(XK_(1,:)-XK_(2,:)))>TOL) THEN
          CALL ERROR$MSG('XK NOT THE SAME IN BOTH SIMULATIONS')
          CALL ERROR$I4VAL('IKPT',IKPT)
          CALL ERROR$R8VAL('XK1',XK(1,:))
          CALL ERROR$R8VAL('XK2',XK(2,:))
          CALL ERROR$STOP('RIXS$READ')
        END IF
        ! CHECK IF IGVEC SAME IN BOTH SIMULATIONS
        IF(ANY(IGVEC(1,:,:).NE.IGVEC(2,:,:))) THEN
          CALL ERROR$MSG('IGVEC NOT THE SAME IN BOTH SIMULATIONS')
          CALL ERROR$I4VAL('IKPT',IKPT)
          CALL ERROR$STOP('RIXS$READ')
        END IF
        END SUBROUTINE TESTKPT
      END SUBROUTINE XRAY$READ


      ! TODO: ATOMMAPPING
      ! TODO: DATACONSISTENCY
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE POLARISATION_CONVERT(K,N,POL,POLXYZ)  ! MARK: POLARISATION_CONVERT
!     **************************************************************************
!     ** POLARISATION IS GIVEN BY:                                            **
!     **   K: VECTOR OF LIGHT                                                 **
!     **   N: SURFACE NORMAL OF MATERIAL                                      **
!     **   POL: POLARISATION VECTOR WITH POL(1)=SIGMA AND POL(2)=PI POLAR.    **
!     ** RETURN POLARISATION IN XYZ COORDINATES                               **
!     **************************************************************************
      IMPLICIT NONE
      REAL(8), INTENT(IN) :: K(3)
      REAL(8), INTENT(IN) :: N(3)
      COMPLEX(8), INTENT(IN) :: POL(2)
      COMPLEX(8), INTENT(OUT) :: POLXYZ(3)
      REAL(8), PARAMETER :: TOL=1.D-8
      REAL(8) :: WORK(3)
      REAL(8) :: WORK2(3)
      REAL(8) :: SVAR
      CALL CROSS_PROD(K,N,WORK)
      SVAR=NORM2(WORK)
      IF(SVAR.LT.TOL) THEN
        CALL ERROR$MSG('K VECTOR AND SURFACE NORMAL ARE PARALLEL')
        CALL ERROR$MSG('POLARISATION VECTOR IS SET TO ARBITRARY ORTHO. VECTOR')
        CALL VEC_ORTHO(K,WORK)
        SVAR=NORM2(WORK)
      END IF
      WORK=WORK/SVAR
      CALL CROSS_PROD(WORK,K,WORK2)
      WORK2=WORK2/NORM2(WORK2)
      POLXYZ=POL(1)*WORK+POL(2)*WORK2
      SVAR=SQRT(SUM(ABS(POLXYZ)**2))
      POLXYZ=POLXYZ/SVAR
      RETURN
      END SUBROUTINE POLARISATION_CONVERT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE CROSS_PROD(A,B,C)  ! MARK: CROSS_PROD
!     **************************************************************************
!     ** CALCULATE CROSS PRODUCT OF TWO VECTORS                               **
!     **************************************************************************
      IMPLICIT NONE
      REAL(8), INTENT(IN) :: A(3)
      REAL(8), INTENT(IN) :: B(3)
      REAL(8), INTENT(OUT) :: C(3)
      C(1)=A(2)*B(3)-A(3)*B(2)
      C(2)=A(3)*B(1)-A(1)*B(3)
      C(3)=A(1)*B(2)-A(2)*B(1)
      RETURN
      END SUBROUTINE CROSS_PROD
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE VEC_ORTHO(A,B)  ! MARK: VEC_ORTHO
!     **************************************************************************
!     ** CALCULATE ORTHOGONAL VECTOR TO A                                      **
!     **************************************************************************
! TODO: UNDERSTAND
      IMPLICIT NONE
      REAL(8), INTENT(IN) :: A(3)
      REAL(8), INTENT(OUT) :: B(3)
      REAL(8) :: VECVAR(3)
      VECVAR = (/1.D0,0.D0,0.D0/)
      IF(DOT_PRODUCT(A,VECVAR).EQ.NORM2(A)) THEN
        VECVAR = (/0.D0,1.D0,0.D0/)
      END IF
      CALL CROSS_PROD(A,VECVAR,B)
      END SUBROUTINE VEC_ORTHO