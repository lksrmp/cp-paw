!........1.........2.........3.........4.........5.........6.........7.........8
      MODULE XAS_MODULE
      TYPE SETUP_TYPE
        INTEGER(4) :: GID ! GRID ID FOR RADIAL MESH
        REAL(8) :: ECORE ! CORE ENERGY
        REAL(8), ALLOCATABLE :: PSPHI(:,:) ! PSEUDO PARTIAL WAVE
        REAL(8), ALLOCATABLE :: AEPHI(:,:) ! AE PARTIAL WAVE
        INTEGER(4) :: NBATOM ! #(ATOMIC WAVE FUNCTIONS)
        INTEGER(4), ALLOCATABLE :: LATOM(:) ! (NBATOM) L QUANTUM NUMBER
        REAL(8), ALLOCATABLE :: AEPSI(:,:) ! (NR,NBATOM) AE ATOMIC WAVE FUNCTION
      END TYPE SETUP_TYPE

      TYPE STATE_TYPE
        REAL(8) :: OCCTOL=1.D-3 ! OCCUPATION > OCCTOL IS OCCUPIED
        INTEGER(4)          :: NB ! #(STATES)
        REAL(8), POINTER    :: EIG(:) ! (NB) EIGENVALUES
        REAL(8), POINTER    :: OCC(:) ! (NB) OCCUPATIONS
        INTEGER(4)          :: NOCC ! #(OCCUPIED STATES)
        COMPLEX(8), POINTER :: PROJ(:,:,:) ! (NDIM,NB,NPRO) PROJECTIONS
      END TYPE STATE_TYPE

      TYPE OVERLAP_TYPE
        COMPLEX(8), ALLOCATABLE :: PW(:,:) ! (NB2,NB1) PLANE WAVE OVERLAP
        COMPLEX(8), ALLOCATABLE :: AUG(:,:) ! (NB2,NB1) AUGMENTATION OVERLAP
        COMPLEX(8), ALLOCATABLE :: OV(:,:) ! (NB2,NB1) OVERLAP
!       IT IS CHECKED THAT NOCC1=NOCC2
        COMPLEX(8), ALLOCATABLE :: OVOCC(:,:) ! (NOCC2,NOCC1) OCCUPIED OVERLAP
        COMPLEX(8), ALLOCATABLE :: OVEMP(:,:) ! (NB2-NOCC2,NOCC1) EMPTY OVERLAP
        COMPLEX(8), ALLOCATABLE :: KMAT(:,:) ! (NB2-NOCC2,NOCC1) K MATRIX ELEMENTS
        COMPLEX(8), ALLOCATABLE :: DIPOLE(:,:) ! (3,NB2) DIPOLE MATRIX ELEMENTS
        COMPLEX(8) :: ADET ! DETERMINANT OF OCCUPIED OVERLAP
       END TYPE OVERLAP_TYPE

      TYPE SETTINGS_TYPE
        INTEGER(4) :: NSPEC ! #(SPECTRA)
        INTEGER(4) :: NAUXORB ! #(AUXORB)
        CHARACTER(256) :: ATOM ! ATOM ID WITH CORE HOLE
        INTEGER(4) :: IATOM ! ATOM INDEX WITH CORE HOLE IN SIM1 (FOR SIM2 USE ATOMMAP)
        INTEGER(4) :: NCORE ! N QUANTUM NUMBER OF CORE HOLE
        INTEGER(4) :: LCORE ! L QUANTUM NUMBER OF CORE HOLE
!       ENERGY GRID PARAMETER
        REAL(8) :: EMIN ! MINIMUM ENERGY
        REAL(8) :: EMAX ! MAXIMUM ENERGY
        REAL(8) :: DE ! ENERGY STEP SIZE
        INTEGER(4) :: NE ! #(ENERGY POINTS)
        REAL(8) :: GAMMA ! LIFETIME BROADENING FROM LORENTZIAN
      END TYPE SETTINGS_TYPE

      TYPE OUTPUT_TYPE
        LOGICAL(4) :: TOVL ! WRITE OVERLAP_TYPE%OV
        LOGICAL(4) :: TOVLPW ! WRITE OVERLAP_TYPE%PW
        LOGICAL(4) :: TOVLAUG ! WRITE OVERLAP_TYPE%AUG
        LOGICAL(4) :: TOVLOCC ! WRITE OVERLAP_TYPE%OVOCC
        LOGICAL(4) :: TOVLEMP ! WRITE OVERLAP_TYPE%OVEMP
        LOGICAL(4) :: TDIPOLE ! WRITE OVERLAP_TYPE%DIPOLE
        LOGICAL(4) :: TKMAT ! WRITE OVERLAP_TYPE%KMAT
        LOGICAL(4) :: TADET ! WRITE OVERLAP_TYPE%ADET
        LOGICAL(4) :: TRAW  ! WRITE SPECTRUM_TYPE%IRAW
        LOGICAL(4) :: TBINARY ! WRITE BINARY FILES
        LOGICAL(4) :: TKPTSPIN ! WRITE K-POINT AND SPIN SPECTRA SEPARATELY
      END TYPE OUTPUT_TYPE

      TYPE SPECTRUM_TYPE
        CHARACTER(256) :: FILE ! FILENAME
        REAL(8) :: NORMAL(3) ! NORMAL VECTOR OF COORDINATES
        REAL(8) :: KDIR(3) ! DIRECTION OF K-VECTOR
        COMPLEX(8) :: POL(2) ! POLARIZATION VECTOR
        COMPLEX(8) :: POLXYZ(3) ! POLARIZATION VECTOR IN CARTESIAN COORDINATES
        LOGICAL(4) :: TPOLXYZ ! CHECK IF POLXYZ IS IN INPUT
        REAL(8), ALLOCATABLE :: E(:) ! (NE) ENERGY GRID
        REAL(8), ALLOCATABLE :: I(:,:,:) ! (NKPT,NSPIN,NE) CROSS SECTION
        REAL(8), ALLOCATABLE :: ERAW(:,:,:)  ! (NKPT,NSPIN,NB2-NOCC)
        REAL(8), ALLOCATABLE :: IRAW(:,:,:)  ! (NKPT,NSPIN,NB2-NOCC)
!       LAST INDEX 1=TOTAL 2=SPIN UP 3=SPIN DOWN
        REAL(8), ALLOCATABLE :: ICONV(:,:,:)  ! (NKPT,NE,3) CONVOLUTED CROSS SECTION
      END TYPE SPECTRUM_TYPE

!     GENERAL SETTINGS OF A SIMULATION 
      TYPE SIMULATION_TYPE
        CHARACTER(11) :: ID ! SIMULATION IDENTIFIER (GROUNDSTATE,EXCITESTATE)
        CHARACTER(256) :: FILE ! FILENAME
        INTEGER(4) :: NAT ! #(ATOMS)
        INTEGER(4) :: NSP ! #(SETUPS)
        INTEGER(4) :: NKPT ! #(KPOINTS)
        INTEGER(4) :: NSPIN ! #(SPINS)
        INTEGER(4) :: NDIM ! #(DIMENSIONS)
        INTEGER(4) :: NPRO ! #(PROJECTIONS)
        INTEGER(4) :: LNXX
        CHARACTER(6) :: FLAG
        INTEGER(4), ALLOCATABLE :: LMNX(:) ! (NSP)
        INTEGER(4), ALLOCATABLE :: LNX(:) ! (NSP)
        INTEGER(4), ALLOCATABLE :: LOX(:,:) ! (LNXX,NSP)
        INTEGER(4), ALLOCATABLE :: MAP(:,:) ! (NAT,LNXX) INDEX-1 OF ATOM AND LN
        LOGICAL(4) :: TINV ! INVERSION SYMMETRY
        INTEGER(4) :: NKDIV(3) ! K-POINT DIVISIONS
        INTEGER(4) :: ISHIFT(3) ! K-POINT SHIFTS
        REAL(8) :: RNTOT
        REAL(8) :: NEL
        REAL(8) :: ETOT  ! TOTAL ENERGY
        REAL(8) :: EDFT  ! TOTAL DFT ENERGY
        REAL(8) :: ECORE  ! TOTAL CORE ENERGY
        INTEGER(4) :: SPACEGROUP
        LOGICAL(4) :: TSHIFT
        REAL(8) :: RBAS(3,3) ! BASIS VECTORS
        REAL(8), ALLOCATABLE :: R(:,:) ! (3,NAT) ATOMIC POSITIONS
        CHARACTER(16), ALLOCATABLE :: ATOMID(:) ! (NAT) ATOM IDENTIFIERS
        INTEGER(4), ALLOCATABLE :: ISPECIES(:) ! (NAT) SPECIES INDEX
        REAL(8), ALLOCATABLE :: XK(:,:) ! (3,NKPT) K-POINTS IN REL. COORD.
        REAL(8), ALLOCATABLE :: WKPT(:) ! (NKPT) K-POINT WEIGHTS
        COMPLEX(8), ALLOCATABLE :: DENMAT(:,:,:,:) ! (LMNXX,LMNXX,NDIM,NAT) DENSITY MATRIX
        TYPE(SETUP_TYPE), ALLOCATABLE :: SETUP(:) ! (NSP) ARRAY OF SETUPS
        TYPE(STATE_TYPE), ALLOCATABLE :: STATEARR(:,:) ! (NKPT,NSPIN) ARRAY OF STATES
        TYPE(STATE_TYPE), POINTER :: STATE ! CURRENT STATE
      END TYPE SIMULATION_TYPE

      TYPE AUXORB_TYPE
        CHARACTER(256) :: FILE  ! FILENAME
        INTEGER(4) :: BAND  ! BAND INDEX OF EMPTY FINAL ORBITAL
        INTEGER(4) :: S  ! SPIN INDEX (DEFAULT 1)
        INTEGER(4) :: K  ! K-POINT INDEX (DEFAULT 1)
        ! INTEGER(4) :: NORB  ! MAXIMUM NUMBER OF CONTRIBUTING ORBITALS
      END TYPE AUXORB_TYPE

! WARNING: CHANGING THIS NUMBER MIGHT BREAK SOME CODE
!     INDEX 1 IS GROUNDSTATE AND 2 EXCITED STATE
      INTEGER(4), PARAMETER :: NSIM=2  ! #(SIMULATIONS)
      LOGICAL,SAVE :: SELECTED=.FALSE.
      TYPE(SIMULATION_TYPE), TARGET :: SIM(NSIM) ! (NSIM) ARRAY OF SIMULATIONS
      TYPE(SIMULATION_TYPE), POINTER :: THIS ! CURRENT SIMULATION

      TYPE(OVERLAP_TYPE), ALLOCATABLE, TARGET :: OVERLAPARR(:,:) ! (NKPT,NSPIN)
      TYPE(OVERLAP_TYPE), POINTER :: OVERLAP ! CURRENT OVERLAP

      TYPE(SETTINGS_TYPE) :: SETTINGS

      TYPE(SPECTRUM_TYPE), ALLOCATABLE, TARGET :: SPECTRUMARR(:) ! (NSPEC)
      TYPE(SPECTRUM_TYPE), POINTER :: SPECTRUM ! CURRENT SPECTRUM

      TYPE(AUXORB_TYPE), ALLOCATABLE, TARGET :: AUXORBARR(:) ! (NAUXORB)
      TYPE(AUXORB_TYPE), POINTER :: AUXORB ! CURRENT AUXORB

      REAL(8), ALLOCATABLE :: S(:,:,:) ! (NAT,LNXX1,LNXX2) ATOMIC OVERLAP MATRIX
      INTEGER(4), ALLOCATABLE :: ATOMMAP(:) ! (NAT) ATOM INDEX MAP SIM1->SIM2

      TYPE(OUTPUT_TYPE) :: OUTPUT

      LOGICAL(4) :: TSIM=.FALSE.
      LOGICAL(4) :: TOVERLAP=.FALSE.
      LOGICAL(4) :: TSPECTRUM=.FALSE.
      LOGICAL(4) :: TSETTINGS=.FALSE.
      LOGICAL(4) :: TRSTRT=.FALSE.

      INTEGER(4), ALLOCATABLE :: KMAP(:) ! (NKPT) K-POINT RESPONSIBILITY OF TASKS
      INTEGER(4) :: NKPTG  ! #(KPOINTS TOTAL)
      INTEGER(4) :: RTASK  ! TASK RESPONSIBLE FOR READ/WRITE
      END MODULE XAS_MODULE

      MODULE XASCNTL_MODULE  ! MARK: XASCNTL_MODULE
        USE LINKEDLIST_MODULE, ONLY: LL_TYPE
        TYPE(LL_TYPE) :: LL_CNTL
        SAVE
      END MODULE XASCNTL_MODULE

      ! MODULE XASSTP_MODULE  ! MARK: XASSTP_MODULE
      !   USE XASPDOS_MODULE, ONLY: NPD
      !   USE LINKEDLIST_MODULE, ONLY: LL_TYPE
      !   TYPE STP_TYPE
      !     INTEGER(4) :: NFIL=0
      !     TYPE(LL_TYPE) :: LL
      !     INTEGER(4) :: GID=0
      !     INTEGER(4) :: LNX=0
      !     INTEGER(4) :: NR=0
      !     INTEGER(4) :: NB ! #(STATES IN AE ATOMIC CALCULATION)
      !     INTEGER(4) :: NC ! #(CORE STATES)
      !   END TYPE STP_TYPE
      !   TYPE(STP_TYPE) :: STP(NPD)
      ! END MODULE XASSTP_MODULE

      PROGRAM PAW_XAS  ! MARK: PAW_XAS
      ! USE XASPDOS_MODULE, ONLY: NPD,PD
      USE XASCNTL_MODULE, ONLY: LL_CNTL
      USE XAS_MODULE, ONLY: TRSTRT
      USE LINKEDLIST_MODULE
      USE CLOCK_MODULE
      IMPLICIT NONE
      INTEGER(4) :: NFIL
      CHARACTER(32) :: DATIME
      INTEGER(4) :: IPD
      INTEGER(4) :: I
      INTEGER(4) :: NUM_ARGS
      INTEGER(4) :: NTASKS
      INTEGER(4) :: THISTASK
!     **************************************************************************
      CALL MPE$INIT
                          CALL TRACE$PUSH('MAIN')
! TODO: COMMAND LINE HANDLING AND HELP MESSAGE
                          CALL TIMING$START
      CALL MPE$QUERY('~',NTASKS,THISTASK)
!     INITIALIZE FILES
      CALL INITIALIZEFILEHANDLER
      CALL FILEHANDLER$UNIT('PROT',NFIL)
      IF(THISTASK.EQ.1) THEN
        CALL CPPAW_WRITEVERSION(NFIL)
        CALL CLOCK$NOW(DATIME)        
        WRITE(NFIL,FMT='(80("="))')
        WRITE(NFIL,FMT='(80("="),T15,"  PROGRAM STARTED ",A32,"  ")')DATIME
        WRITE(NFIL,FMT='(80("="))')
        WRITE(NFIL,FMT='(A,I3)')'NUMBER OF TASKS: ',NTASKS
      END IF
!     ==========================================================================
!     == READ XCNTL FILE                                                      ==
!     ==========================================================================
                          CALL TIMING$CLOCKON('XCNTL')
      CALL FILEHANDLER$UNIT('XCNTL',NFIL)
      CALL XASCNTL$READ(NFIL)
!     READ !RSTRT BLOCK
      CALL XASCNTL$RESTART
!     READ FILES FOR DFT CALCULATION DATA
      CALL XAS$SELECT('GROUNDSTATE')
      CALL XASCNTL$FILES('GROUNDSTATE')
      CALL XAS$UNSELECT
      CALL XAS$SELECT('EXCITESTATE')
      CALL XASCNTL$FILES('EXCITESTATE')
      CALL XAS$UNSELECT
!     READ SETTINGS FOR SPECTRA
      CALL XASCNTL$SPECTRUM
!     CALCULATE POLARISATION IN CARTESIAN COORDINATES FROM NORMAL, K, AND POL
      CALL XAS$POLARISATION
!     READ GRID SETTINGS
      CALL XASCNTL$GRID
!     READ OUTPUT SELECTION
      CALL XASCNTL$OUTPUT
!     READ AUXILIARY ORBITAL ANALYSIS SELECTION
      CALL XASCNTL$AUXORB
                          CALL TIMING$CLOCKOFF('XCNTL')

      IF(TRSTRT) THEN
        CALL XAS$READRESTART
      ELSE
!       READ DFT CALCULATION DATA
        CALL XAS$READ

        CALL XAS$DENMAT
!       REPORT DFT CALCULATION DATA
        CALL XAS$SELECT('GROUNDSTATE')
        CALL XAS$REPORTSIMULATION
        CALL XAS$UNSELECT
        CALL XAS$SELECT('EXCITESTATE')
        CALL XAS$REPORTSIMULATION
        CALL XAS$UNSELECT
        CALL DATACONSISTENCY
      END IF

!     READ SETTINGS FOR CORE HOLE
      CALL XASCNTL$COREHOLE

      CALL XAS$OVERLAP

      CALL XAS$DIPOLEMATRIX

      CALL XAS$ADET
      CALL XAS$KMAT

      CALL XAS$CROSSSECTION

      CALL XAS$OUTPUTGATHER

      CALL XAS$SPINCONV

      CALL XAS$OUTPUT

      CALL XAS$AUXORB

      CALL XAS$REPORTSIMULATION

      CALL XAS$REPORTSETTINGS

      CALL XAS$WRITEDENMAT

      CALL XAS$WRITERESTART

!     REPORT UNUSED LINKEDLISTS
      CALL FILEHANDLER$UNIT('PROT',NFIL)
      CALL LINKEDLIST$SELECT(LL_CNTL,'~')
      IF(THISTASK.EQ.1) THEN
        CALL LINKEDLIST$REPORT_UNUSED(LL_CNTL,NFIL)
      END IF


     
      ! CALL XAS$ISELECT(1)
      ! OPEN(UNIT=NFIL,FILE='gs_1_psphi.dat',STATUS='REPLACE')
      ! CALL XAS$WRITEPHI(NFIL,1,'PSPHI')
      ! CLOSE(NFIL)
      ! OPEN(UNIT=NFIL,FILE='gs_2_psphi.dat',STATUS='REPLACE')
      ! CALL XAS$WRITEPHI(NFIL,2,'PSPHI')
      ! CLOSE(NFIL)
      ! OPEN(UNIT=NFIL,FILE='gs_1_aephi.dat',STATUS='REPLACE')
      ! CALL XAS$WRITEPHI(NFIL,1,'AEPHI')
      ! CLOSE(NFIL)
      ! OPEN(UNIT=NFIL,FILE='gs_2_aephi.dat',STATUS='REPLACE')
      ! CALL XAS$WRITEPHI(NFIL,2,'AEPHI')
      ! CLOSE(NFIL)
      ! CALL XAS$UNSELECT

      ! CALL XAS$ISELECT(2)
      ! OPEN(UNIT=NFIL,FILE='exc_1_psphi.dat',STATUS='REPLACE')
      ! CALL XAS$WRITEPHI(NFIL,1,'PSPHI')
      ! CLOSE(NFIL)
      ! OPEN(UNIT=NFIL,FILE='exc_2_psphi.dat',STATUS='REPLACE')
      ! CALL XAS$WRITEPHI(NFIL,2,'PSPHI')
      ! CLOSE(NFIL)
      ! OPEN(UNIT=NFIL,FILE='exc_1_aephi.dat',STATUS='REPLACE')
      ! CALL XAS$WRITEPHI(NFIL,1,'AEPHI')
      ! CLOSE(NFIL)
      ! OPEN(UNIT=NFIL,FILE='exc_2_aephi.dat',STATUS='REPLACE')
      ! CALL XAS$WRITEPHI(NFIL,2,'AEPHI')
      ! CLOSE(NFIL)
      ! CALL XAS$UNSELECT
                          CALL TIMING$PRINT('~',NFIL)
      CALL MPE$CLOCKREPORT(NFIL)
      CALL USAGE$REPORT(NFIL)

      IF(THISTASK.EQ.1) THEN
        CALL CLOCK$NOW(DATIME)        
        WRITE(NFIL,FMT='(80("="))')
        WRITE(NFIL,FMT='(80("="),T15,"  PROGRAM FINISHED ",A32,"  ")')DATIME
        WRITE(NFIL,FMT='(80("="))')
      END IF
                          CALL TRACE$POP
      CALL ERROR$NORMALSTOP
      STOP
      END PROGRAM PAW_XAS

      SUBROUTINE XAS$ISELECT(I)  ! MARK: XAS$ISELECT
!     **************************************************************************
!     **                                                                      **
!     **************************************************************************
      USE XAS_MODULE, ONLY: NSIM,SELECTED,THIS,SIM
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: I
!     **************************************************************************
      IF(I.GT.NSIM.OR.I.LT.0) THEN
        CALL ERROR$MSG('I NOT IN RANGE')
        CALL ERROR$I4VAL('I',I)
        CALL ERROR$I4VAL('NSIM',NSIM)
        CALL ERROR$STOP('XAS$ISELECT')
      END IF
      IF(I.EQ.0) THEN
        IF(.NOT.SELECTED) THEN
          CALL ERROR$MSG('CANNOT UNSELECT A SIMULATION THAT IS NOT SELECTED')
          CALL ERROR$STOP('XAS$ISELECT')
        END IF
        SELECTED=.FALSE.
        NULLIFY(THIS)
      ELSE
        IF(SELECTED) THEN
          CALL ERROR$MSG('ANOTHER SIMULATION IS ALREADY SELECTED')
          CALL ERROR$STOP('XAS$ISELECT')
        END IF
        THIS=>SIM(I)
        SELECTED=.TRUE.
      END IF
      RETURN
      END SUBROUTINE XAS$ISELECT


      SUBROUTINE XAS$SELECT(ID)  ! MARK: XAS$SELECT
!     **************************************************************************
!     **                                                                      **
!     **************************************************************************
      USE XAS_MODULE, ONLY: SELECTED,THIS,SIM
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
!     **************************************************************************
      IF(SELECTED) THEN
        CALL ERROR$MSG('ANOTHER SIMULATION IS ALREADY SELECTED')
        CALL ERROR$CHVAL('SELECTED ID',THIS%ID)
        CALL ERROR$CHVAL('ID',ID)
        CALL ERROR$STOP('XAS$SELECT')
      END IF
      SELECTED=.TRUE.
      IF(ID.EQ.'GROUNDSTATE') THEN
        THIS=>SIM(1)
      ELSE IF(ID.EQ.'EXCITESTATE') THEN
        THIS=>SIM(2)
      ELSE
        CALL ERROR$MSG('ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID',ID)
        CALL ERROR$MSG('ID MUST BE GROUNDSTATE OR EXCITESTATE')
        CALL ERROR$STOP('XAS$SELECT')
      END IF
      RETURN
      END SUBROUTINE XAS$SELECT


      SUBROUTINE XAS$UNSELECT()
!     **************************************************************************
!     **                                                                      **
!     **************************************************************************
      USE XAS_MODULE, ONLY: SELECTED,THIS
      IMPLICIT NONE
!     **************************************************************************
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('CANNOT UNSELECT A SIMULATION THAT IS NOT SELECTED')
        CALL ERROR$STOP('XAS$UNSELECT')
      END IF
      SELECTED=.FALSE.
      NULLIFY(THIS)
      RETURN
      END SUBROUTINE XAS$UNSELECT
! !
! !     ..................................................................
!       SUBROUTINE XAS$READPDOS(NFIL,IPD)  ! MARK: XAS$READPDOS
! !     ******************************************************************
! !     ** READS PDOS FILE FROM NFIL INTO THE XAS MODULE                **
! !     ** INPUT: NFIL - UNIT NUMBER OF PDOS FILE                       **
! !     **        IPD  - INDEX OF PDOS TO BE READ                       **
! !     ** ADAPTED FROM PDOS$READ                                       **
! !     ******************************************************************
!       USE XASPDOS_MODULE, ONLY: PD,NPD
!       USE LINKEDLIST_MODULE
!       IMPLICIT NONE
!       INTEGER(4),INTENT(IN)  :: NFIL
!       INTEGER(4),INTENT(IN)  :: IPD
!       INTEGER(4)             :: ISP,IKPT,ISPIN,IB
!       INTEGER(4)             :: LNX1,NB
!       INTEGER(4)             :: IOS
!       CHARACTER(82)          :: IOSTATMSG
!       LOGICAL(4)             :: TCHK
!       REAL(8)                :: OCCSUM
!       INTEGER(4)             :: ILOGICAL

!       INTEGER(4)             :: NAT,NSP,NKPT,NSPIN,NDIM,NPRO,LNXX,SPACEGROUP
!       LOGICAL(4)             :: TINV,TSHIFT
!       INTEGER(4)                               :: NKDIV(3)
!       INTEGER(4)                               :: ISHIFT(3)
!       REAL(8)                                  :: RNTOT,NEL
!       REAL(8)                                  :: RBAS(3,3)
!       CHARACTER(6)           :: FLAG
! !     ******************************************************************
!                              CALL TRACE$PUSH('XAS$PDOSREAD')
! !     CHECK SELECTION OF PDOS INDEX
!       IF(IPD.LT.1.OR.IPD.GT.NPD)THEN
!         CALL ERROR$MSG('PDOS INDEX NOT IN RANGE')
!         CALL ERROR$I4VAL('IPD',IPD)
!         CALL ERROR$I4VAL('NPD',NPD)
!         CALL ERROR$STOP('XAS$READPDOS')
!       END IF
! !
! !     ==================================================================
! !     == GENERAL QUANTITIES                                           ==
! !     ==================================================================
!       TCHK=.FALSE.
!       READ(NFIL,ERR=100)NAT,NSP,NKPT,NSPIN,NDIM,NPRO,LNXX,FLAG
!       TCHK=.TRUE.
!  100  CONTINUE
!       IF(.NOT.TCHK) THEN
!         PRINT*,'WARNING: NO OCCUPATIONS PRESENT IN PDOS FILE'
!         PRINT*,'            OCCUPATIONS WILL BE SET TO 0'
!         FLAG='LEGACY'
!         REWIND(NFIL)
!         READ(NFIL)NAT,NSP,NKPT,NSPIN,NDIM,NPRO,LNXX
!       END IF
      
!       ALLOCATE(PD(IPD)%LNX(NSP))
!       ALLOCATE(PD(IPD)%LOX(LNXX,NSP))
!       ALLOCATE(PD(IPD)%ISPECIES(NAT))
!       READ(NFIL)PD(IPD)%LNX(:),PD(IPD)%LOX(:,:),PD(IPD)%ISPECIES(:)
      
!       IF(FLAG.EQ.'181213')THEN
! !         == GFORTRAN LOGICAL REPRESENTATION DEFINED WITH TRUE=1, FALSE=0     ==
! !         https://gcc.gnu.org/onlinedocs/gfortran/compiler-characteristics/
! !         internal-representation-of-logical-variables.html
! !         == IFORT LOGICAL REPRESENTATION DEFINED WITH VALUE OF LAST BIT      ==
! !         https://www.intel.com/content/www/us/en/docs/fortran-compiler/
! !         developer-guide-reference/2024-2/logical-data-representations.html
! !         == BOTH SHARE MEANING OF LAST BIT 1=TRUE, 0=FALSE                   ==
! !         == ENSURES BACKWARDS COMPATIBILITY WITH OLD PDOS FILES              ==
!         READ(NFIL)NKDIV(:),ISHIFT(:),RNTOT,NEL,ILOGICAL
!         TINV=BTEST(ILOGICAL,0)
!         READ(NFIL)SPACEGROUP,ILOGICAL
!         TSHIFT=BTEST(ILOGICAL,0)
!       END IF
! !
! !     ==================================================================
! !     == ATOMIC STRUCTURE                                             ==
! !     ==================================================================
!       ALLOCATE(PD(IPD)%R(3,NAT))
!       ALLOCATE(PD(IPD)%ATOMID(NAT))
!       READ(NFIL)RBAS(:,:),PD(IPD)%R(:,:),PD(IPD)%ATOMID(:)
! !
! !     ==================================================================
! !     == ELEMENT SPECIFIC QUANTITIES                                  ==
! !     ==================================================================
!       ALLOCATE(PD(IPD)%IZ(NSP))
!       ALLOCATE(PD(IPD)%RAD(NSP)); PD(IPD)%RAD=0.D0
!       ALLOCATE(PD(IPD)%PHIOFR(LNXX,NSP)); PD(IPD)%PHIOFR=0.D0
!       ALLOCATE(PD(IPD)%DPHIDR(LNXX,NSP)); PD(IPD)%DPHIDR=0.D0
!       ALLOCATE(PD(IPD)%OV(LNXX,LNXX,NSP)); PD(IPD)%OV=0.D0
!       DO ISP=1,NSP
!         LNX1=PD(IPD)%LNX(ISP)
!         READ(NFIL)PD(IPD)%IZ(ISP),PD(IPD)%RAD(ISP),PD(IPD)%PHIOFR(1:LNX1,ISP) &
!      &            ,PD(IPD)%DPHIDR(1:LNX1,ISP),PD(IPD)%OV(1:LNX1,1:LNX1,ISP)
!       ENDDO
! !
! !     ==================================================================
! !     ==  NOW READ PROJECTIONS                                       ==
! !     ==================================================================
!       OCCSUM=0.0D0
!       ALLOCATE(PD(IPD)%XK(3,NKPT))
!       ALLOCATE(PD(IPD)%WKPT(NKPT))
!       ALLOCATE(PD(IPD)%STATEARR(NKPT,NSPIN))
!       DO IKPT=1,NKPT
!         DO ISPIN=1,NSPIN
!           PD(IPD)%STATE=>PD(IPD)%STATEARR(IKPT,ISPIN)
!           READ(NFIL,ERR=9998,END=9998)PD(IPD)%XK(:,IKPT),NB,PD(IPD)%WKPT(IKPT)
!           PD(IPD)%STATE%NB=NB
!           ALLOCATE(PD(IPD)%STATE%EIG(NB))
!           ALLOCATE(PD(IPD)%STATE%VEC(NDIM,NPRO,NB))
!           ALLOCATE(PD(IPD)%STATE%OCC(NB))
!           DO IB=1,NB
!             IF(FLAG.EQ.'LEGACY') THEN
!               PD(IPD)%STATE%OCC(:)=0.D0
!               READ(NFIL,ERR=9999,IOSTAT=IOS)PD(IPD)%STATE%EIG(IB),PD(IPD)%STATE%VEC(:,:,IB)
!             ELSE
!               READ(NFIL,ERR=9999,IOSTAT=IOS)PD(IPD)%STATE%EIG(IB) &
!     &                          ,PD(IPD)%STATE%OCC(IB),PD(IPD)%STATE%VEC(:,:,IB)
!               OCCSUM=OCCSUM+PD(IPD)%STATE%OCC(IB)
!             END IF
!           ENDDO
!         ENDDO
!       ENDDO
! PRINT*,"OCCSUM",OCCSUM
! !     SET FIXED SIZE VARIABLES IN PDOS STRUCTURE
!       PD(IPD)%FLAG=FLAG
!       PD(IPD)%NAT=NAT
!       PD(IPD)%NSP=NSP
!       PD(IPD)%NKPT=NKPT
!       PD(IPD)%NSPIN=NSPIN
!       PD(IPD)%NDIM=NDIM
!       PD(IPD)%NPRO=NPRO
!       PD(IPD)%NKDIV(:)=NKDIV(:)
!       PD(IPD)%ISHIFT(:)=ISHIFT(:)
!       PD(IPD)%RNTOT=RNTOT
!       PD(IPD)%NEL=NEL
!       PD(IPD)%TINV=TINV
!       PD(IPD)%LNXX=LNXX
!       PD(IPD)%RBAS(:,:)=RBAS(:,:)
!       PD(IPD)%SPACEGROUP=SPACEGROUP
!       PD(IPD)%TSHIFT=TSHIFT
!                              CALL TRACE$POP
!       RETURN
!  9999 CONTINUE
!       CALL FILEHANDLER$IOSTATMESSAGE(IOS,IOSTATMSG)
!       CALL ERROR$MSG('ERROR READING PDOS FILE')
!       CALL ERROR$I4VAL('IOS',IOS)
!       CALL ERROR$CHVAL('IOSTATMSG',IOSTATMSG)
!       CALL ERROR$I4VAL('IB',IB)
!       CALL ERROR$I4VAL('IKPT',IKPT)
!       CALL ERROR$I4VAL('ISPIN',ISPIN)
!       CALL ERROR$I4VAL('NPRO',NPRO)
!       CALL ERROR$STOP('XAS$READPDOS')
!       STOP
!  9998 CONTINUE
!       CALL ERROR$MSG('ERROR READING PDOS FILE')
!       CALL ERROR$MSG('OLD VERSION: VARIABLE WKPT IS NOT PRESENT')
!       CALL ERROR$MSG('PRODUCE NEW PDOS FILE')
!       CALL ERROR$STOP('XAS$READPDOS')
!       STOP
!       END SUBROUTINE XAS$READPDOS
!
!     ..................................................................
      SUBROUTINE DATACONSISTENCY  ! MARK: DATACONSISTENCY
!     **************************************************************************
!     ** CHECKS CONSISTENCY OF PDOS DATA                                      **
! TODO: IMPLEMENT THIS SUBROUTINE FURTHER, TEST THE CHECKS, ADD ADDITIONAL CHECKS
! TODO: COMBINE WITH TEST SUBROUTINE IN XAS$READ
!     **************************************************************************
      USE XAS_MODULE, ONLY: THIS,SIMULATION_TYPE,ATOMMAP
      IMPLICIT NONE
      TYPE(SIMULATION_TYPE), POINTER :: THIS1,THIS2
      INTEGER(4) :: IAT1,IAT2
      REAL(8),PARAMETER :: TOL=1.D-8
!     **************************************************************************
                          CALL TRACE$PUSH('DATACONSISTENCY')
      CALL XAS$SELECT('GROUNDSTATE')
      THIS1=>THIS
      CALL XAS$UNSELECT
      CALL XAS$SELECT('EXCITESTATE')
      THIS2=>THIS
      CALL XAS$UNSELECT
      
      IF(THIS1%NAT.NE.THIS2%NAT)THEN
        CALL ERROR$MSG('NAT INCONSISTENT BETWEEN SIMULATIONS')
        CALL ERROR$I4VAL('GROUNDSTATE%NAT',THIS1%NAT)
        CALL ERROR$I4VAL('EXCITESTATE%NAT',THIS2%NAT)
        CALL ERROR$STOP('DATACONSISTENCY')
      END IF
      IF(THIS1%NKPT.NE.THIS2%NKPT)THEN
        CALL ERROR$MSG('NKPT INCONSISTENT BETWEEN SIMULATIONS')
        CALL ERROR$I4VAL('GROUNDSTATE%NKPT',THIS1%NKPT)
        CALL ERROR$I4VAL('EXCITESTATE%NKPT',THIS2%NKPT)
        CALL ERROR$STOP('DATACONSISTENCY')
      END IF
      IF(THIS1%NSPIN.NE.THIS2%NSPIN)THEN
        CALL ERROR$MSG('NSPIN INCONSISTENT BETWEEN SIMULATIONS')
        CALL ERROR$I4VAL('GROUNDSTATE%NSPIN',THIS1%NSPIN)
        CALL ERROR$I4VAL('EXCITESTATE%NSPIN',THIS2%NSPIN)
        CALL ERROR$STOP('DATACONSISTENCY')
      END IF
      IF(THIS1%NDIM.NE.1.OR.THIS2%NDIM.NE.1)THEN
        CALL ERROR$MSG('ONLY IMPLEMENTED FOR NDIM=1')
        CALL ERROR$I4VAL('GROUNDSTATE%NDIM',THIS1%NDIM)
        CALL ERROR$I4VAL('EXCITESTATE%NDIM',THIS2%NDIM)
        CALL ERROR$STOP('DATACONSISTENCY')
      END IF
! TODO: CHECK IF NECESARRY
      IF(THIS1%TINV.NEQV.THIS2%TINV)THEN
        CALL ERROR$MSG('TINV INCONSISTENT BETWEEN SIMULATIONS')
        CALL ERROR$L4VAL('GROUNDSTATE%TINV',THIS1%TINV)
        CALL ERROR$L4VAL('EXCITESTATE%TINV',THIS2%TINV)
        CALL ERROR$STOP('DATACONSISTENCY')
      END IF
      IF(ANY(ABS(THIS1%NKDIV-THIS2%NKDIV).NE.0))THEN
        CALL ERROR$MSG('NKDIV INCONSISTENT BETWEEN SIMULATIONS')
        CALL ERROR$STOP('DATACONSISTENCY')
      END IF
      IF(ANY(ABS(THIS1%ISHIFT-THIS2%ISHIFT).NE.0))THEN
        CALL ERROR$MSG('ISHIFT INCONSISTENT BETWEEN SIMULATIONS')
        CALL ERROR$STOP('DATACONSISTENCY')
      END IF
      IF(THIS1%TSHIFT.NEQV.THIS2%TSHIFT)THEN
        CALL ERROR$MSG('TSHIFT INCONSISTENT BETWEEN SIMULATIONS')
        CALL ERROR$L4VAL('GROUNDSTATE%TSHIFT',THIS1%TSHIFT)
        CALL ERROR$L4VAL('EXCITESTATE%TSHIFT',THIS2%TSHIFT)
        CALL ERROR$STOP('DATACONSISTENCY')
      END IF
      IF(SUM(ABS(THIS1%RBAS-THIS2%RBAS)).GT.TOL) THEN
        CALL ERROR$MSG('RBAS INCONSISTENT BETWEEN SIMULATIONS')
        CALL ERROR$STOP('DATACONSISTENCY')
      END IF
      DO IAT1=1,THIS1%NAT
        IAT2=ATOMMAP(IAT1)
        IF(SUM(ABS(THIS1%R(:,IAT1)-THIS2%R(:,IAT2))).GT.TOL) THEN
          CALL ERROR$MSG('ATOMIC POSITIONS INCONSISTENT BETWEEN SIMULATIONS')
          CALL ERROR$I4VAL('IAT1',IAT1)
          CALL ERROR$I4VAL('IAT2',IAT2)
          CALL ERROR$CHVAL('ATOMID1',THIS1%ATOMID(IAT1))
          CALL ERROR$R8VAL('R1X',THIS1%R(1,IAT1))
          CALL ERROR$R8VAL('R1Y',THIS1%R(2,IAT1))
          CALL ERROR$R8VAL('R1Z',THIS1%R(3,IAT1))
          CALL ERROR$R8VAL('R2X',THIS2%R(1,IAT2))
          CALL ERROR$R8VAL('R2Y',THIS2%R(2,IAT2))
          CALL ERROR$R8VAL('R2Z',THIS2%R(3,IAT2))
          CALL ERROR$STOP('DATACONSISTENCY')
        END IF
      ENDDO
! TODO: CHECK FOR XK
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE DATACONSISTENCY

!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XASCNTL$READ(NFIL)  ! MARK: XASCNTL$READ
!     **************************************************************************
!     **                                                                      **
!     **************************************************************************
      USE XASCNTL_MODULE, ONLY: LL_CNTL
      USE LINKEDLIST_MODULE
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: NFIL
!     **************************************************************************
                          CALL TRACE$PUSH('XASCNTL$READ')
      CALL LINKEDLIST$NEW(LL_CNTL)
      CALL LINKEDLIST$READ(LL_CNTL,NFIL,'~')
      CALL LINKEDLIST$SELECT(LL_CNTL,'~')
      CALL LINKEDLIST$MARK(LL_CNTL,1)
                          CALL TRACE$POP
      END SUBROUTINE XASCNTL$READ
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XASCNTL$FILES(ID)  ! MARK: XASCNTL$FILES
!     **************************************************************************
!     **                                                                      **
!     **************************************************************************
      USE XASCNTL_MODULE, ONLY: LL_CNTL
      USE XAS_MODULE, ONLY: THIS,SELECTED,TRSTRT
      USE LINKEDLIST_MODULE
      IMPLICIT NONE
      CHARACTER(11), INTENT(IN) :: ID ! GROUNDSTATE OR EXCITESTATE
      LOGICAL(4) :: TCHK
      INTEGER(4) :: NFIL
      CHARACTER(256) :: FILENAME
!     **************************************************************************
                          CALL TRACE$PUSH('XASCNTL$FILES')
!     CHECK IF FLAG IS RECOGNIZED
      IF(ID.NE.'GROUNDSTATE'.AND.ID.NE.'EXCITESTATE') THEN
        CALL ERROR$MSG('ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID',ID)
        CALL ERROR$MSG('ID MUST BE GROUNDSTATE OR EXCITESTATE OR RSTRT')
        CALL ERROR$STOP('XASCNTL$FILES')
      END IF
!     CHECK IF A SIMULATION IS SELECTED
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SIMULATION SELECTED')
        CALL ERROR$STOP('XASCNTL$FILES')
      END IF
      CALL LINKEDLIST$SELECT(LL_CNTL,'~')
      CALL LINKEDLIST$SELECT(LL_CNTL,'XCNTL')
      CALL LINKEDLIST$EXISTL(LL_CNTL,ID,1,TCHK)
      IF(TRSTRT.AND.TCHK) THEN
        CALL ERROR$MSG('!RSTRT NOT COMPATIBLE WITH !GROUNDSTATE AND !EXCITESTATE')
        CALL ERROR$STOP('XASCNTL$FILES')
      END IF
      IF(.NOT.TRSTRT.AND..NOT.TCHK) THEN
        CALL ERROR$MSG('!'//ID//' NOT FOUND')
        CALL ERROR$MSG('EITHER !GROUNDSTATE AND !EXCITESTATE, OR !RSTRT MUST BE DEFINE')
        CALL ERROR$STOP('XASCNTL$FILES')
      END IF
      IF(TRSTRT.AND..NOT.TCHK) THEN
                          CALL TRACE$POP
        RETURN
      END IF
      CALL LINKEDLIST$SELECT(LL_CNTL,ID)
      CALL LINKEDLIST$EXISTD(LL_CNTL,'FILE',1,TCHK)
      IF(.NOT.TCHK) THEN
        CALL ERROR$MSG('FILE NOT FOUND IN !'//ID)
        CALL ERROR$STOP('XASCNTL$FILES')
      END IF
      CALL LINKEDLIST$GET(LL_CNTL,'FILE',0,FILENAME)
    
      CALL XAS$SETCH('FILE',FILENAME)
      CALL XAS$SETCH('ID',ID)
      CALL FILEHANDLER$SETFILE(ID,.FALSE.,TRIM(FILENAME))
                          CALL TRACE$POP
      END SUBROUTINE XASCNTL$FILES
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XASCNTL$RESTART  ! MARK: XASCNTL$RESTART
!     **************************************************************************
!     **                                                                      **
!     **************************************************************************
      USE XASCNTL_MODULE, ONLY: LL_CNTL
      USE XAS_MODULE, ONLY: TRSTRT,TSIM
      USE LINKEDLIST_MODULE
      IMPLICIT NONE
      LOGICAL(4) :: TCHK
      CHARACTER(256) :: FILENAME
!     **************************************************************************
                          CALL TRACE$PUSH('XASCNTL$RESTART')
      CALL LINKEDLIST$SELECT(LL_CNTL,'~')
      CALL LINKEDLIST$SELECT(LL_CNTL,'XCNTL')
      CALL LINKEDLIST$EXISTL(LL_CNTL,'RSTRT',1,TCHK)
      IF(.NOT.TCHK) THEN
        TRSTRT=.FALSE.
        CALL TRACE$POP
        RETURN
      END IF
      IF(TSIM) THEN
        CALL ERROR$MSG('RESTART FILE GIVEN BUT SIMULATION FILES READ BEFORE')
        CALL ERROR$STOP('XASCNTL$RESTART')
      END IF
      CALL LINKEDLIST$SELECT(LL_CNTL,'RSTRT')
      CALL LINKEDLIST$EXISTD(LL_CNTL,'FILE',1,TCHK)
      IF(.NOT.TCHK) THEN
        CALL ERROR$MSG('FILE NOT FOUND IN !RSTRT')
        CALL ERROR$STOP('XASCNTL$RESTART')
      END IF
      CALL LINKEDLIST$GET(LL_CNTL,'FILE',0,FILENAME)
      CALL FILEHANDLER$SETFILE('RSTRT_IN',.FALSE.,TRIM(FILENAME))
      TRSTRT=.TRUE.
                          CALL TRACE$POP
      END SUBROUTINE XASCNTL$RESTART
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XASCNTL$GRID  ! MARK: XASCNTL$GRID
!     **************************************************************************
!     ** READ SETTINGS FOR THE ENERGY GRID                                    **
!     **************************************************************************
      USE XASCNTL_MODULE, ONLY: LL_CNTL
      USE XAS_MODULE, ONLY: SETTINGS
      USE LINKEDLIST_MODULE
      IMPLICIT NONE
      LOGICAL(4) :: TCHK
      REAL(8) :: EV
      REAL(8) :: KB
      REAL(8) :: SVAR
!     **************************************************************************
                          CALL TRACE$PUSH('XASCNTL$GRID')
      CALL CONSTANTS('EV',EV)
      CALL CONSTANTS('KB',KB)
!     == DEFAULT VALUES ========================================================
      SETTINGS%GAMMA=0.3D0*EV
      SETTINGS%DE=1.D-2*EV
!     == READ GRID BLOCK =======================================================
      CALL LINKEDLIST$SELECT(LL_CNTL,'~')
      CALL LINKEDLIST$SELECT(LL_CNTL,'XCNTL')
      CALL LINKEDLIST$EXISTL(LL_CNTL,'GRID',1,TCHK)
      IF(.NOT.TCHK) THEN
                          CALL TRACE$POP
        RETURN
      END IF
      CALL LINKEDLIST$SELECT(LL_CNTL,'GRID')
!     == READ ENERGY SPACING (OPTIONAL) ========================================
      CALL LINKEDLIST$EXISTD(LL_CNTL,'DE[EV]',1,TCHK)
      IF(TCHK) THEN
        CALL LINKEDLIST$GET(LL_CNTL,'DE[EV]',1,SVAR)
        SETTINGS%DE=SVAR*EV
      END IF
!     == READ LIFETIME (OPTIONAL) ============================================
      CALL LINKEDLIST$EXISTD(LL_CNTL,'GAMMA[EV]',1,TCHK)
      IF(TCHK) THEN
        CALL LINKEDLIST$GET(LL_CNTL,'GAMMA[EV]',1,SVAR)
        SETTINGS%GAMMA=SVAR*EV
      END IF
!     == READ ENERGY RANGE (MANDATORY) =========================================
! TODO: IMPLEMENT OVERWRITING AUTOMATIC ENERGY RANGE DETECTION
!       CALL LINKEDLIST$EXISTD(LL_CNTL,'EMIN',1,TCHK)
!       IF(.NOT.TCHK) THEN
!         CALL ERROR$MSG('EMIN NOT FOUND IN !GRID')
!         CALL ERROR$STOP('XASCNTL$GRID')
!       END IF
!       CALL LINKEDLIST$GET(LL_CNTL,'EMIN',1,SVAR)
!       SETTINGS%EMIN=SVAR*EV
!       CALL LINKEDLIST$EXISTD(LL_CNTL,'EMAX',1,TCHK)
!       IF(.NOT.TCHK) THEN
!         CALL ERROR$MSG('EMAX NOT FOUND IN !GRID')
!         CALL ERROR$STOP('XASCNTL$GRID')
!       END IF
!       CALL LINKEDLIST$GET(LL_CNTL,'EMAX',1,SVAR)
!       SETTINGS%EMAX=SVAR*EV
!       SETTINGS%NE=INT((EMAX-EMIN)/DE)+1
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE XASCNTL$GRID
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XASCNTL$SPECTRUM  ! MARK: XASCNTL$SPECTRUM
!     **************************************************************************
!     **                                                                      **
!     **************************************************************************
      USE XASCNTL_MODULE, ONLY: LL_CNTL
      USE XAS_MODULE, ONLY: SPECTRUM,SPECTRUMARR,TSPECTRUM,SETTINGS
      USE LINKEDLIST_MODULE
      IMPLICIT NONE
      LOGICAL(4) :: TCHK
      LOGICAL(4) :: TCHK1,TCHK2
      INTEGER(4) :: NSPEC
      INTEGER(4) :: ISPEC
      REAL(8) :: REALPOL(4)
      REAL(8) :: REALPOLXYZ(6)
!     *************************************************************************
! WARNING: READING OF COMPLEX POLARIZATION IS NOT IMPLEMENTED
! TODO: IMPLEMENT READING OF COMPLEX POLARIZATION
                          CALL TRACE$PUSH('XASCNTL$SPECTRUM')
      CALL LINKEDLIST$SELECT(LL_CNTL,'~')
      CALL LINKEDLIST$SELECT(LL_CNTL,'XCNTL')
!     CHECK IF AT LEAST ONE SPECTRUM IS DEFINED
      CALL LINKEDLIST$EXISTL(LL_CNTL,'SPECTRUM',1,TCHK)
      IF(.NOT.TCHK) THEN
        CALL ERROR$MSG('SPECTRUM NOT FOUND IN XCNTL')
        CALL ERROR$STOP('XASCNTL$SPECTRUM')
      END IF
!     ALLOCATE CORRECT NUMBER OF SPECTRA
      CALL LINKEDLIST$NLISTS(LL_CNTL,'SPECTRUM',NSPEC)
      ALLOCATE(SPECTRUMARR(NSPEC))
      SETTINGS%NSPEC=NSPEC
!     LOOP OVER SPECTRA AND READ DATA
      DO ISPEC=1,NSPEC
        SPECTRUM=>SPECTRUMARR(ISPEC)
        CALL LINKEDLIST$SELECT(LL_CNTL,'~')
        CALL LINKEDLIST$SELECT(LL_CNTL,'XCNTL')
        CALL LINKEDLIST$SELECT(LL_CNTL,'SPECTRUM',ISPEC)
!       OUTPUT FILE NAME
        CALL LINKEDLIST$EXISTD(LL_CNTL,'FILE',1,TCHK)
        IF(.NOT.TCHK) THEN
          CALL ERROR$MSG('FILE NOT FOUND IN !SPECTRUM')
          CALL ERROR$I4VAL('ISPEC',ISPEC)
          CALL ERROR$STOP('XASCNTL$SPECTRUM')
        END IF
        CALL LINKEDLIST$GET(LL_CNTL,'FILE',1,SPECTRUM%FILE)
!       POLARISATION IN CARTHESIAN COORDINATES
        CALL LINKEDLIST$EXISTD(LL_CNTL,'POLXYZ',1,TCHK)
        IF(TCHK) THEN
          CALL LINKEDLIST$GET(LL_CNTL,'POLXYZ',1,REALPOLXYZ)
          SPECTRUM%TPOLXYZ=.TRUE.
          SPECTRUM%POLXYZ(1)=CMPLX(REALPOLXYZ(1),REALPOLXYZ(2),KIND=8)
          SPECTRUM%POLXYZ(2)=CMPLX(REALPOLXYZ(3),REALPOLXYZ(4),KIND=8)
          SPECTRUM%POLXYZ(3)=CMPLX(REALPOLXYZ(5),REALPOLXYZ(6),KIND=8)
        ELSE
          SPECTRUM%TPOLXYZ=.FALSE.
        END IF
!       NORMAL OF THE SYSTEM
        CALL LINKEDLIST$EXISTD(LL_CNTL,'NORMAL',1,TCHK)
        CALL LINKEDLIST$EXISTD(LL_CNTL,'KDIR',1,TCHK1)
        CALL LINKEDLIST$EXISTD(LL_CNTL,'POL',1,TCHK2)

        IF(SPECTRUM%TPOLXYZ) THEN
          IF(TCHK.OR.TCHK1.OR.TCHK2) THEN
            CALL ERROR$MSG('NORMAL, KDIR, OR POL NOT COMPATIBLE WITH POLXYZ')
            CALL ERROR$I4VAL('ISPEC',ISPEC)
            CALL ERROR$STOP('XASCNTL$SPECTRUM')
          END IF
        ELSE
          IF(.NOT.(TCHK.AND.TCHK1.AND.TCHK2)) THEN
            CALL ERROR$MSG('!SPECTRUM REQUIRES ONE OF TWO OPTIONS:')
            CALL ERROR$MSG(' - NORMAL, KDIR, AND POL')
            CALL ERROR$MSG(' - POLXYZ')
            CALL ERROR$I4VAL('ISPEC',ISPEC)
            CALL ERROR$STOP('XASCNTL$SPECTRUM')
          END IF
!         NORMAL OF THE SYSTEM
          CALL LINKEDLIST$GET(LL_CNTL,'NORMAL',1,SPECTRUM%NORMAL)
!         DIRECTION OF THE K-VECTOR
          CALL LINKEDLIST$GET(LL_CNTL,'KDIR',1,SPECTRUM%KDIR)
!         POLARISATION
          CALL LINKEDLIST$GET(LL_CNTL,'POL',1,REALPOL)
          SPECTRUM%POL(1)=CMPLX(REALPOL(1),REALPOL(2),KIND=8)
          SPECTRUM%POL(2)=CMPLX(REALPOL(3),REALPOL(4),KIND=8)
        END IF
      ENDDO
      TSPECTRUM=.TRUE.
                          CALL TRACE$POP
      END SUBROUTINE XASCNTL$SPECTRUM
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XASCNTL$COREHOLE  ! MARK: XASCNTL$COREHOLE
!     **************************************************************************
!     **                                                                      **
!     **************************************************************************
      USE XASCNTL_MODULE, ONLY: LL_CNTL
      USE XAS_MODULE, ONLY: SETTINGS,SIM,TSIM,TSETTINGS,TRSTRT
      USE LINKEDLIST_MODULE
      IMPLICIT NONE
      LOGICAL(4) :: TCHK
      INTEGER(4) :: NCORE
      INTEGER(4) :: LCORE
      CHARACTER(256) :: ATOM
      INTEGER(4) :: IAT
                          CALL TRACE$PUSH('XASCNTL$COREHOLE')
      IF(TRSTRT) THEN
                          CALL TRACE$POP
        TSETTINGS=.TRUE.
        RETURN
      END IF
      IF(.NOT.TSIM) THEN
        CALL ERROR$MSG('SIMULATION DATA NOT ALLOCATED')
        CALL ERROR$MSG('MUST BE CALLED AFTER XAS$READ TO ACCESS ATOM NAMES')
        CALL ERROR$STOP('XASCNTL$COREHOLE')
      END IF
      CALL LINKEDLIST$SELECT(LL_CNTL,'~')
      CALL LINKEDLIST$SELECT(LL_CNTL,'XCNTL')
      CALL LINKEDLIST$EXISTL(LL_CNTL,'COREHOLE',1,TCHK)
      IF(.NOT.TCHK) THEN
        CALL ERROR$MSG('!COREHOLE NOT FOUND IN !XCNTL')
        CALL ERROR$STOP('XASCNTL$COREHOLE')
      END IF
      CALL LINKEDLIST$SELECT(LL_CNTL,'COREHOLE')

      CALL LINKEDLIST$EXISTD(LL_CNTL,'ATOM',1,TCHK)
      IF(.NOT.TCHK) THEN
        CALL ERROR$MSG('ATOM NOT FOUND IN !COREHOLE')
        CALL ERROR$STOP('XASCNTL$COREHOLE')
      END IF
      CALL LINKEDLIST$GET(LL_CNTL,'ATOM',1,ATOM)
      SETTINGS%ATOM=TRIM(ATOM)
      TCHK=.FALSE.
      DO IAT=1,SIM(1)%NAT
        IF(TRIM(ATOM).EQ.TRIM(SIM(1)%ATOMID(IAT))) THEN
          TCHK=.TRUE.
          EXIT
        END IF
      ENDDO
      IF(TCHK) THEN
        SETTINGS%IATOM=IAT
      ELSE
        CALL ERROR$MSG('ATOM NOT FOUND IN SIMULATION')
        CALL ERROR$CHVAL('ATOM',ATOM)
        CALL ERROR$STOP('XASCNTL$COREHOLE')
      END IF

      CALL LINKEDLIST$EXISTD(LL_CNTL,'NCORE',1,TCHK)
      IF(.NOT.TCHK) THEN
        CALL ERROR$MSG('NCORE NOT FOUND IN !COREHOLE')
        CALL ERROR$STOP('XASCNTL$COREHOLE')
      END IF
      CALL LINKEDLIST$GET(LL_CNTL,'NCORE',1,NCORE)
      SETTINGS%NCORE=NCORE
! TODO: CHECK IF LCORE IS VALID FOR GIVEN NCORE
      CALL LINKEDLIST$EXISTD(LL_CNTL,'LCORE',1,TCHK)
      IF(.NOT.TCHK) THEN
        CALL ERROR$MSG('LCORE NOT FOUND IN !COREHOLE')
        CALL ERROR$STOP('XASCNTL$COREHOLE')
      END IF
      CALL LINKEDLIST$GET(LL_CNTL,'LCORE',1,LCORE)
      IF(LCORE.NE.0) THEN
        CALL ERROR$MSG('IMPLEMENTATION ONLY FOR S COREHOLES (LCORE=0)')
        CALL ERROR$I4VAL('LCORE',LCORE)
        CALL ERROR$STOP('XASCNTL$COREHOLE')
      END IF
      SETTINGS%LCORE=LCORE

      TSETTINGS=.TRUE.
                          CALL TRACE$POP
      END SUBROUTINE XASCNTL$COREHOLE
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XASCNTL$OUTPUT  ! MARK: XASCNTL$OUTPUT
!     **************************************************************************
!     **                                                                      **
!     **************************************************************************
      USE XASCNTL_MODULE, ONLY: LL_CNTL
      USE XAS_MODULE, ONLY: OUTPUT
      USE LINKEDLIST_MODULE
      IMPLICIT NONE
      LOGICAL(4) :: TCHK
                          CALL TRACE$PUSH('XASCNTL$OUTPUT')
      OUTPUT%TOVL=.FALSE.
      OUTPUT%TOVLPW=.FALSE.
      OUTPUT%TOVLAUG=.FALSE.
      OUTPUT%TOVLOCC=.FALSE.
      OUTPUT%TOVLEMP=.FALSE.
      OUTPUT%TKMAT=.FALSE.
      OUTPUT%TDIPOLE=.FALSE.
      OUTPUT%TADET=.FALSE.
      OUTPUT%TRAW=.FALSE.
      OUTPUT%TKPTSPIN=.FALSE.
      OUTPUT%TBINARY=.FALSE.
      CALL LINKEDLIST$SELECT(LL_CNTL,'~')
      CALL LINKEDLIST$SELECT(LL_CNTL,'XCNTL')
      CALL LINKEDLIST$EXISTL(LL_CNTL,'OUTPUT',1,TCHK)
      IF(.NOT.TCHK) THEN
                          CALL TRACE$POP
        RETURN
      END IF
      CALL LINKEDLIST$SELECT(LL_CNTL,'OUTPUT')
!     TOVL
      CALL LINKEDLIST$EXISTD(LL_CNTL,'OVL',1,TCHK)
      IF(TCHK) CALL LINKEDLIST$GET(LL_CNTL,'OVL',1,OUTPUT%TOVL)
!     TOVLPW
      CALL LINKEDLIST$EXISTD(LL_CNTL,'OVLPW',1,TCHK)
      IF(TCHK) CALL LINKEDLIST$GET(LL_CNTL,'OVLPW',1,OUTPUT%TOVLPW)
!     TOVLAUG
      CALL LINKEDLIST$EXISTD(LL_CNTL,'OVLAUG',1,TCHK)
      IF(TCHK) CALL LINKEDLIST$GET(LL_CNTL,'OVLAUG',1,OUTPUT%TOVLAUG)
!     TOVLOCC
      CALL LINKEDLIST$EXISTD(LL_CNTL,'OVLOCC',1,TCHK)
      IF(TCHK) CALL LINKEDLIST$GET(LL_CNTL,'OVLOCC',1,OUTPUT%TOVLOCC)
!     TOVLEMP
      CALL LINKEDLIST$EXISTD(LL_CNTL,'OVLEMP',1,TCHK)
      IF(TCHK) CALL LINKEDLIST$GET(LL_CNTL,'OVLEMP',1,OUTPUT%TOVLEMP)
!     TKMAT
      CALL LINKEDLIST$EXISTD(LL_CNTL,'KMAT',1,TCHK)
      IF(TCHK) CALL LINKEDLIST$GET(LL_CNTL,'KMAT',1,OUTPUT%TKMAT)
!     TDIPOLE
      CALL LINKEDLIST$EXISTD(LL_CNTL,'DIPOLE',1,TCHK)
      IF(TCHK) CALL LINKEDLIST$GET(LL_CNTL,'DIPOLE',1,OUTPUT%TDIPOLE)
!     TADET
      CALL LINKEDLIST$EXISTD(LL_CNTL,'ADET',1,TCHK)
      IF(TCHK) CALL LINKEDLIST$GET(LL_CNTL,'ADET',1,OUTPUT%TADET)
!     TRAW
      CALL LINKEDLIST$EXISTD(LL_CNTL,'RAW',1,TCHK)
      IF(TCHK) CALL LINKEDLIST$GET(LL_CNTL,'RAW',1,OUTPUT%TRAW)
!     TKPTSPIN
      CALL LINKEDLIST$EXISTD(LL_CNTL,'KPTSPIN',1,TCHK)
      IF(TCHK) CALL LINKEDLIST$GET(LL_CNTL,'KPTSPIN',1,OUTPUT%TKPTSPIN)
!     TBINARY
      CALL LINKEDLIST$EXISTD(LL_CNTL,'BINARY',1,TCHK)
      IF(TCHK) CALL LINKEDLIST$GET(LL_CNTL,'BINARY',1,OUTPUT%TBINARY)
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE XASCNTL$OUTPUT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XASCNTL$AUXORB  ! MARK: XASCNTL$AUXORB
!     **************************************************************************
!     ** READ AUXORB BLOCKS IN XCNTL                                          **
!     **************************************************************************
      USE XASCNTL_MODULE, ONLY: LL_CNTL
      USE XAS_MODULE, ONLY: SETTINGS,AUXORB,AUXORBARR
      USE LINKEDLIST_MODULE
      IMPLICIT NONE
      LOGICAL(4) :: TCHK
      INTEGER(4) :: NAUX
      INTEGER(4) :: I
      CHARACTER(256) :: FILENAME

                          CALL TRACE$PUSH('XASCNTL$AUXORB')
      CALL LINKEDLIST$SELECT(LL_CNTL,'~')
      CALL LINKEDLIST$SELECT(LL_CNTL,'XCNTL')
!     CHECK IF AUXORB BLOCKS ARE DEFINED
      CALL LINKEDLIST$NLISTS(LL_CNTL,'AUXORB',NAUX)
      SETTINGS%NAUXORB=NAUX
!     RETURN IF NO AUXORB BLOCKS
      IF(SETTINGS%NAUXORB.EQ.0) THEN
                          CALL TRACE$POP
        RETURN
      END IF
!     ALLOCATE AUXORBARR
      ALLOCATE(AUXORBARR(NAUX))
!     LOOP OVER AUXORB BLOCKS
      DO I=1,NAUX
        AUXORB=>AUXORBARR(I)
        CALL LINKEDLIST$SELECT(LL_CNTL,'AUXORB',I)
!       READ FILENAME
        CALL LINKEDLIST$EXISTD(LL_CNTL,'FILE',1,TCHK)
        IF(.NOT.TCHK) THEN
          CALL ERROR$MSG('FILE NOT FOUND IN !AUXORB')
          CALL ERROR$I4VAL('I',I)
          CALL ERROR$STOP('XASCNTL$AUXORB')
        END IF
        CALL LINKEDLIST$GET(LL_CNTL,'FILE',1,FILENAME)
        AUXORB%FILE=TRIM(FILENAME)
!       READ BAND INDEX
        CALL LINKEDLIST$EXISTD(LL_CNTL,'BAND',1,TCHK)
        IF(.NOT.TCHK) THEN
          CALL ERROR$MSG('BAND NOT FOUND IN !AUXORB')
          CALL ERROR$I4VAL('I',I)
          CALL ERROR$STOP('XASCNTL$AUXORB')
        END IF
        CALL LINKEDLIST$GET(LL_CNTL,'BAND',1,AUXORB%BAND)
!       READ SPIN INDEX
        CALL LINKEDLIST$EXISTD(LL_CNTL,'S',1,TCHK)
        IF(TCHK) THEN
          CALL LINKEDLIST$GET(LL_CNTL,'S',1,AUXORB%S)
        ELSE
          AUXORB%S=1
        END IF
!       READ K-POINT INDEX
        CALL LINKEDLIST$EXISTD(LL_CNTL,'K',1,TCHK)
        IF(TCHK) THEN
          CALL LINKEDLIST$GET(LL_CNTL,'K',1,AUXORB%K)
        ELSE
          AUXORB%K=1
        END IF
! !       READ MAXIMUM NUMBER OF ORBITALS
!         CALL LINKEDLIST$EXISTD(LL_CNTL,'NORB',1,TCHK)
!         IF(TCHK) THEN
!           CALL LINKEDLIST$GET(LL_CNTL,'NORB',1,AUXORB%NORB)
!         ELSE
! !         SELECTS ALL
!           AUXORB%NORB=-1
!         END IF
        CALL LINKEDLIST$SELECT(LL_CNTL,'..')
      ENDDO
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE XASCNTL$AUXORB
!      
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE INITIALIZEFILEHANDLER
!     **************************************************************************
      USE STRINGS_MODULE
      IMPLICIT NONE
      CHARACTER(256) :: ROOTNAME
      CHARACTER(256) :: XASINNAME
      INTEGER(4)     :: ISVAR
      INTEGER(4)     :: NARGS
!     **************************************************************************
                          CALL TRACE$PUSH('INITIALIZEFILEHANDLER')
      NARGS=COMMAND_ARGUMENT_COUNT()
      IF(NARGS.LT.1) THEN
        CALL ERROR$MSG('ARGUMENT LIST OF EXECUTABLE IS EMPTY')
        CALL ERROR$MSG('THE CONTROL FILE OF THE XAS TOOL IS MANDATORY')
        CALL ERROR$STOP('INITIALIZEFILEANDLER')
      END IF
      CALL GET_COMMAND_ARGUMENT(1,XASINNAME)
      ISVAR=INDEX(XASINNAME,-'.XCNTL',BACK=.TRUE.)
      IF(ISVAR.NE.0) THEN
        ROOTNAME=XASINNAME(1:ISVAR-1)
      ELSE
        ROOTNAME=' '
      END IF
      CALL FILEHANDLER$SETROOT(ROOTNAME)
      CALL STANDARDFILES
      CALL FILEHANDLER$SETFILE('XCNTL',.FALSE.,XASINNAME)
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE INITIALIZEFILEHANDLER
!
!      ..1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE STANDARDFILES
!     **************************************************************************
      USE STRINGS_MODULE
      IMPLICIT NONE
      CHARACTER(32)        :: ID
!     **************************************************************************
                                   CALL TRACE$PUSH('STANDARDFILES')
!     ==========================================================================
!     == SET STANDARD FILENAMES                                               ==
!     ==========================================================================
!     ==  ERROR FILE ===========================================================
      ID=+'ERR'
      CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.XERR')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','REPLACE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','APPEND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','WRITE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')
!     ==  PROTOCOL FILE ========================================================
      ID=+'PROT'
      CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.XPROT')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','REPLACE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','APPEND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','WRITE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')
!     ==  CONTROL FILE  == =====================================================
      ID=+'XCNTL'
      CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.XCNTL')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','OLD')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','REWIND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','READ')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')
!     ==  GROUNDSTATE XAS FILE   ===============================================
      ID=+'GROUNDSTATE'
      CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.GROUND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','OLD')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','REWIND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','READ')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','UNFORMATTED')
!     ==  EXCITED STATE XAS FILE   =============================================
      ID=+'EXCITESTATE'
      CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.EXCITE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','OLD')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','REWIND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','READ')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','UNFORMATTED')
!     ==  XAS SPECTRUM FILE PRODUCES AS OUTPUT =================================
!     ==  RESTART FILE WRITING =================================================
      ID=+'RSTRT_OUT'
      CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.XASRSTRT')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','REPLACE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','REWIND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','WRITE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','UNFORMATTED')
!     ==  RESTART FILE WRITING =================================================
      ID=+'RSTRT_IN'
      CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.XASRSTRT')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','OLD')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','REWIND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','READ')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','UNFORMATTED')
!     ==  WILL BE ATTACHED TO DIFFERENT FILES DURING EXECUTION =================
      ID=+'XASOUT'
      CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.XASOUT')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','REPLACE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','REWIND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','WRITE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')

      ID=+'OVL'
      CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.OVL')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','REPLACE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','REWIND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','WRITE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')

      ID=+'OVLPW'
      CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.OVLPW')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','REPLACE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','REWIND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','WRITE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')

      ID=+'OVLAUG'
      CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.OVLAUG')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','REPLACE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','REWIND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','WRITE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')

      ID=+'OVLOCC'
      CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.OVLOCC')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','REPLACE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','REWIND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','WRITE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')

      ID=+'OVLEMP'
      CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.OVLEMP')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','REPLACE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','REWIND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','WRITE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')

      ID=+'DIPOLE'
      CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.DIPOLE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','REPLACE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','REWIND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','WRITE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')

      ID=+'KMAT'
      CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.KMAT')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','REPLACE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','REWIND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','WRITE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')

      ID=+'ADET'
      CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.ADET')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','REPLACE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','REWIND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','WRITE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')

      ID=+'XASRAW'
      CALL FILEHANDLER$SETFILE(ID,.TRUE.,-'.XASRAW')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'STATUS','REPLACE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'POSITION','REWIND')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'ACTION','WRITE')
      CALL FILEHANDLER$SETSPECIFICATION(ID,'FORM','FORMATTED')
                                   CALL TRACE$POP
      RETURN
      END SUBROUTINE STANDARDFILES
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$READ  ! MARK: XAS$READ
!     **************************************************************************
!     **  READ FILE PRODUCED BY SIMULATION CODE                               **
!     **************************************************************************
      USE MPE_MODULE
      USE XAS_MODULE, ONLY: THIS,SELECTED,SIMULATION_TYPE,SIM,TSIM, &
     &                      OVERLAP,OVERLAPARR,TRSTRT,KMAP,NKPTG,RTASK
      USE RADIAL_MODULE, ONLY: NGID
      IMPLICIT NONE
      INTEGER(4), PARAMETER :: NSIM=2
      REAL(8), PARAMETER :: TOL=1.D-8
      LOGICAL(4), PARAMETER :: TPR=.FALSE.
      INTEGER(4) :: NFIL(NSIM)
      INTEGER(4) :: IS
      INTEGER(4) :: ILOGICAL
      INTEGER(4) :: ISP
      INTEGER(4) :: GID
      INTEGER(4) :: GID_
      INTEGER(4) :: IGID
      CHARACTER(8) :: GRIDTYPE
      CHARACTER(8) :: GRIDTYPE_
      INTEGER(4) :: NR
      INTEGER(4) :: NR_
      REAL(8) :: DEX
      REAL(8) :: DEX_
      REAL(8) :: R1
      REAL(8) :: R1_
      REAL(8) :: V
      INTEGER(4) :: LNX
      INTEGER(4) :: IB
      INTEGER(4) :: IAT
      INTEGER(4) :: LN
      INTEGER(4) :: L
      INTEGER(4) :: M
      INTEGER(4) :: IPRO
      INTEGER(4) :: IB1,IB2
      INTEGER(4) :: IKPT
      INTEGER(4) :: IG
      INTEGER(4) :: NKPT
      INTEGER(4) :: NKPT_
      INTEGER(4) :: NB_
      INTEGER(4) :: NSPIN_
      INTEGER(4) :: ISPIN
      LOGICAL(4) :: TCHK
      CHARACTER(8) :: KEY(NSIM)
      INTEGER(4) :: NGG(NSIM)
      INTEGER(4) :: NDIM(NSIM)
      INTEGER(4) :: NB(NSIM)
      INTEGER(4) :: NBH(NSIM)
      LOGICAL(4) :: TSUPER(NSIM)
      INTEGER(4), ALLOCATABLE :: IGVEC(:,:,:) ! (NSIM,3,NGG)
      REAL(8) :: XK(NSIM,3)
      COMPLEX(8), ALLOCATABLE :: PSIK1(:,:,:) ! (NGG,NDIM,NB)
      COMPLEX(8), ALLOCATABLE :: PSIK2(:,:,:) ! (NGG,NDIM,NB)
      REAL(8), ALLOCATABLE :: OCC(:,:,:) ! (NB,NKPT,NSPIN)
      COMPLEX(8), ALLOCATABLE :: OVLAP(:,:) ! (NB,NB)
      INTEGER(4) :: NTASKS,THISTASK
!     **************************************************************************
                          CALL TRACE$PUSH('XAS$READ')
                          CALL TIMING$CLOCKON('XAS$READ')
      IF(TRSTRT) THEN
        CALL ERROR$MSG('XAS$READ CANNOT BE CALLED WHEN RESTART FILE IS GIVEN')
        CALL ERROR$STOP('XAS$READ')
      END IF
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      IF(ALLOCATED(KMAP)) THEN
        CALL ERROR$MSG('KMAP ALREADY ALLOCATED')
        CALL ERROR$STOP('XAS$READ')
      END IF
!     ==========================================================================
!     == LOOP OVER BOTH SIMULATIONS                                           ==
!     == REQUIRED TO CALCULATE OVERLAP ON READ AND NOT STORE PLANE WAVE BASIS ==
!     ==========================================================================
      DO IS=1,NSIM
        CALL XAS$ISELECT(IS)
        IF(THISTASK.EQ.1) THEN
          IF(TPR) CALL TRACE$PASS('READING GENERAL QUANTITIES')
          CALL FILEHANDLER$UNIT(THIS%ID,NFIL(IS))
          REWIND(NFIL(IS))
!         ======================================================================
!         == READ GENERAL QUANTATIES                                          ==
!         ======================================================================
!         NAT,NSP,NKPT,NSPIN,NDIM,NPRO,LNXX,FLAG
          READ(NFIL(IS))THIS%NAT,THIS%NSP,THIS%NKPT,THIS%NSPIN,THIS%NDIM, &
&                       THIS%NPRO,THIS%LNXX,THIS%FLAG
        END IF
        CALL MPE$BROADCAST('~',1,THIS%NAT)
        CALL MPE$BROADCAST('~',1,THIS%NSP)
        CALL MPE$BROADCAST('~',1,THIS%NKPT)
        CALL MPE$BROADCAST('~',1,THIS%NSPIN)
        CALL MPE$BROADCAST('~',1,THIS%NDIM)
        CALL MPE$BROADCAST('~',1,THIS%NPRO)
        CALL MPE$BROADCAST('~',1,THIS%LNXX)
        CALL MPE$BROADCAST('~',1,THIS%FLAG)
!       DISTRIBUTE WORKLOAD FOR K-POINT LOOP WHILE READING FOR SIMULATION
        IF(IS.EQ.1) THEN
          NKPTG=THIS%NKPT
          ALLOCATE(KMAP(NKPTG))
          CALL KMAPINIT(NKPTG,RTASK,KMAP)
        END IF
        ALLOCATE(THIS%LNX(THIS%NSP))
        ALLOCATE(THIS%LOX(THIS%LNXX,THIS%NSP))
        IF(THISTASK.EQ.RTASK) THEN
!         LNX(NSP),LOX(LNXX,NSP)
          READ(NFIL(IS))THIS%LNX,THIS%LOX
!         NKDIV(3),ISHIFT(3),RNTOT,NEL,TINV
          READ(NFIL(IS))THIS%NKDIV,THIS%ISHIFT,THIS%RNTOT,THIS%NEL, &
&                       THIS%EDFT,ILOGICAL
          THIS%TINV=.FALSE.
          IF(ILOGICAL.EQ.1) THIS%TINV=.TRUE.
!         SPACEGROUP,TSHIFT
          READ(NFIL(IS))THIS%SPACEGROUP,ILOGICAL
          THIS%TSHIFT=.FALSE.
          IF(ILOGICAL.EQ.1) THIS%TSHIFT=.TRUE.
        END IF
        CALL MPE$BROADCAST('~',RTASK,THIS%LNX)
        CALL MPE$BROADCAST('~',RTASK,THIS%LOX)
        CALL MPE$BROADCAST('~',RTASK,THIS%NKDIV)
        CALL MPE$BROADCAST('~',RTASK,THIS%ISHIFT)
        CALL MPE$BROADCAST('~',RTASK,THIS%RNTOT)
        CALL MPE$BROADCAST('~',RTASK,THIS%NEL)
        CALL MPE$BROADCAST('~',RTASK,THIS%EDFT)
        CALL MPE$BROADCAST('~',RTASK,THIS%TINV)
        CALL MPE$BROADCAST('~',RTASK,THIS%SPACEGROUP)
        CALL MPE$BROADCAST('~',RTASK,THIS%TSHIFT)
        ALLOCATE(THIS%LMNX(THIS%NSP))
        THIS%LMNX=0
        DO ISP=1,THIS%NSP
          DO LN=1,THIS%LNX(ISP)
            THIS%LMNX(ISP)=THIS%LMNX(ISP)+2*THIS%LOX(LN,ISP)+1
          ENDDO
        ENDDO
!       ========================================================================
!       == READ ATOMIC STRUCTURE                                              ==
!       ========================================================================
        ALLOCATE(THIS%R(3,THIS%NAT))
        ALLOCATE(THIS%ATOMID(THIS%NAT))
        ALLOCATE(THIS%ISPECIES(THIS%NAT))
        IF(THISTASK.EQ.RTASK) THEN
          IF(TPR) CALL TRACE$PASS('READING ATOMIC STRUCTURE')
!         RBAS(3,3),R(3,NAT),ATOMID(NAT),ISPECIES(NAT)
          READ(NFIL(IS))THIS%RBAS,THIS%R,THIS%ATOMID,THIS%ISPECIES
        END IF
        CALL MPE$BROADCAST('~',RTASK,THIS%RBAS)
        CALL MPE$BROADCAST('~',RTASK,THIS%R)
        CALL MPE$BROADCAST('~',RTASK,THIS%ATOMID)
        CALL MPE$BROADCAST('~',RTASK,THIS%ISPECIES)
        V=THIS%RBAS(1,1)*(THIS%RBAS(2,2)*THIS%RBAS(3,3)-THIS%RBAS(2,3)*THIS%RBAS(3,2)) &
&         +THIS%RBAS(2,1)*(THIS%RBAS(3,2)*THIS%RBAS(1,3)-THIS%RBAS(3,3)*THIS%RBAS(1,2)) &
&         +THIS%RBAS(3,1)*(THIS%RBAS(1,2)*THIS%RBAS(2,3)-THIS%RBAS(1,3)*THIS%RBAS(2,2)) 
!       ========================================================================
!       == ELEMENT SPECIFIC QUANTITIES                                        ==
!       ========================================================================
        ALLOCATE(THIS%SETUP(THIS%NSP))
!       LOOP THROUGH SPECIES
        DO ISP=1,THIS%NSP
          IF(THISTASK.EQ.RTASK) THEN
            IF(TPR) CALL TRACE$PASS('READING ELEMENT SPECIFIC QUANTITIES')
!           GRIDTYPE,NR,DEX,R1
            READ(NFIL(IS))GRIDTYPE,NR,DEX,R1
!           CHECK IF RADIAL GRID WITH SAME PROPERTIES ALREADY EXISTS
            TCHK=.FALSE.
            IF(NGID.GT.0) THEN
              DO IGID=1,NGID
                CALL RADIAL$GETCH(IGID,'TYPE',GRIDTYPE_)
                CALL RADIAL$GETI4(IGID,'NR',NR_)
                CALL RADIAL$GETR8(IGID,'DEX',DEX_)
                CALL RADIAL$GETR8(IGID,'R1',R1_)
                IF(GRIDTYPE.EQ.GRIDTYPE_.AND.NR.EQ.NR_.AND.DEX.EQ.DEX_.AND.R1.EQ.R1_) THEN
                  GID=IGID
                  TCHK=.TRUE.
                  EXIT
                END IF
              ENDDO ! END IGID
            END IF
          END IF
          CALL MPE$BROADCAST('~',RTASK,GRIDTYPE)
          CALL MPE$BROADCAST('~',RTASK,NR)
          CALL MPE$BROADCAST('~',RTASK,DEX)
          CALL MPE$BROADCAST('~',RTASK,R1)
          CALL MPE$BROADCAST('~',RTASK,TCHK)
          CALL MPE$BROADCAST('~',RTASK,GID)
!         IF GRID ALREADY EXISTS, USE ITS GID. ELSE CREATE NEW GRID
          IF(TCHK) THEN
            THIS%SETUP(ISP)%GID=GID
          ELSE
            CALL RADIAL$NEW(GRIDTYPE,THIS%SETUP(ISP)%GID)
            CALL RADIAL$SETI4(THIS%SETUP(ISP)%GID,'NR',NR)
            CALL RADIAL$SETR8(THIS%SETUP(ISP)%GID,'DEX',DEX)
            CALL RADIAL$SETR8(THIS%SETUP(ISP)%GID,'R1',R1)
          END IF
!         ECORE
          IF(THISTASK.EQ.RTASK) READ(NFIL(IS))THIS%SETUP(ISP)%ECORE
          CALL MPE$BROADCAST('~',RTASK,THIS%SETUP(ISP)%ECORE)
!         ALLOCATE AND READ (AUXILIARY) PARTIAL WAVES
          LNX=THIS%LNX(ISP)
          ALLOCATE(THIS%SETUP(ISP)%PSPHI(NR,LNX))
          ALLOCATE(THIS%SETUP(ISP)%AEPHI(NR,LNX))
          IF(THISTASK.EQ.RTASK) THEN
!           PSPHI(NR,LNX)
            READ(NFIL(IS))THIS%SETUP(ISP)%PSPHI
!           AEPHI(NR,LNX)
            READ(NFIL(IS))THIS%SETUP(ISP)%AEPHI
!           NBATOM
            READ(NFIL(IS))THIS%SETUP(ISP)%NBATOM
          END IF
          CALL MPE$BROADCAST('~',RTASK,THIS%SETUP(ISP)%PSPHI)
          CALL MPE$BROADCAST('~',RTASK,THIS%SETUP(ISP)%AEPHI)
          CALL MPE$BROADCAST('~',RTASK,THIS%SETUP(ISP)%NBATOM)
!         ALLOCATE AND READ ATOMIC WAVE FUNCTIONS
          ALLOCATE(THIS%SETUP(ISP)%LATOM(THIS%SETUP(ISP)%NBATOM))
          ALLOCATE(THIS%SETUP(ISP)%AEPSI(NR,THIS%SETUP(ISP)%NBATOM))
          IF(THISTASK.EQ.RTASK) THEN
!           LATOM(NBATOM)
            READ(NFIL(IS))THIS%SETUP(ISP)%LATOM       
!           AEPSI(NR,NBATOM)
            READ(NFIL(IS))THIS%SETUP(ISP)%AEPSI
          END IF
          CALL MPE$BROADCAST('~',RTASK,THIS%SETUP(ISP)%LATOM)
          CALL MPE$BROADCAST('~',RTASK,THIS%SETUP(ISP)%AEPSI)
        ENDDO ! END ISP
!       ========================================================================
!       == OCCUPATIONS AND K-POINTS AND THEIR WEIGHTS                         ==
!       ========================================================================
        IF(THISTASK.EQ.RTASK) THEN
          IF(TPR) CALL TRACE$PASS('READING OCC, KPTS, WEIGHTS')
          READ(NFIL(IS))NB_,NKPT_,NSPIN_
        END IF
        CALL MPE$BROADCAST('~',RTASK,NB_)
        CALL MPE$BROADCAST('~',RTASK,NKPT_)
        CALL MPE$BROADCAST('~',RTASK,NSPIN_)

        ALLOCATE(THIS%STATEARR(NKPT_,NSPIN_))
        ALLOCATE(THIS%XK(3,NKPT_))
        ALLOCATE(THIS%WKPT(NKPT_))
        ALLOCATE(OCC(NB_,NKPT_,NSPIN_))
!       OCC(NB,NKPT,NSPIN),XK(3,NKPT),WKPT(NKPT)
        IF(THISTASK.EQ.RTASK) READ(NFIL(IS))OCC,THIS%XK,THIS%WKPT
        CALL MPE$BROADCAST('~',RTASK,OCC)
        CALL MPE$BROADCAST('~',RTASK,THIS%XK)
        CALL MPE$BROADCAST('~',RTASK,THIS%WKPT)
        DO IKPT=1,NKPT_
          IF(KMAP(IKPT).NE.THISTASK.AND.THISTASK.NE.RTASK) CYCLE
          DO ISPIN=1,NSPIN_
            THIS%STATE=>THIS%STATEARR(IKPT,ISPIN)
            THIS%STATE%NB=NB_
            ALLOCATE(THIS%STATE%OCC(NB_))
            THIS%STATE%OCC(:)=OCC(:,IKPT,ISPIN)
!           COUNT NUMBER OF OCCUPIED STATES
! ERROR: INVALID METHOD TO COUNT OCCUPIED STATES
            THIS%STATE%NOCC=-1
            DO IB=1,NB_
              IF(THIS%STATE%OCC(IB).LT.THIS%STATE%OCCTOL) THEN
                THIS%STATE%NOCC=IB-1
                EXIT
              END IF
            ENDDO ! END IB
            IF(THIS%STATE%NOCC.EQ.-1) THEN
              IF(THIS%ID.EQ.'EXCITESTATE') THEN
                CALL ERROR$MSG('NO UNOCCUPIED STATES FOUND FOR EXCITESTATE')
                CALL ERROR$STOP('XAS$READ')
              END IF
              THIS%STATE%NOCC=NB_
            END IF
          ENDDO ! END ISPIN
        ENDDO ! END IKPT
        DEALLOCATE(OCC)
!       ========================================================================
!       == MAPPING OF PROJECTION INDICES                                      ==
!       ========================================================================
        ALLOCATE(THIS%MAP(THIS%NAT,THIS%LNXX))
        THIS%MAP(:,:)=0
        IPRO=0
        DO IAT=1,THIS%NAT
          ISP=THIS%ISPECIES(IAT)
          DO LN=1,THIS%LNX(ISP)
            THIS%MAP(IAT,LN)=IPRO
            L=THIS%LOX(LN,ISP)
            DO M=1,2*L+1
              IPRO=IPRO+1
            ENDDO ! END M
          ENDDO ! END LN
        ENDDO ! END IAT
        CALL XAS$UNSELECT
      ENDDO ! END IS (NSIM)
!     MAP ATOM INDICES BASED ON NAMES
      CALL ATOMMAPPING
!     CALCULATE TOTAL CORE ENERGY
      CALL XAS_COREENERGY
!     ADD TOGETHER FOR TOTAL ENERGY
      SIM(1)%ETOT=SIM(1)%EDFT+SIM(1)%ECORE
      SIM(2)%ETOT=SIM(2)%EDFT+SIM(2)%ECORE
!     ==================================================================
!     == DATA CONSISTENCY CHECKS BETWEEN BOTH SIMULATIONS             ==
!     ==================================================================
      CALL DATACONSISTENCY

!     ALLOCATE STORAGE ARRAYS FOR OVERLAP_TYPES AND STATE_TYPES
      ALLOCATE(OVERLAPARR(SIM(1)%NKPT,SIM(1)%NSPIN))
!
!     ==================================================================
!     == WAVE FUNCTIONS AND PROJECTIONS                               ==
!     ==================================================================
      NKPT=SIM(1)%NKPT
!     LOOP OVER K POINTS
      DO IKPT=1,NKPT
        IF(KMAP(IKPT).NE.THISTASK.AND.THISTASK.NE.RTASK) CYCLE
        IF(THISTASK.EQ.RTASK) THEN
          CALL TRACE$I4VAL(' READ/SEND IKPT',IKPT)
!         READ GENERAL INFORMATION ABOUT K POINT
          DO IS=1,NSIM
!           KEY,NGG,NDIM,NB,NBH,TSUPER
            READ(NFIL(IS))KEY(IS),NGG(IS),NDIM(IS),NB(IS),ILOGICAL
            TSUPER(IS)=.FALSE.
            IF(ILOGICAL.EQ.1) TSUPER(IS)=.TRUE.
            IF(KEY(IS).NE.'PSI') THEN
              CALL ERROR$MSG('KEY NOT "PSI"')
              CALL ERROR$MSG('FILE IS CORRUPTED')
              CALL ERROR$CHVAL('KEY',KEY(IS))
              CALL ERROR$I4VAL('IKPT',IKPT)
              CALL ERROR$STOP('XAS$READ')
            END IF
          ENDDO ! END LOOP OVER IS
!         READ K POINT AND G VECTORS (PREVIOUSLY CHECKED IF #(NGG1,NGG2) SAME)
          ALLOCATE(IGVEC(NSIM,3,NGG(1)))
          DO IS=1,NSIM
!           XK(3),IGVEC(3,NGG)
            READ(NFIL(IS))XK(IS,:),IGVEC(IS,:,:)
          ENDDO ! END LOOP OVER IS
!         ==================================================================
!         == DATA CHECKS                                                  ==
!         ==================================================================
! NOTE: DATA CHECKS USE VARIABLES FROM THIS SUBROUTINE, POSITION OF CALL MATTERS     
          CALL TEST
          DEALLOCATE(IGVEC)
        END IF
        CALL MPE$SENDRECEIVE('~',RTASK,KMAP(IKPT),NGG)
        CALL MPE$SENDRECEIVE('~',RTASK,KMAP(IKPT),NDIM)
        CALL MPE$SENDRECEIVE('~',RTASK,KMAP(IKPT),NB)
! WARNING: REQUIRES SUPER WAVE FUNCTIONS TO BE UNRAVELED
        ALLOCATE(PSIK1(NGG(1),NDIM(1),NB(1)))
        ALLOCATE(PSIK2(NGG(2),NDIM(2),NB(2)))
!       LOOP OVER SPIN
        DO ISPIN=1,SIM(1)%NSPIN
!         SET STATE POINTER
          DO IS=1,NSIM
!           SET POINTER TO SPECIFIC STATE(IKPT,ISPIN)
            SIM(IS)%STATE=>SIM(IS)%STATEARR(IKPT,ISPIN)
!           CHECK IF NB CONSISTENT FOR OCCUPATIONS AND EIGENVALUES/PROJECTIONS
            IF(NB(IS).NE.SIM(IS)%STATE%NB) THEN
              CALL ERROR$MSG('NB FOR PROJECTIONS AND EIGENVALUES NOT THE SAME')
              CALL ERROR$MSG('FOR OCCUPATIONS AND EIGENVALUES/PROJECTIONS')
              CALL ERROR$I4VAL('NB_OCC',SIM(IS)%STATE%NB)
              CALL ERROR$I4VAL('NB_PROJ',NB(IS))
              CALL ERROR$STOP('XAS$READ')
            END IF
!           ALLOCATE STORAGE FOR PROJECTIONS
            ALLOCATE(SIM(IS)%STATE%PROJ(NDIM(IS),NB(IS),SIM(IS)%NPRO))
!           ALLOCATE STORAGE FOR EIGENVALUES
            ALLOCATE(SIM(IS)%STATE%EIG(NB(IS)))
          ENDDO ! END LOOP OVER IS
!         SET POINTER TO SPECIFIC OVERLAP(IKPT,ISPIN)
          OVERLAP=>OVERLAPARR(IKPT,ISPIN)
! WARNING: FIND OUT REQUIRED ORDER OF OVERLAP
!         ALLOCATE STORAGE FOR OVERLAP
          IF(THISTASK.EQ.KMAP(IKPT)) THEN
            ALLOCATE(OVERLAP%PW(NB(2),NB(1)))
          END IF
          IF(THISTASK.EQ.RTASK) THEN
!           READ PLANE WAVE BASIS
            READ(NFIL(1))PSIK1
            READ(NFIL(2))PSIK2
!           READ PROJECTIONS
            READ(NFIL(1))SIM(1)%STATE%PROJ
            READ(NFIL(2))SIM(2)%STATE%PROJ
!           READ EIGENVALUES
            READ(NFIL(1))SIM(1)%STATE%EIG
            READ(NFIL(2))SIM(2)%STATE%EIG
          END IF
          CALL MPE$SENDRECEIVE('~',RTASK,KMAP(IKPT),PSIK1)
          CALL MPE$SENDRECEIVE('~',RTASK,KMAP(IKPT),PSIK2)
          DO IS=1,NSIM
            CALL MPE$SENDRECEIVE('~',RTASK,KMAP(IKPT),SIM(IS)%STATE%PROJ)
            CALL MPE$SENDRECEIVE('~',RTASK,KMAP(IKPT),SIM(IS)%STATE%EIG)
          ENDDO
          CALL TIMING$CLOCKON('XAS$READ_SCALARPRODUCT')
          IF(THISTASK.EQ.KMAP(IKPT)) THEN
            CALL TRACE$I4VAL(' CALCULATING IKPT',IKPT)
            DO IB2=1,NB(2) ! LOOP OVER BANDS
              DO IB1=1,NB(1) ! LOOP OVER BANDS
!               NO NDIM LOOP AS NDIM=1
!               SCALARPRODUCT (SUM OVER G VECTORS)
!               PW(I,J)=<PSI1(J)|PSI2(I)>
! WARNING: CHECK IF SCALARPRODUCT IS CORRECT ALSO WITH CONJG
!          SHOULD BE THE CASE AS CALL OF ZGEMM IS DONE WITH 'C' OPTION
! WARNING: CHECK WILL NOT WORK IF ONLY USING REAL WAVE FUNCTIONS AT GAMMA POINT
                CALL LIB$SCALARPRODUCTC8(.FALSE.,NGG(1),1,PSIK1(:,1,IB1),1,PSIK2(:,1,IB2),OVERLAP%PW(IB2,IB1))
              ENDDO ! END LOOP OVER BANDS
            ENDDO ! END LOOP OVER BANDS
            OVERLAP%PW=OVERLAP%PW*V
          END IF
          CALL TIMING$CLOCKOFF('XAS$READ_SCALARPRODUCT')
        ENDDO ! END LOOP OVER SPIN
        DEALLOCATE(PSIK1)
        DEALLOCATE(PSIK2)
      ENDDO ! END IKPT LOOP OVER K POINTS
                          CALL TRACE$PASS('READING XAS FILE DONE, START DATA DISTRIBUTION')
      CALL TRACE$I4VAL(' NB1',SIM(1)%STATEARR(1,1)%NB)
      CALL TRACE$I4VAL(' NB2',SIM(2)%STATEARR(1,1)%NB)
      TSIM=.TRUE.
                          CALL TIMING$CLOCKOFF('XAS$READ')
                          CALL TRACE$POP
      RETURN

      CONTAINS
        SUBROUTINE TEST!(NSIM,KEY,NGG,NDIM,TSUPER,XK,IGVEC)
        ! INTEGER(4), INTENT(IN) :: NSIM
        ! CHARACTER(8), INTENT(IN) :: KEY(NSIM)
        ! INTEGER(4), INTENT(IN) :: NGG(NSIM)
        ! INTEGER(4), INTENT(IN) :: NDIM(NSIM)
        ! LOGICAL(4), INTENT(IN) :: TSUPER(NSIM)
        ! REAL(8), INTENT(IN) :: XK(NSIM,3)
        ! INTEGER(4), INTENT(IN) :: IGVEC(NSIM,3,NGG(1))
        IF(KEY(1).NE.KEY(2)) THEN
          CALL ERROR$MSG('KEYS NOT THE SAME IN BOTH SIMULATIONS')
          CALL ERROR$I4VAL('IKPT',IKPT)
          CALL ERROR$CHVAL('KEY1',KEY(1))
          CALL ERROR$CHVAL('KEY2',KEY(2))
          CALL ERROR$STOP('XAS$READ')
        END IF
        IF(NGG(1).NE.NGG(2)) THEN
          CALL ERROR$MSG('NGG NOT THE SAME IN BOTH SIMULATIONS')
          CALL ERROR$I4VAL('IKPT',IKPT)
          CALL ERROR$I4VAL('NGG1',NGG(1))
          CALL ERROR$I4VAL('NGG2',NGG(2))
          CALL ERROR$STOP('XAS$READ')
        END IF
        IF(NDIM(1).NE.NDIM(2)) THEN
          CALL ERROR$MSG('NDIM NOT THE SAME IN BOTH SIMULATIONS')
          CALL ERROR$I4VAL('IKPT',IKPT)
          CALL ERROR$I4VAL('NDIM1',NDIM(1))
          CALL ERROR$I4VAL('NDIM2',NDIM(2))
          CALL ERROR$STOP('XAS$READ')
        END IF
! TODO: CHECK NDIM AGAINST PREVIOUSLY READ ONE
        IF(TSUPER(1).NEQV.TSUPER(2)) THEN
          CALL ERROR$MSG('TSUPER NOT THE SAME IN BOTH SIMULATIONS')
          CALL ERROR$I4VAL('IKPT',IKPT)
          CALL ERROR$L4VAL('TSUPER1',TSUPER(1))
          CALL ERROR$L4VAL('TSUPER2',TSUPER(2))
          CALL ERROR$STOP('XAS$READ')
        END IF
!       CHECK IF XK SAME IN BOTH SIMULATIONS
        IF(SUM(ABS(XK(1,:)-XK(2,:)))>TOL) THEN
          CALL ERROR$MSG('XK NOT THE SAME IN BOTH SIMULATIONS')
          CALL ERROR$I4VAL('IKPT',IKPT)
          CALL ERROR$R8VAL('XK1',XK(1,:))
          CALL ERROR$R8VAL('XK2',XK(2,:))
          CALL ERROR$STOP('XAS$READ')
        END IF
!       CHECK IF IGVEC SAME IN BOTH SIMULATIONS
        IF(ANY(IGVEC(1,:,:).NE.IGVEC(2,:,:))) THEN
          CALL ERROR$MSG('IGVEC NOT THE SAME IN BOTH SIMULATIONS')
          CALL ERROR$I4VAL('IKPT',IKPT)
          CALL ERROR$STOP('XAS$READ')
        END IF
        END SUBROUTINE TEST
      END SUBROUTINE XAS$READ
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$REPORTSIMULATION  ! MARK: XAS$REPORTSIMULATION
!     **************************************************************************
!     ** REPORT DATA FOR A SELECTED SIMULATION                                **
!     **************************************************************************
      USE XAS_MODULE, ONLY: THIS,SELECTED,S,OVERLAP,OVERLAPARR,RTASK
      IMPLICIT NONE
      INTEGER(4) :: NFIL
! TODO: REMOVE HARDCODED OUTPUT
      integer(4) :: nfilo=11
      integer(4) :: nfilc=12
      INTEGER(4) :: NB1,NB2
      INTEGER(4) :: IAT,ISP,ISPIN,IKPT,IPRO,IB
      CHARACTER(256) :: FORMAT
      REAL(8) :: EV
      INTEGER(4) :: NTASKS,THISTASK
!     **************************************************************************
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      IF(THISTASK.NE.RTASK) RETURN
                          CALL TRACE$PUSH('XAS$REPORTSIMULATION')
      CALL CONSTANTS('EV',EV)
      CALL FILEHANDLER$UNIT('PROT',NFIL)
      IF(SELECTED) THEN
        WRITE(NFIL,'(80("#"))')
        WRITE(NFIL,FMT='(A14,A14)')'SIMULATION',THIS%ID
        WRITE(NFIL,'(80("#"))')
        WRITE(NFIL,FMT='(A10,A)')'FILE:',TRIM(THIS%FILE)
        WRITE(NFIL,FMT='(A10,I10)')'NAT:',THIS%NAT
        WRITE(NFIL,FMT='(A10,I10)')'NSP:',THIS%NSP
        WRITE(NFIL,FMT='(A10,I10)')'NKPT:',THIS%NKPT
        WRITE(NFIL,FMT='(A10,I10)')'NSPIN:',THIS%NSPIN
        WRITE(NFIL,FMT='(A10,I10)')'NDIM:',THIS%NDIM
        WRITE(NFIL,FMT='(A10,I10)')'NPRO:',THIS%NPRO
        WRITE(NFIL,FMT='(A10,I10)')'LNXX:',THIS%LNXX
        WRITE(NFIL,FMT='(A10,L10)')'TINV:',THIS%TINV
        WRITE(NFIL,FMT='(A10,3I10)')'NKDIV:',THIS%NKDIV(:)
        WRITE(NFIL,FMT='(A10,3I10)')'ISHIFT:',THIS%ISHIFT(:)
        WRITE(NFIL,FMT='(A10,F10.4)')'RNTOT:',THIS%RNTOT
        WRITE(NFIL,FMT='(A10,F10.4)')'NEL:',THIS%NEL
        WRITE(NFIL,FMT='(A10,F10.4)')'ETOT [EV]:',THIS%ETOT/EV
        WRITE(NFIL,FMT='(A10,F10.4)')'EDFT [EV]:',THIS%EDFT/EV
        WRITE(NFIL,FMT='(A10,F10.4)')'ECORE [EV]:',THIS%ECORE/EV
        WRITE(NFIL,FMT='(A10,I10)')'SPACEGR.:',THIS%SPACEGROUP
        WRITE(NFIL,FMT='(A10,L10)')'TSHIFT:',THIS%TSHIFT
        WRITE(NFIL,FMT='(A10,3F10.4)')'RBAS:',THIS%RBAS(:,1)
        DO IAT=2,3
          WRITE(NFIL,FMT='(A10,3F10.4)')' ',THIS%RBAS(:,IAT)
        ENDDO
        WRITE(NFIL,FMT='(5A10)')'ATOM','X','Y','Z','SPECIES'
        DO IAT=1,THIS%NAT
          WRITE(NFIL,FMT='(A10,3F10.4,I10)')THIS%ATOMID(IAT),THIS%R(:,IAT),THIS%ISPECIES(IAT)
        ENDDO
        WRITE(NFIL,FMT='(5A10)')'SETUP','GID','ECORE[H]','LNX','LOX'
        IF(THIS%LNXX.GT.9) THEN
          WRITE(FORMAT,'("(2I10,F10.4,I10,",I2,"I10)")')THIS%LNXX
        ELSE
          WRITE(FORMAT,'("(2I10,F10.4,I10,",I1,"I10)")')THIS%LNXX
        END IF
        DO ISP=1,THIS%NSP
          WRITE(NFIL,FMT=FORMAT)ISP,THIS%SETUP(ISP)%GID,THIS%SETUP(ISP)%ECORE, &
     &                          THIS%LNX(ISP),THIS%LOX(:,ISP)
        ENDDO
        WRITE(NFIL,FMT='(A)')'MAPPING OF PROJECTIONS (INDEX-1)'
        WRITE(NFIL,FMT='(A10,A10)')'ATOM','MAP'
        IF(THIS%LNXX.GT.9) THEN
          WRITE(FORMAT,'("(I10,",I2,"I10)")')THIS%LNXX
        ELSE
          WRITE(FORMAT,'("(I10,",I1,"I10)")')THIS%LNXX
        END IF
        DO IAT=1,THIS%NAT
          WRITE(NFIL,FMT=FORMAT)IAT,THIS%MAP(IAT,:)
        ENDDO
        WRITE(NFIL,FMT='(A)')'RADIAL REPORT'
        CALL RADIAL$REPORT(NFIL)
        WRITE(NFIL,FMT='(8A10)')'IKPT','ISPIN','XK1','XK2','XK3', &
&                               'WKPT','NB','NOCC'
        DO IKPT=1,THIS%NKPT
          DO ISPIN=1,THIS%NSPIN
            THIS%STATE=>THIS%STATEARR(IKPT,ISPIN)
            WRITE(NFIL,FMT='(2I10,4F10.6,2I10)')IKPT,ISPIN,THIS%XK(:,IKPT), &
&                                  THIS%WKPT(IKPT),THIS%STATE%NB,THIS%STATE%NOCC
          ENDDO
        ENDDO
      ELSE
        WRITE(*,*) 'NO OUTPUT FOR GENERAL INFORMATION IMPLEMENTED'
!         WRITE(NFIL,'(80("#"))')
!         WRITE(NFIL,FMT='(A19)')'GENERAL INFORMATION'
!         WRITE(NFIL,'(80("#"))')
!         CALL XAS$SELECT('EXCITESTATE')
!         NB2=THIS%STATE%NB
!         IF(THIS%LNXX.GT.9) THEN
!           WRITE(FORMAT,'("(",I2,"F10.4)")')THIS%LNXX
!         ELSE
!           WRITE(FORMAT,'("(",I1,"F10.4)")')THIS%LNXX
!         END IF
!         CALL XAS$UNSELECT
!         CALL XAS$SELECT('GROUNDSTATE')
!         NB1=THIS%STATE%NB
!         WRITE(NFIL,FMT='(A)')'ATOMIC OVERLAP MATRIX S'
!         DO IAT=1,THIS%NAT
!           WRITE(NFIL,FMT='(A10,I10)')'ATOM',IAT
!           DO IPRO=1,THIS%LNXX
!             WRITE(NFIL,FMT=FORMAT)S(IAT,IPRO,:)
!           ENDDO
!         ENDDO
! ! TODO: PROPER OUTPUT FOR OVERLAP MATRIX
!         OVERLAP=>OVERLAPARR(1,1)
!         IF(NB1.GT.99) THEN
!           WRITE(FORMAT,'("(",I3,"F10.6)")')NB1
!         ELSE IF(NB1.GT.9.AND.NB1.LT.100) THEN
!           WRITE(FORMAT,'("(",I2,"F10.6)")')NB1
!         ELSE
!           WRITE(FORMAT,'("(",I1,"F10.6)")')NB1
!         END IF
!         open(nfilo,file='pw.dat')
!         open(nfilc,file='pw_c.dat')
!         WRITE(NFIL,FMT='(A)')'PLANE WAVE OVERLAP MATRIX OF FIRST K POINT/SPIN'
!         DO IB=1,NB2
!           WRITE(NFIL,FMT=FORMAT)CDABS(OVERLAP%PW(IB,:))
!           WRITE(nfilo,FMT=FORMAT)CDABS(OVERLAP%PW(IB,:))
!           write(nfilc,*)OVERLAP%PW(IB,:)
!         ENDDO
!         close(nfilo)
!         close(nfilc)
!         open(nfilo,file='aug.dat')
!         open(nfilc,file='aug_c.dat')
!         WRITE(NFIL,FMT='(A)')'AUGMENTATION OVERLAP MATRIX OF FIRST K POINT/SPIN'
!         DO IB=1,NB2
!           WRITE(NFIL,FMT=FORMAT)CDABS(OVERLAP%AUG(IB,:))
!           WRITE(nfilo,FMT=FORMAT)CDABS(OVERLAP%AUG(IB,:))
!           write(nfilc,*)OVERLAP%AUG(IB,:)
!         ENDDO
!         close(nfilo)
!         close(nfilc)
!         WRITE(NFIL,FMT='(A)')'OVERLAP MATRIX OF FIRST K POINT/SPIN'
!         open(nfilo,file='ov.dat')
!         open(nfilc,file='ov_c.dat')
!         DO IB=1,NB2
!           WRITE(NFIL,FMT=FORMAT)CDABS(OVERLAP%OV(IB,:))
!           WRITE(nfilo,FMT=FORMAT)CDABS(OVERLAP%OV(IB,:))
!           write(nfilc,*)OVERLAP%OV(IB,:)
!         ENDDO
!         close(nfilo)
!         close(nfilc)
!         WRITE(NFIL,FMT='(A)')'OCCUPIED OVERLAP OF FIRST K POINT/SPIN'
!         DO IB=1,THIS%STATEARR(1,1)%NOCC
!           WRITE(NFIL,FMT=FORMAT)CDABS(OVERLAP%OVOCC(IB,:))
!         ENDDO
!         WRITE(NFIL,FMT='(A)')'EMPTY OVERLAP OF FIRST K POINT/SPIN'
!         DO IB=1,NB2-THIS%STATEARR(1,1)%NOCC
!           WRITE(NFIL,FMT=FORMAT)CDABS(OVERLAP%OVEMP(IB,:))
!         ENDDO
!         WRITE(NFIL,FMT='(A)')'KMAT OF FIRST K POINT/SPIN'
!         DO IB=1,NB2-THIS%STATEARR(1,1)%NOCC
!           WRITE(NFIL,FMT=FORMAT)CDABS(OVERLAP%KMAT(IB,:))
!         ENDDO
! ! TODO: OUTPUT FOR DIPOLE ELEMENTS
!         CALL XAS$UNSELECT
      END IF
                          CALL TRACE$POP
      END SUBROUTINE XAS$REPORTSIMULATION
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$REPORTSETTINGS  ! MARK: XAS$REPORTSETTINGS
!     **************************************************************************
!     ** REPORT SETTINGS FOR XAS CALCULATION                                  **
!     **************************************************************************
      USE XAS_MODULE, ONLY: SETTINGS,SPECTRUM,SPECTRUMARR,OUTPUT,TRSTRT
      USE STRINGS_MODULE
      IMPLICIT NONE
      INTEGER(4) :: NFIL
      INTEGER(4) :: ISPEC
      REAL(8) :: EV
      INTEGER(4) :: NTASKS,THISTASK
!     **************************************************************************
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      IF(THISTASK.NE.1) RETURN
                          CALL TRACE$PUSH('XAS$REPORTSETTINGS')
      CALL CONSTANTS('EV',EV)
      CALL FILEHANDLER$UNIT('PROT',NFIL)
      WRITE(NFIL,'(80("#"))')
      WRITE(NFIL,FMT='(A19)')'SETTINGS'
      WRITE(NFIL,'(80("#"))')
      WRITE(NFIL,FMT='(A10,I10)')'NSPECTRA:',SETTINGS%NSPEC
!     DATA NOT AVAILABLE FROM RESTART FILE
      IF(.NOT.TRSTRT) THEN
        WRITE(NFIL,FMT='(A10,A)')'HOLE ATOM:',TRIM(SETTINGS%ATOM)
        WRITE(NFIL,FMT='(A10,I10)')'IND1 ATOM:',SETTINGS%IATOM
        WRITE(NFIL,FMT='(A10,I10)')'NCORE:',SETTINGS%NCORE
        WRITE(NFIL,FMT='(A10,I10)')'LCORE:',SETTINGS%LCORE
      END IF
      WRITE(NFIL,FMT='(A10,F10.6)')'DE:',SETTINGS%DE/EV
      WRITE(NFIL,FMT='(A10,F20.10)')'EMIN:',SETTINGS%EMIN/EV
      WRITE(NFIL,FMT='(A10,F20.10)')'EMAX:',SETTINGS%EMAX/EV
      WRITE(NFIL,FMT='(A10,F10.6)')'GAMMA:',SETTINGS%GAMMA/EV
      DO ISPEC=1,SETTINGS%NSPEC
        SPECTRUM=>SPECTRUMARR(ISPEC)
        WRITE(NFIL,'(80("#"))')
        WRITE(NFIL,FMT='(A10,I10)')'SPECTRUM:',ISPEC
        WRITE(NFIL,FMT='(A10,A)')'FILE:',TRIM(ADJUSTL(SPECTRUM%FILE))
        IF(.NOT.SPECTRUM%TPOLXYZ) THEN
          WRITE(NFIL,FMT='(A10,3F10.4)')'NORMAL:',SPECTRUM%NORMAL(:)
          WRITE(NFIL,FMT='(A10,3F10.4)')'KDIR:',SPECTRUM%KDIR(:)
          WRITE(NFIL,FMT=-'(A10,2(F8.5,SP,F8.5,"I ",S))')'POL:',SPECTRUM%POL(:)
        END IF
        WRITE(NFIL,FMT=-'(A10,3(F8.5,SP,F8.5,"I ",S))')'POLXYZ:',SPECTRUM%POLXYZ(:)
      ENDDO
      WRITE(NFIL,'(80("#"))')
      WRITE(NFIL,FMT='(A19)')'OUTPUT'
      WRITE(NFIL,'(80("#"))')
      WRITE(NFIL,FMT='(A10,L10)')'OVL:',OUTPUT%TOVL
      WRITE(NFIL,FMT='(A10,L10)')'OVLPW:',OUTPUT%TOVLPW
      WRITE(NFIL,FMT='(A10,L10)')'OVLAUG:',OUTPUT%TOVLAUG
      WRITE(NFIL,FMT='(A10,L10)')'OVLOCC:',OUTPUT%TOVLOCC
      WRITE(NFIL,FMT='(A10,L10)')'OVLEMP:',OUTPUT%TOVLEMP
      WRITE(NFIL,FMT='(A10,L10)')'KMAT:',OUTPUT%TKMAT
      WRITE(NFIL,FMT='(A10,L10)')'DIPOLE:',OUTPUT%TDIPOLE
      WRITE(NFIL,FMT='(A10,L10)')'ADET:',OUTPUT%TADET
                          CALL TRACE$POP
      END SUBROUTINE XAS$REPORTSETTINGS
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$AMPL(IKPT,ISPIN,IEMP,AMPL)  ! MARK: XAS$AMPL
!     **************************************************************************
!     ** CALCULATE TRANSITION AMPLITUDE FOR A GIVEN FINAL STATE (IKPT,ISPIN,F)**
!     ** THREE COMPONENTS ARE FOR THE THREE CARTESIAN DIRECTIONS              **
!     **************************************************************************
      USE XAS_MODULE, ONLY: SIM,STATE_TYPE,OVERLAP,OVERLAPARR
      IMPLICIT NONE
!     REDUCE CALCULATION TO SINGLE PARTICLE SPECTRUM
      LOGICAL(4), PARAMETER :: SINGLEPARTICLE=.FALSE.
      INTEGER(4), INTENT(IN) :: IKPT ! K POINT INDEX
      INTEGER(4), INTENT(IN) :: ISPIN ! SPIN INDEX
      INTEGER(4), INTENT(IN) :: IEMP ! FINAL STATE ORBITAL INDEX WITHIN UNOCCUPIED
      COMPLEX(8), INTENT(OUT) :: AMPL(3) ! TRANSITION AMPLITUDE
      INTEGER(4) :: IFINAL ! INDEX FOR FINAL STATE WITHIN ALL STATES
      TYPE(STATE_TYPE), POINTER :: STATE
      INTEGER(4) :: IB
!     **************************************************************************
      STATE=>SIM(2)%STATEARR(IKPT,ISPIN)
      OVERLAP=>OVERLAPARR(IKPT,ISPIN)
      IFINAL=IEMP+STATE%NOCC
!     CHECK IF FINAL STATE ORBITAL INDEX IS VALID
      IF(IFINAL.GT.STATE%NB) THEN
        CALL ERROR$MSG('FINAL STATE ORBITAL INDEX OUT OF BOUNDS')
        CALL ERROR$I4VAL('IEMP',IEMP)
        CALL ERROR$I4VAL('NB',STATE%NB)
        CALL ERROR$STOP('XAS$AMPL')
      END IF
      IF(IFINAL.LE.STATE%NOCC) THEN
        CALL ERROR$MSG('FINAL STATE ORBITAL INDEX OCCUPIED')
        CALL ERROR$I4VAL('IEMP',IEMP)
        CALL ERROR$I4VAL('NOCC',STATE%NOCC)
        CALL ERROR$STOP('XAS$AMPL')
      END IF
      AMPL=(0.D0,0.D0)
! WARNING: CHECK INDICES
      DO IB=1,STATE%NOCC
        AMPL(:)=AMPL(:)+CONJG(OVERLAP%KMAT(IEMP,IB))*OVERLAP%DIPOLE(:,IB)
      ENDDO
      AMPL(:)=OVERLAP%DIPOLE(:,IFINAL)-AMPL(:)
      AMPL(:)=(-1.D0)**STATE%NOCC*AMPL(:)*CONJG(OVERLAP%ADET)
      IF(SINGLEPARTICLE) AMPL(:)=OVERLAP%DIPOLE(:,IFINAL)
      RETURN
      END SUBROUTINE XAS$AMPL
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$CROSSSECTION  ! MARK: XAS$CROSSSECTION
!     **************************************************************************
!     ** CALCULATE XAS CROSS SECTION                                          **
!     **************************************************************************
      USE XAS_MODULE, ONLY: SPECTRUM,SPECTRUMARR,SETTINGS,SIM,STATE_TYPE, &
&                           KMAP,NKPTG,RTASK
      USE MPE_MODULE
      IMPLICIT NONE
      INTEGER(4) :: NFIL
      INTEGER(4) :: ISPEC
      INTEGER(4) :: IKPT
      INTEGER(4) :: ISPIN
      INTEGER(4) :: IFINAL
      TYPE(STATE_TYPE), POINTER :: STATE
      COMPLEX(8) :: AMPL(3)
      COMPLEX(8) :: CVAR
      INTEGER(4) :: NB,NOCC
      REAL(8) :: SIGMA
      REAL(8) :: EGROUND,EEXCITE  ! TOTAL ENERGY OF CALCULATION
      REAL(8) :: EF
      REAL(8) :: DEATOM  ! ENERGY DIFFERENCE OF SUM OF ISOLATED ATOMS
      REAL(8) :: EV
      REAL(8) :: EMIN,EMAX
      REAL(8) :: E
      INTEGER(4) :: NE
      INTEGER(4) :: I
      REAL(8), ALLOCATABLE :: X(:)
      REAL(8), ALLOCATABLE :: Y(:)
      REAL(8), ALLOCATABLE :: YCONV(:)
      INTEGER(4) :: NTASKS,THISTASK
!     **************************************************************************
                          CALL TRACE$PUSH('XAS$CROSSSECTION')
                          CALL TIMING$CLOCKON('XAS$CROSSSECTION')
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      EMIN=HUGE(EMIN)
      EMAX=-HUGE(EMAX)
      CALL CONSTANTS('EV',EV)
      EGROUND=SIM(1)%ETOT
      EEXCITE=SIM(2)%ETOT
! WARNING: ALIGNMENT OF ENERGIES NECESSARY?
!       CALL XAS_ATOMENERGYDIFF(DEATOM)
! write(*,*) 'DEATOM',DEATOM
! write(*,*) 'EGROUND',EGROUND
! write(*,*) 'EEXCITE',EEXCITE
!     AUTOMATICALLY FIND ENERGY RANGE (ONLY RTASK HAS ALL ENERGIES)
      IF(THISTASK.EQ.RTASK) THEN
        DO IKPT=1,SIM(1)%NKPT
          DO ISPIN=1,SIM(1)%NSPIN
            STATE=>SIM(2)%STATEARR(IKPT,ISPIN)
            DO IFINAL=1,STATE%NB-STATE%NOCC
              EF=EEXCITE+STATE%EIG(IFINAL+STATE%NOCC)
              E=EF-EGROUND!+DEATOM
              IF(E.LT.EMIN) EMIN=E
              IF(E.GT.EMAX) EMAX=E
            ENDDO
          ENDDO
        ENDDO
        STATE=>SIM(2)%STATEARR(1,1)
        NB=STATE%NB
        NOCC=STATE%NOCC
      END IF
      CALL MPE$BROADCAST('~',RTASK,EMIN)
      CALL MPE$BROADCAST('~',RTASK,EMAX)
      CALL MPE$BROADCAST('~',RTASK,NB)
      CALL MPE$BROADCAST('~',RTASK,NOCC)
!     WARNING: ENERGY RANGE EXTENDED BY 2 EV
      EMIN=EMIN-2.D0*EV
      EMAX=EMAX+2.D0*EV
      NE=INT((EMAX-EMIN)/SETTINGS%DE)+1
      SETTINGS%EMIN=EMIN
      SETTINGS%EMAX=EMAX
      SETTINGS%NE=NE

      DO ISPEC=1,SETTINGS%NSPEC
        SPECTRUM=>SPECTRUMARR(ISPEC)
        ALLOCATE(SPECTRUM%E(NE))
        ALLOCATE(SPECTRUM%I(SIM(2)%NKPT,SIM(2)%NSPIN,NE))
        SPECTRUM%I(:,:,:)=0.D0
! ERROR: ALLOCATION OF SPECTRUM%ERAW AND SPECTRUM%IRAW CAN BE WRONG IF NB OR 
!        NOCC ARE NOT THE SAME FOR ALL K POINTS
        ALLOCATE(SPECTRUM%ERAW(SIM(2)%NKPT,SIM(2)%NSPIN,NB-NOCC))
        SPECTRUM%ERAW(:,:,:)=0.D0
        ALLOCATE(SPECTRUM%IRAW(SIM(2)%NKPT,SIM(2)%NSPIN,NB-NOCC))
        SPECTRUM%IRAW(:,:,:)=0.D0
        SPECTRUM%I(:,:,:)=0.D0
        DO I=1,NE
          SPECTRUM%E(I)=EMIN+REAL(I-1,KIND=8)*SETTINGS%DE
        ENDDO
      ENDDO

! TODO: METHOD FOR PROPER ENERGY ALIGNMENT
! TODO: CLEANUP
      CALL TRACE$PASS('XAS$CROSSSECTION LOOP')
!     LOOP OVER K POINTS
      DO IKPT=1,SIM(1)%NKPT
        IF(KMAP(IKPT).NE.THISTASK) CYCLE
        CALL TRACE$I4VAL(' IKPT',IKPT)
!       LOOP OVER SPIN
        DO ISPIN=1,SIM(1)%NSPIN
          STATE=>SIM(2)%STATEARR(IKPT,ISPIN)
          DO IFINAL=1,STATE%NB-STATE%NOCC
! TODO: CHECK IMPLEMENTATION WEIGHT OF K POINT AND ROLE OF INVERSION SYMMETRY
            CALL XAS$AMPL(IKPT,ISPIN,IFINAL,AMPL)
            EF=EEXCITE+STATE%EIG(IFINAL+STATE%NOCC)
            E=EF-EGROUND!+DEATOM
!           LOOP OVER SPECTRA
            DO ISPEC=1,SETTINGS%NSPEC
              SPECTRUM=>SPECTRUMARR(ISPEC)
              CVAR=DOT_PRODUCT(SPECTRUM%POLXYZ,AMPL)
!             ABSOLUTE SQUARE AND WEIGHT OF K POINT
              SIGMA=SIM(1)%WKPT(IKPT)*REAL(CONJG(CVAR)*CVAR,KIND=8)
              SPECTRUM%ERAW(IKPT,ISPIN,IFINAL)=E
              SPECTRUM%IRAW(IKPT,ISPIN,IFINAL)=SIGMA
              CALL XAS$MAPGRID(E,SIGMA,NE,SPECTRUM%I(IKPT,ISPIN,:), &
       &                       EMIN,EMAX,SETTINGS%DE)
            ENDDO
          ENDDO
        ENDDO
      ENDDO
      
      DO ISPEC=1,SETTINGS%NSPEC
        SPECTRUM=>SPECTRUMARR(ISPEC)
        CALL MPE$COMBINE('~','+',SPECTRUM%I)
        CALL MPE$COMBINE('~','+',SPECTRUM%ERAW)
        CALL MPE$COMBINE('~','+',SPECTRUM%IRAW)
        DO IKPT=1,SIM(2)%NKPT
          DO ISPIN=1,SIM(2)%NSPIN
            ! CALL LORENTZCONV(NE,SPECTRUM%E,SPECTRUM%I(IKPT,ISPIN,:),SETTINGS%GAMMA)
            CALL GAUSSCONV(NE,SPECTRUM%E,SPECTRUM%I(IKPT,ISPIN,:),SETTINGS%GAMMA)
          ENDDO
        ENDDO
      ENDDO
                          CALL TIMING$CLOCKOFF('XAS$CROSSSECTION')
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE XAS$CROSSSECTION
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$OVERLAP  ! MARK: XAS$OVERLAP
!     **************************************************************************
!     ** CALCULATE OVERLAP MATRIX                                             **
!     **************************************************************************
      USE XAS_MODULE, ONLY: S,OVERLAP,OVERLAPARR,SIM,STATE_TYPE,TOVERLAP,TRSTRT, &
&                           KMAP,NKPTG
      IMPLICIT NONE
      LOGICAL(4), PARAMETER :: TTEST=.TRUE. ! TEST EIGENVALUES OF OVERLAP
      TYPE(STATE_TYPE), POINTER :: STATE1,STATE2
      INTEGER(4) :: NKPT,NSPIN
      INTEGER(4) :: IKPT,ISPIN
      INTEGER(4) :: NOCC
      INTEGER(4) :: NTASKS,THISTASK
!     **************************************************************************
                          CALL TRACE$PUSH('XAS$OVERLAP')
                          CALL TIMING$CLOCKON('XAS$OVERLAP')
      CALL MPE$QUERY('~',NTASKS,THISTASK)
!     CALCULATION UF AUGMENTATION MATRIX NOT NECESSARY WITH RESTART FILE
      IF(.NOT.TRSTRT) THEN
        IF(ALLOCATED(S)) THEN
          CALL ERROR$MSG('ATOMIC OVERLAP MATRIX ALREADY CALCULATED')
          CALL ERROR$STOP('XAS$OVERLAP')
        END IF
        IF(.NOT.ALLOCATED(OVERLAPARR)) THEN
          CALL ERROR$MSG('PLANE WAVE OVERLAP MATRIX NOT AVAILABLE')
          CALL ERROR$MSG('SHOULD BE CALCULATED ON READ')
          CALL ERROR$MSG('USE XAS$READ TO READ DATA')
          CALL ERROR$STOP('XAS$OVERLAP')
        END IF
        CALL XAS$OVERLAPATOMMATRIX

        CALL XAS$OVERLAPAUGMENTATION
      END IF

      NKPT=NKPTG
      NSPIN=SIM(1)%NSPIN
      DO IKPT=1,NKPT
        IF(KMAP(IKPT).NE.THISTASK) CYCLE
        DO ISPIN=1,NSPIN
          OVERLAP=>OVERLAPARR(IKPT,ISPIN)
          STATE1=>SIM(1)%STATEARR(IKPT,ISPIN)
          STATE2=>SIM(2)%STATEARR(IKPT,ISPIN)
          ALLOCATE(OVERLAP%OV(STATE2%NB,STATE1%NB))
          OVERLAP%OV(:,:)=OVERLAP%PW(:,:)+OVERLAP%AUG(:,:)
!         CHECK OF NUMBER OF OCCUPIED STATES IS THE SAME TO PRODUCE SQUARE MATRIX
          IF(STATE1%NOCC.NE.STATE2%NOCC) THEN
            CALL ERROR$MSG('NUMBER OF OCCUPIED STATES NOT THE SAME')
            CALL ERROR$MSG('HAS NUMBER OF ELECTRONS CHANGED OR VARIABLE OCCUPATIONS?')
            CALL ERROR$I4VAL('NOCC1',STATE1%NOCC)
            CALL ERROR$I4VAL('NOCC2',STATE2%NOCC)
            CALL ERROR$I4VAL('IKPT',IKPT)
            CALL ERROR$I4VAL('ISPIN',ISPIN)
            CALL ERROR$STOP('XAS$OVERLAP')
          END IF
          NOCC=STATE1%NOCC
          ALLOCATE(OVERLAP%OVOCC(NOCC,NOCC))
          ALLOCATE(OVERLAP%OVEMP(STATE2%NB-NOCC,NOCC))
          OVERLAP%OVOCC(:,:)=OVERLAP%OV(1:NOCC,1:NOCC)
          OVERLAP%OVEMP(:,:)=OVERLAP%OV(NOCC+1:STATE2%NB,1:NOCC)
        ENDDO
      ENDDO  
      TOVERLAP=.TRUE.  
                          CALL TIMING$CLOCKOFF('XAS$OVERLAP')
                          CALL TRACE$POP
      END SUBROUTINE XAS$OVERLAP
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$OVERLAPAUGMENTATION  ! MARK: XAS$OVERLAPAUGMENTATION
!     **************************************************************************
!     ** OVERLAP CONTRIBUTION FROM PAW AUGMENTATION                           **
!     **************************************************************************
      USE XAS_MODULE, ONLY: S,OVERLAP,OVERLAPARR,SIM,STATE_TYPE,NKPTG,KMAP,RTASK
      USE MPE_MODULE
      IMPLICIT NONE
      TYPE(STATE_TYPE), POINTER :: STATE1,STATE2
      INTEGER(4) :: NKPT,NSPIN
      INTEGER(4) :: IKPT,ISPIN
      INTEGER(4) :: IB1,IB2
      INTEGER(4) :: IPRO1,IPRO2
      COMPLEX(8) :: CVAR
      INTEGER(4) :: NTASKS,THISTASK
      INTEGER(4) :: ICOUNT
      INTEGER(4) :: WTASK
!     **************************************************************************
                          CALL TRACE$PUSH('XAS$OVERLAPAUGMENTATION')
                          CALL TIMING$CLOCKON('XAS$OVERLAPAUGMENTATION')
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      NKPT=NKPTG
      NSPIN=SIM(1)%NSPIN
  !   LOOP OVER K POINTS
      DO IKPT=1,NKPT
        IF(THISTASK.NE.KMAP(IKPT)) CYCLE
        CALL TRACE$I4VAL(' IKPT',IKPT)
  !     LOOP OVER SPIN
        DO ISPIN=1,NSPIN
          STATE1=>SIM(1)%STATEARR(IKPT,ISPIN)
          STATE2=>SIM(2)%STATEARR(IKPT,ISPIN)
          OVERLAP=>OVERLAPARR(IKPT,ISPIN)
          ALLOCATE(OVERLAP%AUG(STATE2%NB,STATE1%NB))
          OVERLAP%AUG(:,:)=(0.D0,0.D0)
  !       LOOP OVER BANDS OF FIRST SIMULATION
          DO IB2=1,STATE2%NB
  !         LOOP OVER BANDS OF SECOND SIMULATION
            DO IB1=1,STATE1%NB
              CALL XAS$OVERLAPSTATE(STATE1,IB1,STATE2,IB2,CVAR)
!             AUG(I,J)=<PSI1(J)|PSI2(I)>
              OVERLAP%AUG(IB2,IB1)=CVAR
            ENDDO ! END LOOP OVER BANDS OF SECOND SIMULATION
          ENDDO ! END LOOP OVER BANDS OF FIRST SIMULATION
        ENDDO ! END LOOP OVER SPIN
      ENDDO ! END LOOP OVER K POINTS
                          CALL TIMING$CLOCKOFF('XAS$OVERLAPAUGMENTATION')
                          CALL TRACE$POP
      END SUBROUTINE XAS$OVERLAPAUGMENTATION
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$OVERLAPSTATE(STATE1,NB1,STATE2,NB2,OVLAP)  ! MARK: XAS$OVERLAPSTATE
!     **************************************************************************
!     ** CALCULATE ATOMIC OVERLAP BETWEEN TWO STATES                          **
!     ** <STATE1|STATE2>                                                      **
!     **************************************************************************
      USE XAS_MODULE, ONLY: STATE_TYPE,S,SIM,ATOMMAP
      IMPLICIT NONE
      TYPE(STATE_TYPE), INTENT(IN) :: STATE1
      INTEGER(4), INTENT(IN) :: NB1
      TYPE(STATE_TYPE), INTENT(IN) :: STATE2
      INTEGER(4), INTENT(IN) :: NB2
      COMPLEX(8), INTENT(OUT) :: OVLAP
      INTEGER(4) :: IAT1,IAT2
      INTEGER(4) :: ISP1,ISP2
      INTEGER(4) :: LN1,LN2
      INTEGER(4) :: IPRO1,IPRO2
      INTEGER(4) :: L1,L2
      INTEGER(4) :: M1,M2
      COMPLEX(8) :: CVAR
!     **************************************************************************
      OVLAP=(0.D0,0.D0)
      DO IAT1=1,SIM(1)%NAT
        ISP1=SIM(1)%ISPECIES(IAT1)
        IAT2=ATOMMAP(IAT1)
        ISP2=SIM(2)%ISPECIES(IAT2)
        DO LN1=1,SIM(1)%LNX(ISP1)
          DO LN2=1,SIM(2)%LNX(ISP2)
            L1=SIM(1)%LOX(LN1,ISP1)
            L2=SIM(2)%LOX(LN2,ISP2)
            IF(L1.NE.L2) CYCLE
            IPRO1=SIM(1)%MAP(IAT1,LN1)
            DO M1=1,2*L1+1
              IPRO1=IPRO1+1
              IPRO2=SIM(2)%MAP(IAT2,LN2)
              DO M2=1,2*L2+1
                IPRO2=IPRO2+1
                IF(M1.NE.M2) CYCLE
                CVAR=CONJG(STATE1%PROJ(1,NB1,IPRO1))*STATE2%PROJ(1,NB2,IPRO2)
                OVLAP=OVLAP+CVAR*S(IAT1,LN1,LN2)
              ENDDO
            ENDDO
          ENDDO
        ENDDO
      END DO
      END SUBROUTINE XAS$OVERLAPSTATE
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$OVERLAPATOMMATRIX  ! MARK: XAS$OVERLAPATOMMATRIX
!     **************************************************************************
!     ** CALCULATE ATOMIC OVERLAP MATRIX                                      **
!     ** REAL SPHERICAL HARMONICS GIVE L1=L2 AND M1=M2                        **
!     ** ONLY CALCULATE FOR ONE ARBITRARY M1=M2 AS RESULT IS THE SAME WITHIN  **
!     ** THE SAME L-SHELL; M1=M2 MUST BE ENSURED ELSEWHERE                    **
!     **************************************************************************
      USE XAS_MODULE, ONLY: SIM,S,ATOMMAP
      IMPLICIT NONE
      INTEGER(4) :: IAT1,IAT2
      INTEGER(4) :: ISP1,ISP2
      INTEGER(4) :: LN1,LN2
      INTEGER(4) :: L1,L2
      REAL(8) :: SVAL
      INTEGER(4),ALLOCATABLE :: IATMAP1(:),IATMAP2(:)
      REAL(8), ALLOCATABLE :: PSPHI1(:),PSPHI2(:)
      REAL(8), ALLOCATABLE :: AEPHI1(:),AEPHI2(:)
      REAL(8), ALLOCATABLE :: AUX(:)
      REAL(8), ALLOCATABLE :: R(:)
      INTEGER(4) :: NR1,NR2
      INTEGER(4) :: GID1,GID2
!     **************************************************************************
                          CALL TRACE$PUSH('XAS$OVERLAPATOMMATRIX')
      ALLOCATE(S(SIM(1)%NAT,SIM(1)%LNXX,SIM(2)%LNXX))
      S=0.D0
      DO IAT1=1,SIM(1)%NAT
        ISP1=SIM(1)%ISPECIES(IAT1)
        GID1=SIM(1)%SETUP(ISP1)%GID
        CALL RADIAL$GETI4(GID1,'NR',NR1)
        ALLOCATE(PSPHI1(NR1))
        ALLOCATE(AEPHI1(NR1))
        ALLOCATE(PSPHI2(NR1))
        ALLOCATE(AEPHI2(NR1))
        ALLOCATE(AUX(NR1))
        ALLOCATE(R(NR1))
        CALL RADIAL$R(GID1,NR1,R)

        DO LN1=1,SIM(1)%LNX(ISP1)
          L1=SIM(1)%LOX(LN1,ISP1)
          IAT2=ATOMMAP(IAT1)
          ISP2=SIM(2)%ISPECIES(IAT2)
          GID2=SIM(2)%SETUP(ISP2)%GID
          CALL RADIAL$GETI4(GID2,'NR',NR2)

          DO LN2=1,SIM(2)%LNX(ISP2)
            L2=SIM(2)%LOX(LN2,ISP2)
            IF(L1.NE.L2) CYCLE
!           GET RADIAL FUNCTIONS
            PSPHI1=SIM(1)%SETUP(ISP1)%PSPHI(:,LN1)
            AEPHI1=SIM(1)%SETUP(ISP1)%AEPHI(:,LN1)  
!           IF GRIDS ARE DIFFERENT, MAP ONTO FIRST GRID   
            IF(GID1.NE.GID2) THEN
              CALL RADIAL$CHANGEGRID(GID2,NR2,SIM(2)%SETUP(ISP2)%PSPHI(:,LN2), &
     &                               GID1,NR1,PSPHI2)
              CALL RADIAL$CHANGEGRID(GID2,NR2,SIM(2)%SETUP(ISP2)%AEPHI(:,LN2), &
     &                               GID1,NR1,AEPHI2)
            ELSE
              PSPHI2=SIM(2)%SETUP(ISP2)%PSPHI(:,LN2)
              AEPHI2=SIM(2)%SETUP(ISP2)%AEPHI(:,LN2)
            END IF
! TODO: CHECK IF ORDER IS CORRECT
            AUX=AEPHI1*AEPHI2-PSPHI1*PSPHI2
            AUX=AUX*R**2
! TODO: CHECK IF AUX IS ZERO OUTSIDE OF R_AUG
            CALL RADIAL$INTEGRAL(GID1,NR1,AUX,SVAL)
            S(IAT1,LN1,LN2)=SVAL
          ENDDO
        ENDDO
        DEALLOCATE(PSPHI1)
        DEALLOCATE(AEPHI1)
        DEALLOCATE(PSPHI2)
        DEALLOCATE(AEPHI2)
        DEALLOCATE(AUX)
        DEALLOCATE(R)
      ENDDO
      ! IPRO=0
      ! WRITE(*,FMT='(6A10)')'IAT','ISP','LN','L','M','IPRO'
      ! DO IAT1=1,SIM(1)%NAT
      !   ISP1=SIM(1)%ISPECIES(IAT1)
      !   DO LN1=1,SIM(1)%LNX(ISP1)
      !     L1=SIM(1)%LOX(LN1,ISP1)
      !     DO M1=1,2*L1+1
      !       IPRO=IPRO+1
      !       WRITE(*,FMT='(6I10)')IAT1,ISP1,LN1,L1,M1,IPRO
      !     ENDDO
      !   ENDDO
      ! ENDDO
                          CALL TRACE$POP
      END SUBROUTINE XAS$OVERLAPATOMMATRIX
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$POLARISATION  ! MARK: XAS$POLARISATION
!     **************************************************************************
!     **  CALCULATE POLARISATION FROM K VECTOR, SURFACE NORMAL,               **
!     **  AND POLARISATION OF INCIDENT LIGHT                                  **
!     **************************************************************************
      USE XAS_MODULE, ONLY: SPECTRUM,SPECTRUMARR,SETTINGS
      IMPLICIT NONE
      REAL(8), PARAMETER :: TOL=1.D-10
      INTEGER(4) :: ISPEC
      REAL(8) :: KVEC(3)
      REAL(8) :: WORK(3)
      REAL(8) :: WORK2(3)
      REAL(8) :: SVAR
!     **************************************************************************
                          CALL TRACE$PUSH('XAS$POLARISATION')
      IF(.NOT.ALLOCATED(SPECTRUMARR)) THEN
        CALL ERROR$MSG('NO SPECTRUM AVAILABLE')
        CALL ERROR$STOP('XAS$POLARISATION')
      END IF
!     LOOP OVER SPECTRA
      DO ISPEC=1,SETTINGS%NSPEC
        SPECTRUM=>SPECTRUMARR(ISPEC)
!       AVOID CALCULATION OF CARTHESIAN POLARISATION IF IT WAS SET IN CNTL FILE
        IF(SPECTRUM%TPOLXYZ) CYCLE
        KVEC=SPECTRUM%KDIR
        CALL CROSS_PROD(KVEC,SPECTRUM%NORMAL,WORK)
        SVAR=NORM2(WORK)
        IF(SVAR.LT.TOL) THEN
          CALL ERROR$MSG('K VECTOR AND SURFACE NORMAL ARE PARALLEL')
          CALL ERROR$MSG('POLARISATION VECTOR SET TO ARBITRARY ORTHOGONAL VECTOR')
          CALL VEC_ORTHO(KVEC,WORK)
          SVAR=NORM2(WORK)
        END IF
        WORK=WORK/SVAR
        CALL CROSS_PROD(WORK,KVEC,WORK2)
        WORK2=WORK2/NORM2(WORK2)
        SPECTRUM%POLXYZ=SPECTRUM%POL(1)*WORK+ &
      &                 SPECTRUM%POL(2)*WORK2
        SVAR=SQRT(SUM(ABS(SPECTRUM%POLXYZ)**2))
        SPECTRUM%POLXYZ=SPECTRUM%POLXYZ/SVAR
      ENDDO
                          CALL TRACE$POP
      END SUBROUTINE XAS$POLARISATION
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$DIPOLEMATRIX ! MARK: XAS$DIPOLEMATRIX
!     **************************************************************************
!     ** CALCULATE DIPOLE MATRIX ELEMENTS IN EXCITED ORBITAL BASIS            **
!     ** SIMULATION 2 IS THE EXCITED STATE, SIMULATION 1 IS THE GROUND STATE  **
!     **************************************************************************
      USE XAS_MODULE, ONLY: SETTINGS,SIM,SETUP_TYPE,STATE_TYPE,OVERLAP, &
&                           OVERLAPARR,TRSTRT,ATOMMAP,KMAP,NKPTG
      IMPLICIT NONE
      LOGICAL(4), PARAMETER :: TTEST=.FALSE.
      REAL(8), PARAMETER :: PI=4.D0*ATAN(1.D0)
      INTEGER(4) :: NFIL
      INTEGER(4) :: IATOM ! ATOM WITH CORE HOLE
      INTEGER(4) :: ISP   ! SETUP INDEX OF ATOM WITH CORE HOLE
      TYPE(SETUP_TYPE), POINTER :: STP ! POINTER TO SETUP
      TYPE(STATE_TYPE), POINTER :: STATE
      INTEGER(4) :: N
      INTEGER(4) :: IB
      INTEGER(4) :: LN
      INTEGER(4) :: NR
      REAL(8), ALLOCATABLE :: AEPSI(:) ! (NR) ATOMIC RADIAL PART
      REAL(8) :: GAUNT(3)
      INTEGER(4) :: LLCORE ! LL OF CORE HOLE
      INTEGER(4) :: LLVAL ! LL OF VALENCE ORBITAL
      INTEGER(4) :: L
      INTEGER(4) :: M
      INTEGER(4) :: IKPT
      INTEGER(4) :: ISPIN
      INTEGER(4) :: IPRO
      REAL(8), ALLOCATABLE :: RADINT(:) ! (LNX(ISP)) RADIAL INTEGRAL VALUES
      REAL(8), ALLOCATABLE :: R(:)
      REAL(8), ALLOCATABLE :: WORK(:)
      COMPLEX(8) :: CVAR(3)
      INTEGER(4) :: NTASKS,THISTASK
!     **************************************************************************
      !     CALCULATION NOT NECESSARY WITH RESTART FILE
      IF(TRSTRT) RETURN
                          CALL TRACE$PUSH('XAS$DIPOLEMATRIX')
                          CALL TIMING$CLOCKON('XAS$DIPOLEMATRIX')
      IF(TTEST) THEN
        CALL FILEHANDLER$UNIT('PROT',NFIL)
        WRITE(NFIL,'(80("#"))')
        WRITE(NFIL,FMT='(A)')'DIPOLE MATRIX CALCULATION'
        WRITE(NFIL,'(80("#"))')
      END IF
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      IATOM=ATOMMAP(SETTINGS%IATOM)
      ISP=SIM(2)%ISPECIES(IATOM)
      STP=>SIM(2)%SETUP(ISP)
      CALL RADIAL$GETI4(STP%GID,'NR',NR)
      ALLOCATE(AEPSI(NR))
      ALLOCATE(R(NR))
      CALL RADIAL$R(STP%GID,NR,R)
      ALLOCATE(WORK(NR))
!     ==========================================================================
!     == SELECT CORRECT RADIAL PART FOR CORE ORBITAL                          ==
!     == NOTE: THIS ASSUME THE FOLLOWING STRUCTURE                            ==
!     ==       |IB | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |10 |                  ==
!     ==       |---|---|---|---|---|---|---|---|---|---|---|                  ==
!     ==       | N | 1 | 2 | 2 | 3 | 3 | 3 | 4 | 4 | 4 | 4 |                  ==
!     ==       | L | 0 | 0 | 1 | 0 | 1 | 2 | 0 | 1 | 2 | 3 |                  ==
!     ==========================================================================
      N=0
      DO IB=1,STP%NBATOM
        IF(STP%LATOM(IB).EQ.0) N=N+1
        IF(N.EQ.SETTINGS%NCORE.AND.STP%LATOM(IB).EQ.SETTINGS%LCORE) THEN
          AEPSI(:)=STP%AEPSI(:,IB)
          IF(TTEST) WRITE(NFIL,FMT='(A10,I10)')'INDEX RAD:',IB
        END IF
      ENDDO
! WARING: THIS ASSUMES THAT THE CORE ORBITAL IS AN S ORBITAL
! TODO: GENERALISE TO ARBITRARY ORBITALS
! ERROR: DOES IT REQUIRE A PHASE ON THE CORE ORBITAL?
      CALL LLOFLM(SETTINGS%LCORE,0,LLCORE)
      IF(TTEST) WRITE(NFIL,FMT='(A10,I10)')'LLCORE:',LLCORE
!     PRE-CALCULATE RADIAL INTEGRALS
      ALLOCATE(RADINT(SIM(2)%LNX(ISP)))
      DO LN=1,SIM(2)%LNX(ISP)
        WORK=STP%AEPHI(:,LN)*R**3*AEPSI
        CALL RADIAL$INTEGRAL(STP%GID,NR,WORK,RADINT(LN))
      ENDDO
!     LOOP OVER K POINTS
      DO IKPT=1,NKPTG
        IF(KMAP(IKPT).NE.THISTASK) CYCLE
!       LOOP OVER SPIN
        DO ISPIN=1,SIM(2)%NSPIN
          STATE=>SIM(2)%STATEARR(IKPT,ISPIN)
          OVERLAP=>OVERLAPARR(IKPT,ISPIN)
          ALLOCATE(OVERLAP%DIPOLE(3,STATE%NB))
          IF(TTEST) WRITE(NFIL,FMT='(A10,I10,A10,I10)')'IKPT:',IKPT,'ISPIN:',ISPIN
!         LOOP OVER BANDS
          DO IB=1,STATE%NB
            IF(TTEST) WRITE(NFIL,FMT='(A10,I10)')'BAND:',IB
            CVAR=(0.D0,0.D0)
            DO LN=1,SIM(2)%LNX(ISP)
              L=SIM(2)%LOX(LN,ISP)
              IPRO=SIM(2)%MAP(IATOM,LN)
              DO M=-L,L
                IPRO=IPRO+1
                CALL LLOFLM(L,M,LLVAL)
!               CALCULATE GAUNT COEFFICIENT VECTOR
!               X COMPONENT
                CALL SPHERICAL$GAUNT(LLVAL,2,LLCORE,GAUNT(1))
!               Y COMPONENT
                CALL SPHERICAL$GAUNT(LLVAL,4,LLCORE,GAUNT(2))
!               Z COMPONENT
                CALL SPHERICAL$GAUNT(LLVAL,3,LLCORE,GAUNT(3))
                CVAR=CVAR+CONJG(STATE%PROJ(1,IB,IPRO))*RADINT(LN)*GAUNT
              ENDDO
            ENDDO
            CVAR=SQRT(4.D0*PI/3.D0)*CVAR
            IF(TTEST) WRITE(NFIL,FMT='(A10,3(F8.5,SP,F8.5,"I ",S))')'DIPOLE:',CVAR(:)
            OVERLAP%DIPOLE(:,IB)=CVAR
          ENDDO ! END LOOP OVER BANDS
        ENDDO ! END LOOP OVER SPINS
      ENDDO ! END LOOP OVER K POINTS          
      DEALLOCATE(AEPSI)
      DEALLOCATE(R)
      DEALLOCATE(WORK)
      DEALLOCATE(RADINT)
                          CALL TIMING$CLOCKOFF('XAS$DIPOLEMATRIX')
                          CALL TRACE$POP
      END SUBROUTINE XAS$DIPOLEMATRIX
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$ADET ! MARK: XAS$ADET
!     **************************************************************************
!     ** CALCULATE DETERMINANT ADET FOR OCCUPIED OVERLAP MATRIX               **
!     **************************************************************************
      USE XAS_MODULE, ONLY: OVERLAP,OVERLAPARR,SIM,KMAP,NKPTG
      IMPLICIT NONE
      INTEGER(4) :: IKPT
      INTEGER(4) :: ISPIN
      INTEGER(4) :: NTASKS,THISTASK
!     **************************************************************************
                          CALL TRACE$PUSH('XAS$ADET')
                          CALL TIMING$CLOCKON('XAS$ADET')
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      DO IKPT=1,NKPTG
        IF(KMAP(IKPT).NE.THISTASK) CYCLE
        DO ISPIN=1,SIM(1)%NSPIN
          OVERLAP=>OVERLAPARR(IKPT,ISPIN)
          SIM(1)%STATE=>SIM(1)%STATEARR(IKPT,ISPIN)
          CALL LIB$DETC8(SIM(1)%STATE%NOCC,OVERLAP%OVOCC,OVERLAP%ADET)
          ! WRITE(*,*)'ADET:',OVERLAP%ADET
        ENDDO
      ENDDO
                          CALL TIMING$CLOCKOFF('XAS$ADET')
                          CALL TRACE$POP
      END SUBROUTINE XAS$ADET
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$KMAT  ! MARK: XAS$KMAT
!     **************************************************************************
!     ** CALCULATE K MATRIX FOR XAS CALCULATION                               **
!     **************************************************************************
      USE XAS_MODULE, ONLY: OVERLAP,OVERLAPARR,SIM,KMAP,NKPTG
      IMPLICIT NONE
      INTEGER(4) :: IKPT
      INTEGER(4) :: ISPIN
      INTEGER(4) :: NOCC
      INTEGER(4) :: NB1,NB2
      COMPLEX(8), ALLOCATABLE :: WORK(:,:)
      INTEGER(4) :: NTASKS,THISTASK
!     **************************************************************************
                          CALL TRACE$PUSH('XAS$KMAT')
                          CALL TIMING$CLOCKON('XAS$KMAT')
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      DO IKPT=1,NKPTG
        IF(KMAP(IKPT).NE.THISTASK) CYCLE
        DO ISPIN=1,SIM(1)%NSPIN
          OVERLAP=>OVERLAPARR(IKPT,ISPIN)
          SIM(1)%STATE=>SIM(1)%STATEARR(IKPT,ISPIN)
          SIM(2)%STATE=>SIM(2)%STATEARR(IKPT,ISPIN)
          NOCC=SIM(1)%STATE%NOCC
          NB1=SIM(1)%STATE%NB
          NB2=SIM(2)%STATE%NB
          ALLOCATE(OVERLAP%KMAT(NB2-NOCC,NOCC))
          ALLOCATE(WORK(NOCC,NOCC))
          CALL LIB$INVERTC8(NOCC,OVERLAP%OVOCC,WORK)
          CALL LIB$MATMULC8(NB2-NOCC,NOCC,NOCC,OVERLAP%OVEMP,WORK,OVERLAP%KMAT)
          DEALLOCATE(WORK)
        ENDDO
      ENDDO
                          CALL TIMING$CLOCKOFF('XAS$KMAT')
                          CALL TRACE$POP
      END SUBROUTINE XAS$KMAT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$OUTPUT  ! MARK: XAS$OUTPUT
!     **************************************************************************
!     ** OUTPUT XAS DATA TO FILE                                               **
!     **************************************************************************
      USE XAS_MODULE, ONLY: SPECTRUM,SPECTRUMARR,SETTINGS,OUTPUT,SIM, &
     &                      OVERLAP,OVERLAPARR,STATE_TYPE
      IMPLICIT NONE
      INTEGER(4) :: NFIL
      INTEGER(4) :: ISPEC
      INTEGER(4) :: I
      INTEGER(4) :: IFINAL
      REAL(8) :: EV
      INTEGER(4) :: IKPT,ISPIN
      INTEGER(4) :: NB1,NB2,NOCC
      REAL(8) :: SVAR
      REAL(8), ALLOCATABLE :: ISUM(:,:) ! SUM OF SPECTRUM OVER K POINTS
      TYPE(STATE_TYPE), POINTER :: STATE1,STATE2
      INTEGER(4) :: NTASKS,THISTASK
!     **************************************************************************
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      IF(THISTASK.NE.1) RETURN
                          CALL TRACE$PUSH('XAS$OUTPUT')
                          CALL TIMING$CLOCKON('XAS$OUTPUT')
      CALL CONSTANTS('EV',EV)
! WARNING: THERE IS A MAXIMUM LINE LENGTH THAT CAN CRASH THE PROGRAM
!          RECL=1000 IN PAW_FILEHANDLER.F90, LINE 721
      IF(OUTPUT%TKPTSPIN.AND.SIM(1)%NKPT*SIM(1)%NSPIN.GT.70) THEN
        CALL FILEHANDLER$UNIT('PROT',NFIL)
        WRITE(NFIL,FMT='(A)')'WARNING: LINE LENGTH TOO LONG FOR OUTPUT, SWITCHING TO TOTAL SPECTRUM'
        OUTPUT%TKPTSPIN=.FALSE.
      END IF   
      DO ISPEC=1,SETTINGS%NSPEC
        SPECTRUM=>SPECTRUMARR(ISPEC)
!       OPEN FILE
        CALL XAS$FILEHANDLER(ISPEC,'XASOUT','O')
        CALL FILEHANDLER$UNIT('XASOUT',NFIL)
        IF(OUTPUT%TKPTSPIN) THEN
          WRITE(NFIL,FMT='(A14)',ADVANCE='NO') '# ENERGY[EV] |'
          DO IKPT=1,SIM(1)%NKPT
            DO ISPIN=1,SIM(1)%NSPIN
              WRITE(NFIL,FMT='(A4,I4,A4,I1,A1)',ADVANCE='NO') ' KP=',IKPT,' SP=',ISPIN,'|'
            ENDDO
          ENDDO
          WRITE(NFIL,*)
          DO I=1,SETTINGS%NE
            WRITE(NFIL,FMT='(E14.7E2)',ADVANCE='NO')SPECTRUM%E(I)/EV
            DO IKPT=1,SIM(1)%NKPT
              DO ISPIN=1,SIM(1)%NSPIN
                WRITE(NFIL,FMT='(E14.7E2)',ADVANCE='NO')SPECTRUM%I(IKPT,ISPIN,I)
              ENDDO
            ENDDO
            WRITE(NFIL,*)
          ENDDO
        ELSE
          ALLOCATE(ISUM(SETTINGS%NE,3))
          ISUM=0.D0
          DO IKPT=1,SIM(1)%NKPT
            ISUM(:,:)=ISUM(:,:)+SPECTRUM%ICONV(IKPT,:,:)
          ENDDO
          DO I=1,SETTINGS%NE
            WRITE(NFIL,*) SPECTRUM%E(I)/EV,ISUM(I,:)
          ENDDO
          DEALLOCATE(ISUM)
        END IF
!       CLOSE FILE
        CALL XAS$FILEHANDLER(ISPEC,'XASOUT','C')
      ENDDO   
      IF(OUTPUT%TRAW) THEN
        DO ISPEC=1,SETTINGS%NSPEC
          SPECTRUM=>SPECTRUMARR(ISPEC)
          CALL XAS$FILEHANDLER(ISPEC,'XASRAW','O')
          CALL FILEHANDLER$UNIT('XASRAW',NFIL)
          DO IKPT=1,SIM(1)%NKPT
            DO ISPIN=1,SIM(1)%NSPIN
              NB2=SIM(2)%STATEARR(IKPT,ISPIN)%NB
              NOCC=SIM(1)%STATEARR(IKPT,ISPIN)%NOCC
              WRITE(NFIL,FMT='(A10,I5,A10,I3)')'# KPOINT=',IKPT,' SPIN=',ISPIN
              WRITE(NFIL,FMT='(3A14)')'# ENERGY','CROSSSECTION','FINAL BAND'
              DO IFINAL=1,NB2-NOCC
                I=IFINAL+NOCC
                WRITE(NFIL,*)SPECTRUM%ERAW(IKPT,ISPIN,IFINAL)/EV, &
&                            SPECTRUM%IRAW(IKPT,ISPIN,IFINAL),I
              ENDDO
            ENDDO
          ENDDO
          CALL XAS$FILEHANDLER(ISPEC,'XASRAW','C')
        ENDDO
      END IF

      DO IKPT=1,SIM(1)%NKPT
        DO ISPIN=1,SIM(1)%NSPIN
          OVERLAP=>OVERLAPARR(IKPT,ISPIN)
          STATE1=>SIM(1)%STATEARR(IKPT,ISPIN)
          STATE2=>SIM(2)%STATEARR(IKPT,ISPIN)
          NB1=STATE1%NB
          NB2=STATE2%NB
          NOCC=STATE1%NOCC
          IF(NOCC.NE.STATE2%NOCC) THEN
            CALL ERROR$MSG('NUMBER OF OCCUPIED STATES NOT THE SAME')
            CALL ERROR$MSG('SHOULD HAVE BEEN CAUGHT EARLIER')
            CALL ERROR$STOP('XAS$OUTPUT')
          END IF
! ERROR: THERE IS A MAXIMUM LINE LENGTH THAT CAN CRASH THE PROGRAM
!        EFFECTED BY SIZE OF SECOND WRITEMATC8 ARGUMENT
          IF(OUTPUT%TOVL) THEN
            ! CALL WRITEMATC8ABS(NB2,NB1,OVERLAP%OV,'OVL',IKPT,ISPIN)
            CALL WRITEMATC8(NB2,NB1,OVERLAP%OV,'OVL',IKPT,ISPIN)
          END IF
          IF(OUTPUT%TOVLPW) THEN
            ! CALL WRITEMATC8ABS(NB2,NB1,OVERLAP%PW,'OVLPW',IKPT,ISPIN)
            CALL WRITEMATC8(NB2,NB1,OVERLAP%PW,'OVLPW',IKPT,ISPIN)
          END IF
          IF(OUTPUT%TOVLAUG) THEN
            ! CALL WRITEMATC8ABS(NB2,NB1,OVERLAP%AUG,'OVLAUG',IKPT,ISPIN)
            CALL WRITEMATC8(NB2,NB1,OVERLAP%AUG,'OVLAUG',IKPT,ISPIN)
          END IF
          IF(OUTPUT%TOVLOCC) THEN
            ! CALL WRITEMATC8ABS(NOCC,NOCC,OVERLAP%OVOCC,'OVLOCC',IKPT,ISPIN)
            CALL WRITEMATC8(NOCC,NOCC,OVERLAP%OVOCC,'OVLOCC',IKPT,ISPIN)
          END IF
          IF(OUTPUT%TOVLEMP) THEN
            ! CALL WRITEMATC8ABS(NB2-NOCC,NOCC,OVERLAP%OVEMP,'OVLEMP',IKPT,ISPIN)
            CALL WRITEMATC8(NB2-NOCC,NOCC,OVERLAP%OVEMP,'OVLEMP',IKPT,ISPIN)
          END IF
          IF(OUTPUT%TKMAT) THEN
            ! CALL WRITEMATC8ABS(NB2-NOCC,NOCC,OVERLAP%KMAT,'KMAT',IKPT,ISPIN)
            CALL WRITEMATC8(NB2-NOCC,NOCC,OVERLAP%KMAT,'KMAT',IKPT,ISPIN)
          END IF
          IF(OUTPUT%TDIPOLE) THEN
            ! CALL WRITEMATC8ABS(NB2,3,TRANSPOSE(OVERLAP%DIPOLE),'DIPOLE',IKPT,ISPIN)
            CALL WRITEMATC8(NB2,3,TRANSPOSE(OVERLAP%DIPOLE),'DIPOLE',IKPT,ISPIN)
          END IF
          IF(OUTPUT%TADET) THEN
            CALL FILEHANDLER$UNIT('ADET',NFIL)
            WRITE(NFIL,FMT='(A,I5,A,I3)')'# KPOINT:',IKPT,' SPIN:',ISPIN
            WRITE(NFIL,FMT='("(",F14.8,",",F14.8,")")')OVERLAP%ADET
          END IF
        ENDDO
      ENDDO
!     WRITE BINARY FILES
      IF(OUTPUT%TBINARY) THEN
        IF(OUTPUT%TOVL)    CALL BINCOMPMAT('OVL')
        IF(OUTPUT%TOVLPW)  CALL BINCOMPMAT('OVLPW')
        IF(OUTPUT%TOVLAUG) CALL BINCOMPMAT('OVLAUG')
        IF(OUTPUT%TOVLOCC) CALL BINCOMPMAT('OVLOCC')
        IF(OUTPUT%TOVLEMP) CALL BINCOMPMAT('OVLEMP')
        IF(OUTPUT%TKMAT)   CALL BINCOMPMAT('KMAT')
        IF(OUTPUT%TDIPOLE) CALL BINCOMPMAT('DIPOLE')
      END IF
                          CALL TIMING$CLOCKOFF('XAS$OUTPUT')
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE XAS$OUTPUT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$AUXORB  ! MARK: XAS$AUXORB
!     **************************************************************************
!     ** CALCULATE AUXILIARY ORBITALS OF XAS CALCULATION                      **
!     **************************************************************************
      USE XAS_MODULE, ONLY: SETTINGS,AUXORB,AUXORBARR,SIM,NKPTG,RTASK,OVERLAP, &
&                           OVERLAPARR
      IMPLICIT NONE
      INTEGER(4) :: IAUX
      INTEGER(4) :: NB
      INTEGER(4) :: NOCC
      INTEGER(4) :: K
      INTEGER(4) :: S
      INTEGER(4) :: SOPPOSITE
      INTEGER(4) :: BAND
      INTEGER(4) :: EBAND
      CHARACTER(256) :: FILE
      INTEGER(4) :: NFIL
      INTEGER(4) :: NTASKS,THISTASK
      INTEGER(4) :: IB
      COMPLEX(8), ALLOCATABLE :: VAL(:)
      INTEGER(4), ALLOCATABLE :: BANDARR(:)
      INTEGER(4), ALLOCATABLE :: IND(:)
      COMPLEX(8) :: ADETOPP
!     **************************************************************************
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      IF(THISTASK.NE.RTASK) RETURN
                          CALL TRACE$PUSH('XAS$AUXORB')
!     LOOP THROUGH AUXILIARY ORBITALS
      DO IAUX=1,SETTINGS%NAUXORB
        AUXORB=>AUXORBARR(IAUX)
        FILE=AUXORB%FILE
!       CHECK IF K POINT SELECTION IS VALID
        K=AUXORB%K
        IF(K.LE.0.OR.K.GT.NKPTG) THEN
          CALL ERROR$MSG('INVALID K POINT INDEX')
          CALL ERROR$I4VAL('K',K)
          CALL ERROR$I4VAL('NKPT',NKPTG)
          CALL ERROR$STOP('XAS$AUXORB')
        END IF
!       CHECK IF SPIN SELECTION IS VALID
        S=AUXORB%S
        IF(S.LE.0.OR.S.GT.SIM(1)%NSPIN) THEN
          CALL ERROR$MSG('INVALID SPIN INDEX')
          CALL ERROR$I4VAL('S',S)
          CALL ERROR$I4VAL('NSPIN',SIM(1)%NSPIN)
          CALL ERROR$STOP('XAS$AUXORB')
        END IF
        NB=SIM(2)%STATEARR(K,S)%NB
        NOCC=SIM(2)%STATEARR(K,S)%NOCC
!       CHECK IF BAND SELECTION IS VALID AND UNOCCUPIED
        BAND=AUXORB%BAND
        IF(BAND.LE.0.OR.BAND.GT.NB) THEN
          CALL ERROR$MSG('INVALID BAND INDEX')
          CALL ERROR$I4VAL('BAND',BAND)
          CALL ERROR$I4VAL('NOCC',NOCC)
          CALL ERROR$I4VAL('NB',NB)
          CALL ERROR$STOP('XAS$AUXORB')
        END IF
        IF(BAND.LE.NOCC) THEN
          CALL ERROR$MSG('BAND MUST BE UNOCCUPIED')
          CALL ERROR$I4VAL('BAND',BAND)
          CALL ERROR$I4VAL('NOCC',NOCC)
          CALL ERROR$STOP('XAS$AUXORB')
        END IF
        EBAND=BAND-NOCC
! !       CHECK NUMBER OF CONTRIBUTING ORBITALS
!         IF(AUXORB%NORB.EQ.-1) THEN
!           AUXORB%NORB=NB-NOCC
!         ELSE IF(AUXORB%NORB.GT.NB-NOCC) THEN
!           AUXORB%NORB=NB-NOCC
!         ELSE IF(AUXORB%NORB.LT.-1.OR.AUXORB%NORB.EQ.0) THEN
!           CALL ERROR$MSG('INVALID NUMBER OF ORBITALS')
!           CALL ERROR$I4VAL('NORB',AUXORB%NORB)
!           CALL ERROR$STOP('XAS$AUXORB')
!         END IF
!       OPEN FILE
        CALL FILEHANDLER$SETFILE('AUXORB',.FALSE.,TRIM(FILE))
        CALL FILEHANDLER$SETSPECIFICATION('AUXORB','STATUS','REPLACE')
        CALL FILEHANDLER$SETSPECIFICATION('AUXORB','POSITION','REWIND')
        CALL FILEHANDLER$SETSPECIFICATION('AUXORB','ACTION','WRITE')
        CALL FILEHANDLER$SETSPECIFICATION('AUXORB','FORM','FORMATTED')
        CALL FILEHANDLER$UNIT('AUXORB',NFIL)
! TODO: CHECK CORRECT FORMULATION OF ORBITALS
        ! IF(SIM(1)%NSPIN.EQ.1) THEN
        !   SOPPOSITE=1
        ! ELSE
        !   SOPPOSITE=MOD(S,2)+1
        ! END IF
        ! ADETOPP=OVERLAPARR(K,SOPPOSITE)%ADET
        OVERLAP=>OVERLAPARR(K,S)
        ALLOCATE(VAL(NOCC+1))
        ALLOCATE(BANDARR(NOCC+1))
        ALLOCATE(IND(NOCC+1))
        DO IB=1,NOCC
          VAL(IB)=-OVERLAP%KMAT(EBAND,IB)
          BANDARR(IB)=IB
        ENDDO
        VAL(NOCC+1)=1.D0
        VAL=VAL*OVERLAP%ADET*(-1.D0)**NOCC !*ADETOPP
        BANDARR(NOCC+1)=BAND
        CALL SORT$INDEXARRAY(NOCC+1,ABS(VAL),IND)

        WRITE(NFIL, &
     &   FMT='("# AUXILIARY ORBITALS K=",I5," S=",I2," BAND=",I4)')K,S,BAND
        WRITE(NFIL,FMT='(A5, 2A14)') '#BAND', 'REAL', 'IMAG'
        DO IB=NOCC+1,1,-1
          WRITE(NFIL,FMT='(I5, 2F14.8)') BANDARR(IND(IB)), REAL(VAL(IND(IB))), &
     &                                   AIMAG(VAL(IND(IB)))
        ENDDO
        DEALLOCATE(VAL)
        DEALLOCATE(BANDARR)
        DEALLOCATE(IND)
!       CLOSE FILE
        CALL FILEHANDLER$CLOSE('AUXORB')
      END DO
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE XAS$AUXORB
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$OUTPUTGATHER  ! MARK: XAS$OUTPUTGATHER
!     **************************************************************************
!     ** GATHER XAS DATA FROM ALL TASKS AND WRITE TO FILE                     **
!     **************************************************************************
      USE MPE_MODULE
      USE XAS_MODULE, ONLY: OUTPUT,SIM,NKPTG,NSIM,KMAP,RTASK,OVERLAP,OVERLAPARR
      IMPLICIT NONE
      INTEGER(4) :: IKPT
      INTEGER(4) :: ISPIN
      INTEGER(4) :: IS
      INTEGER(4) :: NTASKS,THISTASK
!     **************************************************************************
                          CALL TRACE$PUSH('XAS$OUTPUTGATHER')
                          CALL TIMING$CLOCKON('XAS$OUTPUTGATHER')
      CALL MPE$QUERY('~',NTASKS,THISTASK)
!     SEND NOCC AND NB TO READ TASK
      DO IS=1,NSIM
        DO IKPT=1,NKPTG
          IF(KMAP(IKPT).NE.THISTASK.AND.THISTASK.NE.RTASK) CYCLE
          DO ISPIN=1,SIM(1)%NSPIN
            SIM(IS)%STATE=>SIM(IS)%STATEARR(IKPT,ISPIN)
            CALL MPE$SENDRECEIVE('~',KMAP(IKPT),RTASK,SIM(IS)%STATE%NOCC)
            CALL MPE$SENDRECEIVE('~',KMAP(IKPT),RTASK,SIM(IS)%STATE%NB)
          ENDDO
        ENDDO
      ENDDO
      DO IKPT=1,NKPTG
        IF(KMAP(IKPT).NE.THISTASK.AND.THISTASK.NE.RTASK) CYCLE
        DO ISPIN=1,SIM(1)%NSPIN
          OVERLAP=>OVERLAPARR(IKPT,ISPIN)
          SIM(1)%STATE=>SIM(1)%STATEARR(IKPT,ISPIN)
          SIM(2)%STATE=>SIM(2)%STATEARR(IKPT,ISPIN)
!         OVERLAP PW AND AUG MANDATORY FOR RESTART FILE
          IF(.NOT.ALLOCATED(OVERLAP%PW)) THEN
            ALLOCATE(OVERLAP%PW(SIM(2)%STATE%NB,SIM(1)%STATE%NB))
          END IF
          CALL MPE$SENDRECEIVE('~',KMAP(IKPT),RTASK,OVERLAP%PW)
          IF(.NOT.ALLOCATED(OVERLAP%AUG)) THEN
            ALLOCATE(OVERLAP%AUG(SIM(2)%STATE%NB,SIM(1)%STATE%NB))
          END IF
          CALL MPE$SENDRECEIVE('~',KMAP(IKPT),RTASK,OVERLAP%AUG)

          IF(OUTPUT%TOVL) THEN
            IF(.NOT.ALLOCATED(OVERLAP%OV)) THEN
              ALLOCATE(OVERLAP%OV(SIM(2)%STATE%NB,SIM(1)%STATE%NB))
            END IF
            CALL MPE$SENDRECEIVE('~',KMAP(IKPT),RTASK,OVERLAP%OV)
          END IF
          IF(OUTPUT%TOVLOCC) THEN
            IF(.NOT.ALLOCATED(OVERLAP%OVOCC)) THEN
              ALLOCATE(OVERLAP%OVOCC(SIM(2)%STATE%NOCC,SIM(1)%STATE%NOCC))
            END IF
            CALL MPE$SENDRECEIVE('~',KMAP(IKPT),RTASK,OVERLAP%OVOCC)
          END IF
          IF(OUTPUT%TOVLEMP) THEN
            IF(.NOT.ALLOCATED(OVERLAP%OVEMP)) THEN
              ALLOCATE(OVERLAP%OVEMP(SIM(2)%STATE%NB-SIM(2)%STATE%NOCC,SIM(1)%STATE%NOCC))
            END IF
            CALL MPE$SENDRECEIVE('~',KMAP(IKPT),RTASK,OVERLAP%OVEMP)
          END IF
          IF(OUTPUT%TKMAT) THEN
            IF(.NOT.ALLOCATED(OVERLAP%KMAT)) THEN
              ALLOCATE(OVERLAP%KMAT(SIM(2)%STATE%NB-SIM(2)%STATE%NOCC,SIM(1)%STATE%NOCC))
            END IF
            CALL MPE$SENDRECEIVE('~',KMAP(IKPT),RTASK,OVERLAP%KMAT)
          END IF
          IF(OUTPUT%TDIPOLE) THEN
            IF(.NOT.ALLOCATED(OVERLAP%DIPOLE)) THEN
              ALLOCATE(OVERLAP%DIPOLE(3,SIM(2)%STATE%NB))
            END IF
            CALL MPE$SENDRECEIVE('~',KMAP(IKPT),RTASK,OVERLAP%DIPOLE)
          END IF
          IF(OUTPUT%TADET) THEN
            CALL MPE$SENDRECEIVE('~',KMAP(IKPT),RTASK,OVERLAP%ADET)
          END IF
        ENDDO
      ENDDO
                          CALL TIMING$CLOCKOFF('XAS$OUTPUTGATHER')
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE XAS$OUTPUTGATHER
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$GETCH(ID,VAL)  ! MARK: XAS$GETCH
!     **************************************************************************
!     ** GET CHARACTER IN XAS MODULE                                          **
!     **************************************************************************
      USE XAS_MODULE, ONLY: THIS, SELECTED
      IMPLICIT NONE
      CHARACTER(*) ,INTENT(IN) :: ID
      CHARACTER(*),INTENT(OUT):: VAL
!     **************************************************************************
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SIMULATION SELECTED')
        CALL ERROR$STOP('XAS$GETCH')
      END IF
      IF(ID.EQ.'FILE') THEN
        VAL=THIS%FILE
      ELSE IF(ID.EQ.'FLAG') THEN
        VAL=THIS%FLAG
      ELSE IF(ID.EQ.'ID') THEN
        VAL=THIS%ID
      ELSE
        CALL ERROR$MSG('ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID',ID)
        CALL ERROR$STOP('XAS$GETCH')
      END IF
      RETURN
      END SUBROUTINE XAS$GETCH
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$SETCH(ID,VAL)  ! MARK: XAS$SETCH
!     **************************************************************************
!     ** SET CHARACTER IN XAS MODULE                                          **
!     **************************************************************************
      USE XAS_MODULE, ONLY: THIS, SELECTED
      IMPLICIT NONE
      CHARACTER(*) ,INTENT(IN) :: ID
      CHARACTER(*) ,INTENT(IN):: VAL
!     **************************************************************************
      IF(.NOT.SELECTED) THEN
        CALL ERROR$MSG('NO SIMULATION SELECTED')
        CALL ERROR$STOP('XAS$SETCH')
      END IF
      IF(ID.EQ.'FILE') THEN
        THIS%FILE=VAL
      ELSE IF(ID.EQ.'FLAG') THEN
        THIS%FLAG=VAL
      ELSE IF(ID.EQ.'ID') THEN
        THIS%ID=VAL
      ELSE
        CALL ERROR$MSG('ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID',ID)
        CALL ERROR$STOP('XAS$SETCH')
      END IF
      RETURN
      END SUBROUTINE XAS$SETCH
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$WRITEPHI(NFIL,ISP,ID)  ! MARK: XAS$WRITEPHI
!     **************************************************************************
!     **                                                                      **
!     **************************************************************************
      USE XAS_MODULE, ONLY: THIS  ! SELECTS SIMULATION
      IMPLICIT NONE
      INTEGER(4)  ,INTENT(IN) :: NFIL
      INTEGER(4), INTENT(IN) :: ISP ! SELECT SETUP
      CHARACTER(*) ,INTENT(IN) :: ID ! SELECT AEPHI OR PSPHI
      INTEGER(4) :: NR
      INTEGER(4) :: IR
      REAL(8), ALLOCATABLE :: R(:) ! (NR)
      REAL(8), ALLOCATABLE :: PSI(:,:) ! (NR,LNX)
      INTEGER(4) :: NTASKS,THISTASK
!     **************************************************************************
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      IF(THISTASK.NE.1) RETURN
      CALL RADIAL$GETI4(THIS%SETUP(ISP)%GID,'NR',NR)
      ALLOCATE(R(NR))
      ALLOCATE(PSI(NR,THIS%LNX(ISP)))
      CALL RADIAL$R(THIS%SETUP(ISP)%GID,NR,R)
      IF(ID.EQ.'AEPHI') THEN
        PSI=THIS%SETUP(ISP)%AEPHI
      ELSE IF(ID.EQ.'PSPHI') THEN
        PSI=THIS%SETUP(ISP)%PSPHI
      ELSE
        CALL ERROR$MSG('ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID',ID)
        CALL ERROR$STOP('XAS$WRITEPHI')
      END IF
      DO IR=1,NR
        WRITE(NFIL,*) R(IR),PSI(IR,:)
      ENDDO
      DEALLOCATE(PSI)
      DEALLOCATE(R)
      END SUBROUTINE XAS$WRITEPHI
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$MAPGRID(X,Y,N,GRID,XMIN,XMAX,DE)  ! MARK: XAS$MAPGRID
!     **************************************************************************
!     ** MAP VALUE Y AT POSITION X ONTO GRID                                  **
!     ** SPLIT BETWEEN THE TWO NEIGHBORING POINTS DEPENDING ON DISTANCE       **
!     **************************************************************************
      IMPLICIT NONE
      REAL(8), INTENT(IN) :: X
      REAL(8), INTENT(IN) :: Y
      INTEGER(4), INTENT(IN) :: N
      REAL(8), INTENT(INOUT) :: GRID(N)
      REAL(8), INTENT(IN) :: XMIN
      REAL(8), INTENT(IN) :: XMAX
      REAL(8), INTENT(IN) :: DE
      INTEGER(4) :: I1,I2
      REAL(8) :: X0
      REAL(8) :: W1,W2
!     **************************************************************************
      X0=(X-XMIN)/DE+1.D0
      I1=INT(X0)
      I2=I1+1
      W2=(X0-REAL(I1,KIND=8))
      W1=1.D0-W2
      IF(I1.GT.0.AND.I1.LE.N) GRID(I1)=GRID(I1)+Y*W1
      IF(I2.GT.0.AND.I2.LE.N) GRID(I2)=GRID(I2)+Y*W2
      RETURN
      END SUBROUTINE XAS$MAPGRID
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$FILEHANDLER(ISPEC,FILE,FLAG)  !MARK: XAS$FILEHANDLER
!     **************************************************************************
!     **  OPEN OR CLOSE FILE FOR SPECTRUM ISPEC                               **
!     **  FLAG='O' OPEN FILE, FLAG='C' CLOSE FILE                             **
!     **************************************************************************
      USE XAS_MODULE, ONLY: SPECTRUMARR,SETTINGS
      USE STRINGS_MODULE
      IMPLICIT NONE 
      INTEGER(4), INTENT(IN) :: ISPEC
      CHARACTER(*), INTENT(IN) :: FILE
      CHARACTER(1), INTENT(IN) :: FLAG

      IF(ISPEC.LT.1.OR.ISPEC.GT.SETTINGS%NSPEC)THEN
        CALL ERROR$MSG('SPECTRUM INDEX OUT OF RANGE')
        CALL ERROR$I4VAL('ISPEC',ISPEC)
        CALL ERROR$STOP('RIXS$FILE')
      END IF
      IF(FILE.NE.'XASOUT'.AND.FILE.NE.'XASRAW') THEN
        CALL ERROR$MSG('FILE MUST BE XASOUT OR XASRAW')
        CALL ERROR$CHVAL('FILE',FILE)
        CALL ERROR$STOP('XAS$FILEHANDLER')
      END IF
      IF(FLAG.EQ.'O') THEN
        IF(FILE.EQ.'XASOUT') THEN
          CALL FILEHANDLER$SETFILE(FILE,.FALSE., &
     &                           TRIM(ADJUSTL(SPECTRUMARR(ISPEC)%FILE)))
        ELSE IF(FILE.EQ.'XASRAW') THEN
          CALL FILEHANDLER$SETFILE(FILE,.FALSE., &
     &                           TRIM(ADJUSTL(SPECTRUMARR(ISPEC)%FILE))//-'RAW')
        END IF
      ELSE IF(FLAG.EQ.'C') THEN
        CALL FILEHANDLER$CLOSE(FILE)
      ELSE
        CALL ERROR$MSG('FLAG MUST BE O OR C')
        CALL ERROR$CHVAL('FLAG',FLAG)
        CALL ERROR$STOP('XAS$FILEHANDLER')
      END IF
      END SUBROUTINE XAS$FILEHANDLER
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS_COREENERGY  ! MARK: XAS_COREENERGY
!     **************************************************************************
!     ** CALCULATE CORE ENERGY FOR BOTH SIMULATIONS                           **
!     **************************************************************************
      USE XAS_MODULE, ONLY: SIM,ATOMMAP
      IMPLICIT NONE
      REAL(8) :: GSCORE
      REAL(8) :: EXCORE
      INTEGER(4) :: IAT1,IAT2
      INTEGER(4) :: ISP1,ISP2
      INTEGER(4) :: I
      REAL(8) :: E1,E2
!     **************************************************************************
      GSCORE=0.D0
      EXCORE=0.D0
      DO IAT1=1,SIM(1)%NAT
        ISP1=SIM(1)%ISPECIES(IAT1)
        IAT2=ATOMMAP(IAT1)
        ISP2=SIM(2)%ISPECIES(IAT2)
        GSCORE=GSCORE+SIM(1)%SETUP(ISP1)%ECORE
        EXCORE=EXCORE+SIM(2)%SETUP(ISP2)%ECORE
      ENDDO
      SIM(1)%ECORE=GSCORE
      SIM(2)%ECORE=EXCORE
      RETURN
      END SUBROUTINE XAS_COREENERGY
        
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE LLOFLM(L,M,LL) ! MARK: LLOFLM
!     **************************************************************************
!     ** CALCULATE LL=L*L+L-M+1                                               **
!     **************************************************************************
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: L
      INTEGER(4), INTENT(IN) :: M
      INTEGER(4), INTENT(OUT) :: LL
!     **************************************************************************
      LL=L*L+L-M+1
      RETURN
      END SUBROUTINE LLOFLM
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE LORENTZCONV(N,X,Y,GAMMA)  ! MARK: LORENTZCONV
!     **************************************************************************
!     ** CALCULATE CONVOLUTION WITH LORENTZIAN FUNCTION                       **
!     ** L(X,X0,GAMMA)=(Y/2)/(PI*((X-X0)**2+(GAMMA/2)**2))                    **
!     **************************************************************************
      IMPLICIT NONE
      REAL(8), PARAMETER :: PI=4.D0*ATAN(1.D0)
      INTEGER(4), INTENT(IN) :: N
      REAL(8), INTENT(IN) :: X(N)
      REAL(8), INTENT(INOUT) :: Y(N)
      REAL(8), INTENT(IN) :: GAMMA
      REAL(8) :: WORK(N)
      INTEGER(4) :: I,J
      REAL(8) :: GAMMA2
      REAL(8) :: SVAR
!     **************************************************************************
      DO I=1,N
        WORK(I)=0.D0
        GAMMA2=0.25D0*GAMMA*GAMMA
        DO J=1,N
          SVAR=GAMMA/(2.D0*PI*((X(I)-X(J))**2+GAMMA2))
          WORK(I)=WORK(I)+Y(J)*SVAR
        ENDDO
      ENDDO
      Y=WORK
      RETURN
      END SUBROUTINE LORENTZCONV
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE GAUSSCONV(N,X,Y,SIGMA)
!     **************************************************************************
!     ** CALCULATE CONVOLUTION WITH GAUSSIAN FUNCTION                         **
!     ** G(X,X0,SIGMA)=(1/(SIGMA*SQRT(2*PI)))*EXP(-0.5*((X-X0)/SIGMA)**2)     **
!     **************************************************************************
      IMPLICIT NONE
      REAL(8), PARAMETER :: PI=4.D0*ATAN(1.D0)
      INTEGER(4), INTENT(IN) :: N
      REAL(8), INTENT(IN) :: X(N)
      REAL(8), INTENT(INOUT) :: Y(N)
      REAL(8), INTENT(IN) :: SIGMA
      REAL(8) :: WORK(N)
      INTEGER(4) :: I,J
      REAL(8) :: SVAR
!     **************************************************************************
      DO I=1,N
        WORK(I)=0.D0
        DO J=1,N
          SVAR=EXP(-0.5D0*((X(I)-X(J))/SIGMA)**2)/(SIGMA*SQRT(2.D0*PI))
          WORK(I)=WORK(I)+Y(J)*SVAR
        ENDDO
      ENDDO
      Y=WORK
      RETURN
      END SUBROUTINE GAUSSCONV
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE CROSS_PROD(A,B,C)  ! MARK: CROSS_PROD
!     **************************************************************************
!     ** CALCULATE CROSS PRODUCT OF TWO VECTORS                               **
!     **************************************************************************
      IMPLICIT NONE
      REAL(8), INTENT(IN) :: A(3)
      REAL(8), INTENT(IN) :: B(3)
      REAL(8), INTENT(OUT) :: C(3)
!     **************************************************************************
      C(1)=A(2)*B(3)-A(3)*B(2)
      C(2)=A(3)*B(1)-A(1)*B(3)
      C(3)=A(1)*B(2)-A(2)*B(1)
      RETURN
      END SUBROUTINE CROSS_PROD
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE VEC_ORTHO(A,B)  ! MARK: VEC_ORTHO
!     **************************************************************************
!     ** CALCULATE ORTHOGONAL VECTOR TO A                                      **
!     **************************************************************************
! TODO: UNDERSTAND
      IMPLICIT NONE
      REAL(8), INTENT(IN) :: A(3)
      REAL(8), INTENT(OUT) :: B(3)
      REAL(8) :: VECVAR(3)
!     **************************************************************************
      VECVAR = (/1.D0,0.D0,0.D0/)
      IF(DOT_PRODUCT(A,VECVAR).EQ.NORM2(A)) THEN
        VECVAR = (/0.D0,1.D0,0.D0/)
      END IF
      CALL CROSS_PROD(A,VECVAR,B)
      END SUBROUTINE VEC_ORTHO

      
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE WRITEMATC8(N,M,A,FLAG,IKPT,ISPIN)  ! MARK: WRITEMATC8
!     **************************************************************************
!     ** WRITE COMPLEX MATRIX TO FILE                                         **
!     **************************************************************************
      IMPLICIT NONE
! WARNING: LIMIT DUE TO RECL IN PAW_FILEHANDLER.F90, LINE 721
      INTEGER(4), PARAMETER :: RECL=1000
      INTEGER(4), PARAMETER :: LIMIT=INT(RECL/30)
      INTEGER(4), INTENT(IN) :: N
      INTEGER(4), INTENT(IN) :: M
      COMPLEX(8), INTENT(IN) :: A(N,M)
      CHARACTER(*), INTENT(IN) :: FLAG
      INTEGER(4), INTENT(IN) :: IKPT
      INTEGER(4), INTENT(IN) :: ISPIN
      INTEGER(4) :: NFIL
      INTEGER(4) :: I,J
      INTEGER(4) :: MLIM,NLIM
      CHARACTER(256) :: FORMAT
      INTEGER(4) :: NTASKS,THISTASK
!     **************************************************************************
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      IF(THISTASK.NE.1) RETURN
      CALL FILEHANDLER$UNIT(TRIM(ADJUSTL(FLAG)),NFIL)
      MLIM=MIN(LIMIT,M)
      NLIM=MIN(LIMIT,N)
      WRITE(FORMAT,*)MLIM
      FORMAT="("//TRIM(ADJUSTL(FORMAT))//'("(",F13.8,",",F13.8,") "))'
      WRITE(NFIL,FMT='(A,I5,A,I3)')'# KPOINT:',IKPT,' SPIN:',ISPIN
      DO I=1,NLIM
        WRITE(NFIL,FMT=FORMAT)A(I,1:MLIM)
      ENDDO
      RETURN
      END SUBROUTINE WRITEMATC8
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE BINCOMPMAT(ID)
!     **************************************************************************
!     ** WRITE COMPLEX MATRIX TO BINARY FILE                                  **
!     **************************************************************************
      USE XAS_MODULE, ONLY: OVERLAPARR,OVERLAP,SIM
      USE STRINGS_MODULE
      IMPLICIT NONE
      CHARACTER(*), INTENT(IN) :: ID
      INTEGER(4) :: NFIL
      INTEGER(4) :: IKPT,ISPIN
      INTEGER(4) :: NB1,NB2,NOCC
      INTEGER(4) :: THISTASK,NTASKS
      LOGICAL(4) :: TCHK
!     **************************************************************************
                          CALL TRACE$PUSH('BINCOMPMAT')
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      IF(THISTASK.NE.1) RETURN
      TCHK=.FALSE.
      IF(ID.EQ.'OVL')    TCHK=.TRUE.
      IF(ID.EQ.'OVLAUG') TCHK=.TRUE.
      IF(ID.EQ.'OVLPW')  TCHK=.TRUE.
      IF(ID.EQ.'OVLOCC') TCHK=.TRUE.
      IF(ID.EQ.'OVLEMP') TCHK=.TRUE.
      IF(ID.EQ.'KMAT')   TCHK=.TRUE.
      IF(ID.EQ.'DIPOLE') TCHK=.TRUE.
      IF(.NOT.TCHK) THEN
        CALL ERROR$MSG('ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID',ID)
        CALL ERROR$STOP('BINCOMPMAT')
      END IF

      CALL FILEHANDLER$SETFILE(ID//'BIN',.TRUE.,'.'//-ID//-'BIN')
      CALL FILEHANDLER$SETSPECIFICATION(ID//'BIN','STATUS','REPLACE')
      CALL FILEHANDLER$SETSPECIFICATION(ID//'BIN','POSITION','REWIND')
      CALL FILEHANDLER$SETSPECIFICATION(ID//'BIN','ACTION','WRITE')
      CALL FILEHANDLER$SETSPECIFICATION(ID//'BIN','FORM','UNFORMATTED')

      CALL FILEHANDLER$UNIT(ID//'BIN',NFIL)
      
      WRITE(NFIL)SIM(1)%NKPT
      WRITE(NFIL)SIM(1)%NSPIN
      DO IKPT=1,SIM(1)%NKPT
        DO ISPIN=1,SIM(1)%NSPIN
          OVERLAP=>OVERLAPARR(IKPT,ISPIN)
          NB1=SIM(1)%STATEARR(IKPT,ISPIN)%NB
          NB2=SIM(2)%STATEARR(IKPT,ISPIN)%NB
          NOCC=SIM(1)%STATEARR(IKPT,ISPIN)%NOCC
          WRITE(NFIL)NB2,NB1,NOCC
          IF(ID.EQ.'OVL') THEN
            WRITE(NFIL)OVERLAP%OV
          ELSE IF(ID.EQ.'OVLAUG') THEN
            WRITE(NFIL)OVERLAP%AUG
          ELSE IF(ID.EQ.'OVLPW') THEN
            WRITE(NFIL)OVERLAP%PW
          ELSE IF(ID.EQ.'OVLOCC') THEN
            WRITE(NFIL)OVERLAP%OVOCC
          ELSE IF(ID.EQ.'OVLEMP') THEN
            WRITE(NFIL)OVERLAP%OVEMP
          ELSE IF(ID.EQ.'KMAT') THEN
            WRITE(NFIL)OVERLAP%KMAT          
          ELSE IF(ID.EQ.'DIPOLE') THEN
            WRITE(NFIL)OVERLAP%DIPOLE
          END IF
        ENDDO
      ENDDO          
      CALL FILEHANDLER$CLOSE(ID//'BIN')
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE BINCOMPMAT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE WRITEMATC8ABS(N,M,A,FLAG,IKPT,ISPIN)  ! MARK: WRITEMATC8
!     **************************************************************************
!     ** WRITE ABSOLUTE VALUE OF COMPLEX MATRIX TO FILE                       **
!     **************************************************************************
      IMPLICIT NONE
      INTEGER(4), PARAMETER :: LIMIT=50
      INTEGER(4), INTENT(IN) :: N
      INTEGER(4), INTENT(IN) :: M
      COMPLEX(8), INTENT(IN) :: A(N,M)
      CHARACTER(*), INTENT(IN) :: FLAG
      INTEGER(4), INTENT(IN) :: IKPT
      INTEGER(4), INTENT(IN) :: ISPIN
      INTEGER(4) :: NFIL
      INTEGER(4) :: I,J
      INTEGER(4) :: MLIM,NLIM
      CHARACTER(256) :: FORMAT
      INTEGER(4) :: NTASKS,THISTASK
!     **************************************************************************
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      IF(THISTASK.NE.1) RETURN
      CALL FILEHANDLER$UNIT(TRIM(ADJUSTL(FLAG)),NFIL)
      WRITE(NFIL,FMT='(A,I5,A,I3)')'# KPOINT:',IKPT,' SPIN:',ISPIN
      MLIM=MIN(LIMIT,M)
      NLIM=MIN(LIMIT,N)
      DO I=1,NLIM
        DO J=1,MLIM
          WRITE(NFIL,FMT='(F12.8)',ADVANCE='NO')ABS(A(I,J))
          WRITE(NFIL,FMT='(A)',ADVANCE='NO')' '
        ENDDO
        WRITE(NFIL,*)
      ENDDO
      RETURN
      END SUBROUTINE WRITEMATC8ABS
! WARNING: THIS TESTS ONLY CHANGE OF SIGN AND NOT A POTENTIAL RANDOM PHASE CHANGE
!          COULD THIS HAPPEN IN A SIMULATION?
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE TEST$INVERSE
!     **************************************************************************
!     ** TEST DETERMINANT PROCEDURE FOR INDEPENDENCE OF SIGN                  **
!     **************************************************************************
      IMPLICIT NONE
      INTEGER(4) :: M1 ! TOTAL STATES OF GROUNDSTATE
      INTEGER(4) :: M2 ! TOTAL STATES OF EXCITESTATE
      INTEGER(4) :: NOCC ! NUMBER OF OCCUPIED STATES
      INTEGER(4) :: I,J
      REAL(8), ALLOCATABLE :: ARE(:,:) ! HELPER MATRIX
      REAL(8), ALLOCATABLE :: AIM(:,:) ! HELPER MATRIX
      COMPLEX(8), ALLOCATABLE :: OVLORIGINAL(:,:) ! (M2,M1) ORIGINAL OVERLAP MATRIX
      COMPLEX(8), ALLOCATABLE :: OVL(:,:) ! (M2,M1) OVERLAP MATRIX
      COMPLEX(8), ALLOCATABLE :: OVLOCC(:,:) ! (NOCC,NOCC) OCCUPIED OVERLAP MATRIX
      COMPLEX(8), ALLOCATABLE :: OVLEMP(:,:) ! (M2-NOCC,NOCC) EMPTY OVERLAP MATRIX
      COMPLEX(8), ALLOCATABLE :: INVOVLOCC(:,:) ! (NOCC,NOCC) INVERSE OCCUPIED OVERLAP MATRIX
      COMPLEX(8), ALLOCATABLE :: KMAT(:,:) ! (M2-NOCC,NOCC) K MATRIX
      COMPLEX(8) :: DET
      INTEGER(4) :: COUNT
      INTEGER(4) :: NTASKS,THISTASK
!     **************************************************************************
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      IF(THISTASK.NE.1) RETURN
      NOCC=4
      M1=4
      M2=8
      IF(M1.LT.NOCC) THEN
        CALL ERROR$MSG('NUMBER OF OCCUPIED STATES MUST BE SMALLER OR EQUAL THAN TOTAL STATES')
        CALL ERROR$STOP('TEST$INVERSE')
      END IF
      IF(M2.LE.NOCC) THEN
        CALL ERROR$MSG('NUMBER OF TOTAL STATES MUST BE LARGER THAN OCCUPIED STATES')
        CALL ERROR$STOP('TEST$INVERSE')
      END IF
      ALLOCATE(OVL(M2,M1))
      ALLOCATE(OVLORIGINAL(M2,M1))
      ALLOCATE(OVLOCC(NOCC,NOCC))
      ALLOCATE(OVLEMP(M2-NOCC,NOCC))
      ALLOCATE(ARE(M2,M1))
      ALLOCATE(AIM(M2,M1))
      ALLOCATE(INVOVLOCC(NOCC,NOCC))
      ALLOCATE(KMAT(M2-NOCC,NOCC))
!     RANDOMLY INITIALIZE OVERLAP
      CALL RANDOM_NUMBER(ARE)
      CALL RANDOM_NUMBER(AIM)
      OVLORIGINAL=CMPLX(ARE,AIM,KIND=8)

!     ## ORIGINAL MATRIX
      WRITE(*,*) '####### ORIGINAL MATRIX #######'
      OVL(:,:)=OVLORIGINAL(:,:)
!     EXTRACTION OF OCCUPIED AND EMPTY OVERLAP
      CALL TEST_SPLITOVL
      CALL LIB$INVERTC8(NOCC,OVLOCC,INVOVLOCC)
      CALL LIB$MATMULC8(M2-NOCC,NOCC,NOCC,OVLEMP,INVOVLOCC,KMAT)
      CALL LIB$DETC8(NOCC,OVLOCC,DET)
      CALL REPORT

!     ## CHANGE SIGN OF EMPTY STATE (HERE 7) IN EXCITESTATE
!     ##    - DETERMINANT: NO EFFECT
!     ##    - INVERSE OF OCCUPIED OVERLAP: NO EFFECT
!     ##    - K MATRIX: CHANGED SIGN IN ROW OF STATE 7
      WRITE(*,*) '####### CHANGE SIGN OF ROW 7 IN EXCITESTATE #######'
      OVL(:,:)=OVLORIGINAL(:,:)
      OVL(7,:)=OVL(7,:)*(-1.D0)
      CALL TEST_SPLITOVL
      CALL LIB$INVERTC8(NOCC,OVLOCC,INVOVLOCC)
      CALL LIB$MATMULC8(M2-NOCC,NOCC,NOCC,OVLEMP,INVOVLOCC,KMAT)
      CALL LIB$DETC8(NOCC,OVLOCC,DET)
      CALL REPORT

!     ## CHANGE SIGN OF OCCUPIED STATE (HERE 3) IN EXCITESTATE
!     ##    - DETERMINANT: CHANGED SIGN
!     ##    - INVERSE OF OCCUPIED OVERLAP: CHANGED SIGN IN COLUMN 3  
!     ##    - K MATRIX: CHANGED SIGN IN COLUMN 3
      WRITE(*,*) '####### CHANGE SIGN OF ROW 3 IN EXCITESTATE #######'
      OVL(:,:)=OVLORIGINAL(:,:)
      OVL(3,:)=OVL(3,:)*(-1.D0)
      CALL TEST_SPLITOVL
      CALL LIB$INVERTC8(NOCC,OVLOCC,INVOVLOCC)
      CALL LIB$MATMULC8(M2-NOCC,NOCC,NOCC,OVLEMP,INVOVLOCC,KMAT)
      CALL LIB$DETC8(NOCC,OVLOCC,DET)
      CALL REPORT

!     ## CHANGE SIGN OF OCCUPIED STATE (HERE 3) IN GROUNDSTATE
!     ##    - DETERMINANT: CHANGED SIGN
!     ##    - INVERSE OF OCCUPIED OVERLAP: CHANGED SIGN IN ROW 3
!     ##    - K MATRIX: NO EFFECT
      WRITE(*,*) '####### CHANGE SIGN OF ROW 3 IN GROUNDSTATE #######'
      OVL(:,:)=OVLORIGINAL(:,:)
      OVL(:,3)=OVL(:,3)*(-1.D0)
      CALL TEST_SPLITOVL
      CALL LIB$INVERTC8(NOCC,OVLOCC,INVOVLOCC)
      CALL LIB$MATMULC8(M2-NOCC,NOCC,NOCC,OVLEMP,INVOVLOCC,KMAT)
      CALL LIB$DETC8(NOCC,OVLOCC,DET)
      CALL REPORT


      DEALLOCATE(OVL)
      DEALLOCATE(OVLORIGINAL)
      DEALLOCATE(OVLOCC)
      DEALLOCATE(OVLEMP)
      DEALLOCATE(ARE)
      DEALLOCATE(AIM)
      DEALLOCATE(INVOVLOCC)
      DEALLOCATE(KMAT)
      CONTAINS
        SUBROUTINE TEST_SPLITOVL
        OVLOCC(:,:)=OVL(1:NOCC,1:NOCC)
        OVLEMP(:,:)=OVL(NOCC+1:M2,1:NOCC)
        RETURN
        END SUBROUTINE TEST_SPLITOVL

        SUBROUTINE REPORT
        WRITE(*,*) 'MATRIX OVL:'
        DO I=1,M2
          WRITE(*,*)OVL(I,:)
        ENDDO
        WRITE(*,*)'MATRIX OVLOCC:'
        DO I=1,NOCC
          WRITE(*,*)OVLOCC(I,:)
        ENDDO
        WRITE(*,*)'MATRIX OVLEMP:'
        DO I=1,M2-NOCC
          WRITE(*,*)OVLEMP(I,:)
        ENDDO
        WRITE(*,*) 'DETERMINANT:',DET
        WRITE(*,*) 'INVERSE OVLOCC:'
        DO I=1,NOCC
          WRITE(*,*)INVOVLOCC(I,:)
        ENDDO
        WRITE(*,*) 'K MATRIX:'
        DO I=1,M2-NOCC
          WRITE(*,*)KMAT(I,:)
        ENDDO
        RETURN
        END SUBROUTINE REPORT
      END SUBROUTINE TEST$INVERSE
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$WRITERESTART
!     **************************************************************************
!     ** WRITE RESTART DATA TO FILE                                           **
!     **************************************************************************
      USE XAS_MODULE, ONLY: SIM,OVERLAP,OVERLAPARR
      IMPLICIT NONE
      INTEGER(4) :: NFIL
      INTEGER(4) :: IKPT,ISPIN,IS
      INTEGER(4) :: THISTASK,NTASKS
!     **************************************************************************
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      IF(THISTASK.NE.1) RETURN
                          CALL TRACE$PUSH('XAS$WRITERESTART')
                          CALL TIMING$CLOCKON('XAS$WRITERESTART')
      CALL FILEHANDLER$UNIT('RSTRT_OUT',NFIL)
      REWIND NFIL
      DO IS=1,2
!       WRITE NKPT,NSPIN,NDIM,ETOT (HAVE TO BE THE SAME FOR BOTH SIMULATIONS)
        WRITE(NFIL)SIM(IS)%NKPT,SIM(IS)%NSPIN,SIM(IS)%NDIM,SIM(IS)%ETOT
      ENDDO
      DO IS=1,2
!       WRITE WKPT (HAS TO BE THE SAME FOR BOTH SIMULATIONS)
        WRITE(NFIL)SIM(IS)%WKPT
      ENDDO
      ! WRITE NB,EIG
      DO IS=1,2
        DO IKPT=1,SIM(IS)%NKPT
          DO ISPIN=1,SIM(IS)%NSPIN
            WRITE(NFIL)SIM(IS)%STATEARR(IKPT,ISPIN)%NB
            WRITE(NFIL)SIM(IS)%STATEARR(IKPT,ISPIN)%NOCC
            WRITE(NFIL)SIM(IS)%STATEARR(IKPT,ISPIN)%EIG
          ENDDO
        ENDDO
      ENDDO

      ! WRITE OVERLAP
      DO IKPT=1,SIM(1)%NKPT
        DO ISPIN=1,SIM(1)%NSPIN
          OVERLAP=>OVERLAPARR(IKPT,ISPIN)
          WRITE(NFIL)OVERLAP%AUG
          WRITE(NFIL)OVERLAP%PW
          WRITE(NFIL)OVERLAP%DIPOLE
        ENDDO
      ENDDO
      CALL FILEHANDLER$CLOSE('RSTRT_OUT')
                          CALL TIMING$CLOCKOFF('XAS$WRITERESTART')
                          CALL TRACE$POP
      END SUBROUTINE XAS$WRITERESTART
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$READRESTART
!     **************************************************************************
!     ** READ RESTART DATA TO FILE                                            **
!     **************************************************************************
      USE XAS_MODULE, ONLY: SIM,OVERLAP,OVERLAPARR,KMAP,NKPTG,RTASK
      USE MPE_MODULE
      IMPLICIT NONE
      INTEGER(4) :: NFIL
      INTEGER(4) :: IKPT,ISPIN,IS
      REAL(8) :: EV
      INTEGER(4) :: THISTASK,NTASKS
!     **************************************************************************
                          CALL TRACE$PUSH('XAS$READRESTART')
                          CALL TIMING$CLOCKON('XAS$READRESTART')
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      CALL CONSTANTS('EV',EV)
      IF(THISTASK.EQ.1) THEN
        CALL FILEHANDLER$UNIT('RSTRT_IN',NFIL)
        REWIND NFIL
        DO IS=1,2
!         READ NKPT,NSPIN,NDIM,ETOT (HAVE TO BE THE SAME FOR BOTH SIMULATIONS)
          READ(NFIL)SIM(IS)%NKPT,SIM(IS)%NSPIN,SIM(IS)%NDIM,SIM(IS)%ETOT
        ENDDO
      END IF
      DO IS=1,2
        CALL MPE$BROADCAST('~',1,SIM(IS)%NKPT)
        CALL MPE$BROADCAST('~',1,SIM(IS)%NSPIN)
        CALL MPE$BROADCAST('~',1,SIM(IS)%NDIM)
        CALL MPE$BROADCAST('~',1,SIM(IS)%ETOT)
        ALLOCATE(SIM(IS)%WKPT(SIM(IS)%NKPT))
      ENDDO
      NKPTG=SIM(1)%NKPT
      IF(ALLOCATED(KMAP)) THEN
        CALL ERROR$MSG('KMAP ALREADY ALLOCATED')
        CALL ERROR$STOP('XAS$READRESTART')
      END IF
      ALLOCATE(KMAP(NKPTG))
      CALL KMAPINIT(NKPTG,RTASK,KMAP)      
      IF(THISTASK.EQ.RTASK) THEN
        DO IS=1,2
!         READ WKPT (HAS TO BE THE SAME FOR BOTH SIMULATIONS)
          READ(NFIL)SIM(IS)%WKPT
        ENDDO
      END IF
      DO IS=1,2
        CALL MPE$BROADCAST('~',1,SIM(IS)%WKPT)
        IF(ALLOCATED(SIM(IS)%STATEARR)) THEN
          CALL ERROR$MSG('STATEARR ALREADY ALLOCATED')
          CALL ERROR$STOP('XAS$READRESTART')
        END IF
        ALLOCATE(SIM(IS)%STATEARR(SIM(IS)%NKPT,SIM(IS)%NSPIN))
      ENDDO
      
      DO IS=1,2
        DO IKPT=1,SIM(IS)%NKPT
          DO ISPIN=1,SIM(IS)%NSPIN
            IF(KMAP(IKPT).NE.THISTASK.AND.THISTASK.NE.RTASK) CYCLE
            IF(THISTASK.EQ.RTASK) THEN
              READ(NFIL)SIM(IS)%STATEARR(IKPT,ISPIN)%NB
              READ(NFIL)SIM(IS)%STATEARR(IKPT,ISPIN)%NOCC
            END IF
            CALL MPE$SENDRECEIVE('~',RTASK,KMAP(IKPT),SIM(IS)%STATEARR(IKPT,ISPIN)%NB)
            CALL MPE$SENDRECEIVE('~',RTASK,KMAP(IKPT),SIM(IS)%STATEARR(IKPT,ISPIN)%NOCC)
            ALLOCATE(SIM(IS)%STATEARR(IKPT,ISPIN)%EIG(SIM(IS)%STATEARR(IKPT,ISPIN)%NB))
            IF(THISTASK.EQ.RTASK) THEN
              READ(NFIL)SIM(IS)%STATEARR(IKPT,ISPIN)%EIG
            END IF
            CALL MPE$SENDRECEIVE('~',RTASK,KMAP(IKPT),SIM(IS)%STATEARR(IKPT,ISPIN)%EIG)
          ENDDO
        ENDDO
      ENDDO

      IF(ALLOCATED(OVERLAPARR)) THEN
        CALL ERROR$MSG('OVERLAPARR ALREADY ALLOCATED')
        CALL ERROR$STOP('XAS$READRESTART')
      END IF
      ALLOCATE(OVERLAPARR(SIM(1)%NKPT,SIM(1)%NSPIN))
      ! READ OVERLAP
      DO IKPT=1,SIM(1)%NKPT
        IF(KMAP(IKPT).NE.THISTASK.AND.THISTASK.NE.RTASK) CYCLE
        DO ISPIN=1,SIM(1)%NSPIN
          OVERLAP=>OVERLAPARR(IKPT,ISPIN)
          SIM(1)%STATE=>SIM(1)%STATEARR(IKPT,ISPIN)
          SIM(2)%STATE=>SIM(2)%STATEARR(IKPT,ISPIN)
          ALLOCATE(OVERLAP%PW(SIM(2)%STATE%NB,SIM(1)%STATE%NB))
          OVERLAP%PW=0.D0
          ALLOCATE(OVERLAP%AUG(SIM(2)%STATE%NB,SIM(1)%STATE%NB))
          OVERLAP%AUG=0.D0
          ALLOCATE(OVERLAP%DIPOLE(3,SIM(2)%STATE%NB))
          OVERLAP%DIPOLE=0.D0
          IF(THISTASK.EQ.RTASK) THEN
            READ(NFIL)OVERLAP%AUG
            READ(NFIL)OVERLAP%PW
            READ(NFIL)OVERLAP%DIPOLE
          END IF
          CALL MPE$SENDRECEIVE('~',RTASK,KMAP(IKPT),OVERLAP%PW)
          CALL MPE$SENDRECEIVE('~',RTASK,KMAP(IKPT),OVERLAP%AUG)
          CALL MPE$SENDRECEIVE('~',RTASK,KMAP(IKPT),OVERLAP%DIPOLE)
        ENDDO
      ENDDO
      IF(THISTASK.EQ.RTASK) THEN
        CALL FILEHANDLER$CLOSE('RSTRT_IN')
        CALL FILEHANDLER$UNIT('PROT',NFIL)
        WRITE(NFIL,'(80("#"))')
        WRITE(NFIL,FMT='(A)')'RESTART DATA READ'
        WRITE(NFIL,'(80("#"))')
        WRITE(NFIL,FMT='(A10,I10)')'NKPT:',SIM(1)%NKPT
        WRITE(NFIL,FMT='(A10,I10)')'NSPIN:',SIM(1)%NSPIN
        WRITE(NFIL,FMT='(A10,I10)')'NDIM:',SIM(1)%NDIM
        WRITE(NFIL,FMT='(A10,F20.10)')'ETOT 1:',SIM(1)%ETOT/EV
        WRITE(NFIL,FMT='(A10,F20.10)')'ETOT 2:',SIM(2)%ETOT/EV
      END IF
                          CALL TIMING$CLOCKOFF('XAS$READRESTART')
                          CALL TRACE$POP
      END SUBROUTINE XAS$READRESTART
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE ATOMMAPPING
!     **************************************************************************
!     ** MAP INDICES ATOMS FROM SIMULATION 1 TO SIMULATION 2                  **
!     ** MAPPING BASED ON ATOM NAMES                                          **
!     **************************************************************************
      USE XAS_MODULE, ONLY: ATOMMAP,SIM
      IMPLICIT NONE
      INTEGER(4) :: IAT1
      INTEGER(4) :: IAT2
      INTEGER(4) :: I
      LOGICAL(4) :: FOUND
!     **************************************************************************
                          CALL TRACE$PUSH('ATOMMAPPING')
      ALLOCATE(ATOMMAP(SIM(1)%NAT))
      DO IAT1=1,SIM(1)%NAT
        FOUND=.FALSE.
        DO IAT2=1,SIM(2)%NAT
          IF(SIM(1)%ATOMID(IAT1).EQ.SIM(2)%ATOMID(IAT2)) THEN
            ATOMMAP(IAT1)=IAT2
            FOUND=.TRUE.
            EXIT
          END IF
        ENDDO
        IF(.NOT.FOUND) THEN
          CALL ERROR$MSG('ATOM NOT FOUND IN SIMULATION 2')
          CALL ERROR$I4VAL('IAT1',IAT1)
          CALL ERROR$CHVAL('ATOMID',SIM(1)%ATOMID(IAT1))
          CALL ERROR$STOP('ATOMMAPPING')
        END IF
      ENDDO
                          CALL TRACE$POP
      END SUBROUTINE ATOMMAPPING

      SUBROUTINE KMAPINIT(NKPTG,RTASK,KMAP)
!     **************************************************************************
!     ** INITIALIZE KMAP ARRAY                                                **
!     **************************************************************************
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: NKPTG
      INTEGER(4), INTENT(OUT) :: RTASK
      INTEGER(4), INTENT(OUT) :: KMAP(NKPTG)
      INTEGER(4) :: NFIL
      INTEGER(4) :: NTASKS,THISTASK
      INTEGER(4) :: I
!     **************************************************************************
                          CALL TRACE$PUSH('KMAPINIT')
      CALL MPE$QUERY('~',NTASKS,THISTASK)
!     ONLY ONE TASK: 
!       BOTH READ TASK AND RESPONSIBLE FOR EVERY KPOINT
      IF(NTASKS.EQ.1) THEN
        RTASK=1
        KMAP=1
!     MORE THAN ONE TASK:
!       FIRST IS READ TASK, OTHERS ARE RESPONSIBLE FOR DIFFERENT KPOINTS
      ELSE
        RTASK=1
        DO I=1,NKPTG
          KMAP(I)=MOD(I-1,NTASKS-1)+2
        ENDDO
      END IF
      CALL FILEHANDLER$UNIT('PROT',NFIL)
      IF(THISTASK.EQ.RTASK) THEN
        WRITE(NFIL,FMT='(A12,I5)')'RW TASK:',RTASK
        WRITE(NFIL,FMT='(A12,*(I5))')'KPOINT:',(I, I=1,NKPTG)
        WRITE(NFIL,FMT='(A12,*(I5))')'KMAP:',(KMAP(I), I=1,NKPTG)
      END IF
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE KMAPINIT
! ERROR: CHECK DEFINITIONS OF NDIM, NDIMD AND EVERYTHING CONNECTED TO IT!
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$DENMAT
!     **************************************************************************
!     ** CALCULATE DENSITY MATRIX                                             **
!     **************************************************************************
      USE XAS_MODULE, ONLY: RTASK,TRSTRT,NSIM,SIM,NKPTG
      IMPLICIT NONE
      INTEGER(4) :: NTASKS,THISTASK
      INTEGER(4) :: IS
      INTEGER(4) :: NAT
      INTEGER(4) :: IAT
      INTEGER(4) :: NDIM
      INTEGER(4) :: NDIMD
      INTEGER(4) :: NSPIN
      INTEGER(4) :: ISP
      INTEGER(4) :: LMNXX
      INTEGER(4) :: LMNX
      INTEGER(4) :: IKPT
      INTEGER(4) :: ISPIN
      INTEGER(4) :: IPRO
      INTEGER(4) :: NB
      INTEGER(4) :: LMN1,LMN2
      COMPLEX(8), ALLOCATABLE :: PROJ(:,:,:)
      COMPLEX(8), ALLOCATABLE :: DENMAT1(:,:,:)
      COMPLEX(8) :: CSVAR1,CSVAR2
      INTEGER(4) :: NFIL
!     **************************************************************************
      CALL MPE$QUERY('~',NTASKS,THISTASK)
!     READTASK CONTAINS ALL DATA (COULD CALCULATE IN PARALLEL BUT MORE COMPLEX)
      IF(THISTASK.NE.RTASK) RETURN
                          CALL TRACE$PUSH('DENMAT')
                          CALL TIMING$CLOCKON('DENMAT')
      IF(TRSTRT) THEN
        CALL ERROR$MSG('DENSITY MATRIX CAN NOT BE CALCULATED FROM XASRSTRT FILE')
        CALL ERROR$STOP('DENMAT')
      END IF
!     LOOP OVER BOTH SIMULATIONS
      DO IS=1,NSIM
        NAT=SIM(IS)%NAT
        NSPIN=SIM(IS)%NSPIN
        NDIM=SIM(IS)%NDIM
        NDIMD=NSPIN
        IF(NDIM.NE.1) THEN
          CALL ERROR$MSG('DENSITY MATRIX ONLY IMPLEMENTED FOR NDIM=1')
          CALL ERROR$STOP('XAS$DENMAT')
        END IF
!       GET MAXIMUM NUMBER OF LMNX OF ALL SPECIES
        LMNXX=0
        DO ISP=1,SIM(IS)%NSP
          LMNXX=MAX(LMNXX,SIM(IS)%LMNX(ISP))
        ENDDO
        ALLOCATE(SIM(IS)%DENMAT(LMNXX,LMNXX,NDIMD,NAT))
        SIM(IS)%DENMAT=(0.D0,0.D0)
!       LOOP OVER KPOINTS AND SPINS
        DO IKPT=1,NKPTG
          DO ISPIN=1,NSPIN
!           SET POINTER TO STATE
            SIM(IS)%STATE=>SIM(IS)%STATEARR(IKPT,ISPIN)
            NB=SIM(IS)%STATE%NB
            IPRO=1
!           LOOP OVER ATOMS
            DO IAT=1,NAT
              ISP=SIM(IS)%ISPECIES(IAT)
              LMNX=SIM(IS)%LMNX(ISP)
              ALLOCATE(PROJ(NDIM,NB,LMNX))
              PROJ(:,:,:)=SIM(IS)%STATE%PROJ(:,:,IPRO:IPRO-1+LMNX)
              ALLOCATE(DENMAT1(LMNX,LMNX,NDIMD))

              CALL DENMATCALC(NDIM,NB,LMNX,SIM(IS)%STATE%OCC,PROJ,DENMAT1)

              IF(NDIM.EQ.1) THEN
                SIM(IS)%DENMAT(1:LMNX,1:LMNX,ISPIN,IAT) &
&                     =SIM(IS)%DENMAT(1:LMNX,1:LMNX,ISPIN,IAT)+DENMAT1(:,:,1)
              ELSE
                CALL ERROR$MSG('DENSITY MATRIX ONLY IMPLEMENTED FOR NDIM=1')
                CALL ERROR$STOP('XAS$DENMAT')
!                 SIM(IS)%DENMAT(1:LMNX,1:LMNX,:,IAT) &
! &                     =SIM(IS)%DENMAT(1:LMNX,1:LMNX,:,IAT)+DENMAT1(:,:,:)
              END IF
              DEALLOCATE(PROJ)
              DEALLOCATE(DENMAT1)
              IPRO=IPRO+LMNX
            ENDDO ! IAT
          ENDDO ! ISPIN
        ENDDO ! IKPT
!       CONVERT SPIN-UP AND SPIN-DOWN DENSITY MATRIX INTO
!       TOTAL AND SPIN DENSITY MATRIX
        ! IF(NSPIN.EQ.2) THEN
        !   DO IAT=1,NAT
        !     ISP=SIM(IS)%ISPECIES(IAT)
        !     LMNX=SIM(IS)%LMNX(ISP)
        !     DO LMN1=1,LMNX
        !       DO LMN2=1,LMNX
        !         CSVAR1=SIM(IS)%DENMAT(LMN1,LMN2,1,IAT)
        !         CSVAR2=SIM(IS)%DENMAT(LMN1,LMN2,2,IAT)
        !         SIM(IS)%DENMAT(LMN1,LMN2,1,IAT)=CSVAR1+CSVAR2 ! TOTAL
        !         SIM(IS)%DENMAT(LMN1,LMN2,2,IAT)=CSVAR1-CSVAR2 ! SPIN
        !       ENDDO ! LMN2
        !     ENDDO ! LMN1
        !   ENDDO ! IAT
        ! END IF
      ENDDO ! IS
                          CALL TIMING$CLOCKOFF('DENMAT')
                          CALL TRACE$POP
      END SUBROUTINE XAS$DENMAT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE DENMATCALC(NDIM,NB,LMNX,OCC,PROJ,DENMAT)
!     **************************************************************************
!     ** CALCULATE DENSITY MATRIX                                             **
!     **************************************************************************
      IMPLICIT NONE
      INTEGER(4), INTENT(IN) :: NDIM
      INTEGER(4), INTENT(IN) :: NB
      INTEGER(4), INTENT(IN) :: LMNX
      REAL(8), INTENT(IN) :: OCC(NB)
      COMPLEX(8), INTENT(IN) :: PROJ(NDIM,NB,LMNX)
      COMPLEX(8), INTENT(OUT) :: DENMAT(LMNX,LMNX,NDIM)
      COMPLEX(8) :: DENMAT1(LMNX,LMNX,NDIM,NDIM)
      INTEGER(4) :: LMN1,LMN2
      INTEGER(4) :: IDIM1,IDIM2,IDIM
      INTEGER(4) :: IB
      COMPLEX(8) :: CSVAR
      INTEGER(4) :: NFIL
      LOGICAL(4), PARAMETER :: TPR=.FALSE.
!     **************************************************************************
      IF(NDIM.NE.1) THEN
        CALL ERROR$MSG('DENSITY MATRIX ONLY IMPLEMENTED FOR NDIM=1')
        CALL ERROR$STOP('DENMATCALC')
      END IF
      DENMAT=(0.D0,0.D0)
      DENMAT1=(0.D0,0.D0)
      DO IB=1,NB
        DO LMN1=1,LMNX
          DO LMN2=1,LMNX
            DO IDIM1=1,NDIM
              DO IDIM2=1,NDIM
                DENMAT1(LMN1,LMN2,IDIM1,IDIM2)=DENMAT1(LMN1,LMN2,IDIM1,IDIM2) &
&                 +PROJ(IDIM1,IB,LMN1)*OCC(IB)*CONJG(PROJ(IDIM2,IB,LMN2))
              ENDDO ! IDIM2
            ENDDO ! IDIM1
          ENDDO ! LMN2
        ENDDO ! LMN1
      ENDDO ! IB
!     MAP DENSITY MATRIX ONTO TOTAL AND SPIN DENSITY
      IF(NDIM.EQ.1) THEN
        DO LMN1=1,LMNX
          DO LMN2=1,LMNX
            DENMAT(LMN1,LMN2,1)=DENMAT1(LMN1,LMN2,1,1)
          ENDDO
        ENDDO
      ELSE
        CALL ERROR$MSG('DENSITY MATRIX ONLY IMPLEMENTED FOR NDIM=1')
        CALL ERROR$STOP('DENMATCALC')
      END IF
!     SYMMETRIZE DENSITY MATRIX
      DO IDIM=1,NDIM
        DO LMN1=1,LMNX
          DO LMN2=1,LMNX
            CSVAR=0.5D0*(DENMAT(LMN1,LMN2,IDIM)+CONJG(DENMAT(LMN2,LMN1,IDIM)))
            DENMAT(LMN1,LMN2,IDIM)=CSVAR
            DENMAT(LMN2,LMN1,IDIM)=CONJG(CSVAR)
          ENDDO ! LMN2
        ENDDO ! LMN1
      ENDDO ! IDIM
!     SYMMETRIZE DENSITY MATRIX WITH RESPECT TO TIME INVERSION            
!     FOR COLLINEAR CALCULATIONS PSI(K)=CONJG(PSI(-K)). THEREFORE THE                          
!     DENSITY MATRIX IS REAL AFTER SUMMING OVER K-POINTS. THIS IS NOT TRUE
!     FOR TRANSPORT CALCULATIONS. THIS SYMMETRY FAILS FRO SPIN-ORBIT      
!     AND NON-COLLINEAR CALCULATIONS WHERE AN EXPLICIT MAGNETIC FIELD     
!     IS PRESENT.
      IF(NDIM.EQ.1) THEN
        DENMAT(:,:,1)=REAL(DENMAT(:,:,1),KIND=8)
      END IF
      RETURN
      END SUBROUTINE DENMATCALC
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$WRITEDENMAT
!     **************************************************************************
!     ** WRITE DENSITY MATRIX TO FILE                                         **
!     **************************************************************************
      USE XAS_MODULE, ONLY: RTASK,NSIM,SIM
      IMPLICIT NONE
      INTEGER(4) :: NFIL
      INTEGER(4) :: NTASKS,THISTASK
      INTEGER(4) :: IS
      INTEGER(4) :: IAT
      INTEGER(4) :: ISPIN
      INTEGER(4) :: LMNX
      INTEGER(4) :: LMN
      INTEGER(4) :: ISP
!     **************************************************************************
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      IF(THISTASK.NE.RTASK) RETURN
                          CALL TRACE$PUSH('XAS$WRITEDENMAT')
      CALL FILEHANDLER$UNIT('PROT',NFIL)
      DO IS=1,NSIM
        WRITE(NFIL,'(80("#"))')
        WRITE(NFIL,FMT='("DENSITY MATRICES FOR SIM ",I2)') IS
        WRITE(NFIL,'(80("#"))')
        DO IAT=1,SIM(IS)%NAT
          ISP=SIM(IS)%ISPECIES(IAT)
          LMNX=SIM(IS)%LMNX(ISP)
          DO ISPIN=1,SIM(IS)%NSPIN
            WRITE(NFIL,FMT='("DENMAT FOR ATOM ",I3,"(",A6,") AND SPIN",I2)')IAT,SIM(IS)%ATOMID(IAT),ISPIN
            DO LMN=1,LMNX
              WRITE(NFIL,FMT='("R",I3,*(F10.5))')LMN,REAL(SIM(IS)%DENMAT(LMN,:LMNX,ISPIN,IAT))
              IF(ANY(AIMAG(SIM(IS)%DENMAT(LMN,:LMNX,ISPIN,IAT)).GT.1.D-8)) THEN
                WRITE(NFIL,FMT='("I",I3,*(F10.5))')LMN,AIMAG(SIM(IS)%DENMAT(LMN,:LMNX,ISPIN,IAT))
              END IF
            ENDDO
          ENDDO
        ENDDO
      ENDDO
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE XAS$WRITEDENMAT
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      SUBROUTINE XAS$SPINCONV
!     **************************************************************************
!     ** SPIN CONVOLUTION FOR NSPIN=2                                         **
!     ** TOTAL = I(UP) * |ADET(DOWN)|^2 + I(DOWN) * |ADET(UP)|^2              **
!     ** SPIN CONVOLUTION FOR NSPIN=1 (I(UP)=I(DOWN), ADET(UP)=ADET(DOWN))    **
!     ** TOTAL = 2 * I * |ADET|^2                                             **
!     **************************************************************************
      USE XAS_MODULE, ONLY: SPECTRUM,SPECTRUMARR,SIM,RTASK,SETTINGS,OVERLAP,OVERLAPARR,NKPTG
      IMPLICIT NONE
      INTEGER(4) :: NTASKS,THISTASK
      INTEGER(4) :: ISPEC
      INTEGER(4) :: IKPT
      INTEGER(4) :: ISPIN
      INTEGER(4) :: ISPINOPPOSITE
!     **************************************************************************
      CALL MPE$QUERY('~',NTASKS,THISTASK)
      IF(THISTASK.NE.RTASK) RETURN
                          CALL TRACE$PUSH('XAS$SPINCONV')
      DO ISPEC=1,SETTINGS%NSPEC
        SPECTRUM=>SPECTRUMARR(ISPEC)
        ALLOCATE(SPECTRUM%ICONV(SIM(1)%NKPT,SETTINGS%NE,3))
        SPECTRUM%ICONV=0.D0
        DO IKPT=1,NKPTG
          DO ISPIN=1,SIM(1)%NSPIN
!           NSPIN=1: BOTH SPIN CHANNELS ARE EQUAL AND TOTAL IS TWICE THE VALUE
            IF(SIM(1)%NSPIN.EQ.1) THEN
              OVERLAP=>OVERLAPARR(IKPT,ISPIN)
              SPECTRUM%ICONV(IKPT,:,1)=SPECTRUM%ICONV(IKPT,:,1)+ &
     &                        2.D0*SPECTRUM%I(IKPT,ISPIN,:)*ABS(OVERLAP%ADET)**2
              SPECTRUM%ICONV(IKPT,:,2)=0.5D0*SPECTRUM%ICONV(IKPT,:,1)
              SPECTRUM%ICONV(IKPT,:,3)=0.5D0*SPECTRUM%ICONV(IKPT,:,1)
            ELSE
!             NSPIN=2: UP=I(UP)*|ADET(DOWN)|^2, DOWN=I(DOWN)*|ADET(UP)|^2
!                      TOTAL=UP+DOWN
              ISPINOPPOSITE=MOD(ISPIN,2)+1
              OVERLAP=>OVERLAPARR(IKPT,ISPINOPPOSITE)
!             ISPIN=1 -> ISPINOPPOSITE=2, ISPIN=2 -> ISPINOPPOSITE=1
              SPECTRUM%ICONV(IKPT,:,ISPIN+1)=SPECTRUM%ICONV(IKPT,:,ISPIN+1)+ &
     &                             SPECTRUM%I(IKPT,ISPIN,:)*ABS(OVERLAP%ADET)**2
              SPECTRUM%ICONV(IKPT,:,1)=SPECTRUM%ICONV(IKPT,:,1)+ &
     &                             SPECTRUM%I(IKPT,ISPIN,:)*ABS(OVERLAP%ADET)**2
            END IF
          ENDDO
        ENDDO
      ENDDO
                          CALL TRACE$POP
      RETURN
      END SUBROUTINE XAS$SPINCONV